<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>快乐暑假第10天——学习ES6 | Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今日小结  用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。   使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。   不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，">
<meta property="og:type" content="article">
<meta property="og:title" content="快乐暑假第10天——学习ES6">
<meta property="og:url" content="http://yoursite.com/2019/07/18/快乐暑假第10天——学习ES6/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:description" content="今日小结  用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。   使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。   不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-28T01:44:40.739Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="快乐暑假第10天——学习ES6">
<meta name="twitter:description" content="今日小结  用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。   使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。   不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-快乐暑假第10天——学习ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/快乐暑假第10天——学习ES6/" class="article-date">
  <time datetime="2019-07-18T13:04:59.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      快乐暑假第10天——学习ES6
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，并且二者相互独立，不会互相影响。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h1><h2 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了let命令，用来声明变量。用法类似于var，但是<strong>所声明的变量，只在let命令所在的代码块内有效。</strong></p>
<ul>
<li><p>for循环的计数器，就很合适使用let命令。在for循环内定义的计数器变量不会影响到外部变量。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量(JavaScript 引擎内部会记住上一轮循环的值)。</li>
<li>for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
</ul>
</li>
</ul>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>let声明的变量一定要在<strong>声明后使用</strong>，否则报错。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内<strong>存在let命令</strong>，它所声明的变量就“绑定”（binding）这个区域，<strong>不受外部的影响</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就<strong>形成了封闭作用域</strong>。凡是在声明之前就使用这些变量，就会报错。</li>
<li>语法上，称为“暂时性死区”。</li>
</ul>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作：</p>
<ul>
<li>如果在用let声明的变量之前对其使用typeOf，则会报错</li>
<li>如果一个变量根本没有被声明，使用typeof反而不会报错(在没有let之前，typeof运算符是百分之百安全的)</li>
</ul>
<p>有些“死区”比较隐蔽，不太容易发现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = x;  <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;  <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在变量x的声明语句还没有执行完成前，就去取x的值，导致报错“x 未定义”</li>
</ul>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。因此<strong>不能在函数内部重新声明参数</strong>。</p>
<h2 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景：</p>
<ul>
<li>内层变量可能会覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>let实际上为 JavaScript 新增了块级作用域，外层代码块不受内层代码块的影响。</p>
<p>块级作用域必须有<strong>大括号</strong>。</p>
<p>块级作用域的出现，使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<p>块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<p>考虑到环境导致的行为差异太大，应该<strong>避免在块级作用域内声明函数</strong>。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明一个<strong>只读</strong>的常量，一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须<strong>立即初始化</strong>，不能留到以后赋值。</p>
<p>与let特性相似：</p>
<ul>
<li>只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
</ul>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
<ul>
<li><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
</li>
<li><p>对于复合类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const<strong>只能保证这个指针是固定的</strong>（即总是指向另一个固定的地址），至于它<strong>指向的数据结构是不是可变的，就完全不能控制了</strong>。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错，不能改变指针的指向</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果真的想将对象冻结，应该使用Object.freeze方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>;     <span class="comment">// 常规模式时不起作用；严格模式时会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>var命令和function命令、let命令和const命令、import命令和class命令。</p>
<h2 id="1-4-顶层对象的属性"><a href="#1-4-顶层对象的属性" class="headerlink" title="1.4 顶层对象的属性"></a>1.4 顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的，这带来了各种各样的问题。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<strong>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</strong>。</p>
<h2 id="1-5-globalThis-对象"><a href="#1-5-globalThis-对象" class="headerlink" title="1.5 globalThis 对象"></a>1.5 globalThis 对象</h2><p>在有一个提案，在语言标准的层面，<strong>引入globalThis作为顶层对象</strong>。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p>
<p>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</p>
<h1 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h1><h2 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中<strong>提取值</strong>，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</li>
<li>本质上，这种写法属于 <strong>“模式匹配”</strong> ，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</li>
</ul>
<p>如果<strong>解构不成功</strong>，变量的值就等于undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>以上两种情况都属于解构不成功，foo的值都会等于undefined。</li>
</ul>
<p>另一种情况是<strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个例子，都属于不完全解构，但是可以成功。</li>
</ul>
<p>如果等号的右边不是数组（严格地说，不是可遍历的结构），那么将会报错。</p>
<p>事实上，只要某种数据结构<strong>具有 Iterator 接口</strong>，都可以采用数组形式的解构赋值。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值<strong>允许指定默认值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>

<p>ES6 内部<strong>使用严格相等运算符（===）</strong>，判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>因为x能取到值，所以函数f根本不会执行。</li>
</ul>
<p>默认值可以引用解构赋值的其他变量，但该变量<strong>必须已经声明</strong>。</p>
<h2 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再<strong>赋给对应的变量</strong>。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</li>
</ul>
<p>与数组一样，解构也<strong>可以用于嵌套结构的对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;    <span class="comment">//foo这时等于undefined，再取子属性就会报错</span></span><br></pre></td></tr></table></figure>

<p>对象的解构赋值<strong>可以取到继承的属性</strong>。</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。默认值生效的条件是，<strong>对象的属性值严格等于undefined</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有<strong>不将大括号写在行首</strong>，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。</p>
</li>
<li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-数值和布尔值的解构赋值"><a href="#2-4-数值和布尔值的解构赋值" class="headerlink" title="2.4 数值和布尔值的解构赋值"></a>2.4 数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就<strong>先将其转为对象</strong>。由于<strong>undefined和null无法转为对象</strong>，所以对它们进行解构赋值，都会报错。</p>
<h2 id="2-5-函数参数的解构赋值"><a href="#2-5-函数参数的解构赋值" class="headerlink" title="2.5 函数参数的解构赋值"></a>2.5 函数参数的解构赋值</h2><h2 id="2-6-圆括号问题"><a href="#2-6-圆括号问题" class="headerlink" title="2.6 圆括号问题"></a>2.6 圆括号问题</h2><p>建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号：</p>
<ol>
<li>变量声明语句</li>
<li>函数参数</li>
<li>赋值语句的模式</li>
</ol>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<h2 id="2-7-用途"><a href="#2-7-用途" class="headerlink" title="2.7 用途"></a>2.7 用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数参数的定义</li>
</ol>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<ol start="4">
<li>提取 JSON 数据</li>
<li>函数参数的默认值</li>
<li>遍历 Map 结构</li>
<li>输入模块的指定方法</li>
</ol>
<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-5-模板字符串"><a href="#3-5-模板字符串" class="headerlink" title="3.5 模板字符串"></a>3.5 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/快乐暑假第10天——学习ES6/" data-id="cjyql0woj0005vsuwgb9mb1bo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/19/快乐暑假第11天/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          快乐暑假第11天
        
      </div>
    </a>
  
  
    <a href="/2019/07/17/快乐暑假第9天——学习移动端网页制作/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">快乐暑假第9天——学习移动端网页制作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
          </li>
        
          <li>
            <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
          </li>
        
          <li>
            <a href="/2019/07/28/快乐暑假第18天——继续学习nodejs/">快乐暑假第18天——继续学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/26/快乐暑假第17天——开始学习nodejs/">快乐暑假第17天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第16天——继续做Bolo/">快乐暑假第16天——继续做Bolo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>