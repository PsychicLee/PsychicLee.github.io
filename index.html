<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lee&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lee&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-快乐暑假第20天——学习nodejs模块化和express框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/" class="article-date">
  <time datetime="2019-07-31T01:26:04.000Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Node-js-模块化"><a href="#Node-js-模块化" class="headerlink" title="Node.js 模块化"></a>Node.js 模块化</h1><h2 id="模块内部"><a href="#模块内部" class="headerlink" title="模块内部"></a>模块内部</h2><ul>
<li>require - 引入模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>exports - 输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports.a = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>module.exports - 批量输出</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>,</span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="require-的参数"><a href="#require-的参数" class="headerlink" title="require 的参数"></a>require 的参数</h2><p>引用自定义模块时，一般情况下写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./xxx.js</span><br></pre></td></tr></table></figure>

<p>其中，.js 后缀可以省略</p>
<ul>
<li>如果省略 “./“ ，会默认在系统模块中寻找，找不到则报错</li>
<li>如果将自定义模块文件放在 node_modules 文件夹里，也可以省略 “./“ </li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>用来下载模块，会自动解决依赖问题。</p>
<p>也可以上传自己的模块。</p>
<h1 id="Node-js-express"><a href="#Node-js-express" class="headerlink" title="Node.js express"></a>Node.js express</h1><p>express 是非破坏式的，即保留了原生的功能，在此基础上又添加了一些更方便的功能(增强原有的功能)。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>创建服务</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = express();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>监听</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.lesten(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>处理请求</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.ues(<span class="string">'地址'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//处理的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>一共有三种处理方法：<ul>
<li>.get()  - 用于get请求</li>
<li>.post() - 用于post请求</li>
<li>.use() - 两种请求都可以使用</li>
</ul>
</li>
</ul>
<h2 id="express-static"><a href="#express-static" class="headerlink" title="express-static"></a>express-static</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">static</span>  = <span class="built_in">require</span>(<span class="string">'static'</span>);</span><br><span class="line">server.use(<span class="keyword">static</span>(<span class="string">'访问的路径'</span>));</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/" data-id="cjyql0wop000avsuwyzkra8o3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第19天——学习nodejs处理两种请求" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/" class="article-date">
  <time datetime="2019-07-29T12:42:37.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="12-Node-js-GET-POST请求"><a href="#12-Node-js-GET-POST请求" class="headerlink" title="12. Node.js GET/POST请求"></a>12. Node.js GET/POST请求</h1><h2 id="获取GET请求内容"><a href="#获取GET请求内容" class="headerlink" title="获取GET请求内容"></a>获取GET请求内容</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">    res.write(<span class="string">'hello world!'</span>);</span><br><span class="line">    res.end(util.inspect(params));</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取-POST-请求内容"><a href="#获取-POST-请求内容" class="headerlink" title="获取 POST 请求内容"></a>获取 POST 请求内容</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    req.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data+=chunk</span><br><span class="line">    &#125;)</span><br><span class="line">    req.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>,&#123;<span class="string">"Content-Type"</span>:<span class="string">'application/json'</span>&#125;);</span><br><span class="line">        res.end(<span class="string">'post sucess!'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>一般来说，get请求由于数据量少，因此可以直接采用第一方法去解析，但是第二种方法也可以解析get请求。</li>
<li>post请求由于数据较多，需要将数据分段来进行传输，因此需要用第二种方法去解析post请求。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/" data-id="cjyql0woo0009vsuw82zvrhpn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第18天——继续学习nodejs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/28/快乐暑假第18天——继续学习nodejs/" class="article-date">
  <time datetime="2019-07-28T12:52:49.000Z" itemprop="datePublished">2019-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/28/快乐暑假第18天——继续学习nodejs/">快乐暑假第18天——继续学习nodejs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="4-Node-js-事件循环"><a href="#4-Node-js-事件循环" class="headerlink" title="4. Node.js 事件循环"></a>4. Node.js 事件循环</h1><h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p>
<p>有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>
<h2 id="Node-应用程序的工作方式"><a href="#Node-应用程序的工作方式" class="headerlink" title="Node 应用程序的工作方式"></a>Node 应用程序的工作方式</h2><p>在 Node 应用程序中，执行异步操作的函数<strong>将回调函数作为最后一个参数</strong>，<strong>回调函数接收错误对象作为第一个参数</strong>。</p>
<h1 id="5-Node-js-EventEmitter"><a href="#5-Node-js-EventEmitter" class="headerlink" title="5. Node.js EventEmitter"></a>5. Node.js EventEmitter</h1><h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是<strong>事件触发与事件监听器功能的封装</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure>

<ul>
<li>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。</li>
<li>当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</li>
</ul>
<p>EventEmitter 的<strong>每个事件由一个事件名和若干个参数组成</strong>，事件名是一个字符串，通常表达一定的语义。</p>
<ul>
<li>对于每个事件，EventEmitter 支持若干个事件监听器。</li>
<li>当事件触发时，注册到这个事件的事件监听器被<strong>依次调用</strong>，<strong>事件参数作为回调函数参数传递</strong>。</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">addListener(event, listener)</td>
<td align="left">为指定事件添加一个监听器到监听器数组的尾部。</td>
</tr>
<tr>
<td align="left">on(event, listener)</td>
<td align="left">为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</td>
</tr>
<tr>
<td align="left">once(event, listener)</td>
<td align="left">为指定事件注册一个单次监听器，即监听器最多只会触发一次。</td>
</tr>
<tr>
<td align="left">removeListener(event, listener)</td>
<td align="left">移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。接受两个参数，第一个是事件名称，第二个是回调函数名称。</td>
</tr>
<tr>
<td align="left">removeAllListeners([event])</td>
<td align="left">移除所有事件的所有监听器，如果指定事件，则移除指定事件的所有监听器。</td>
</tr>
<tr>
<td align="left">setMaxListeners(n)</td>
<td align="left">用于提高监听器的默认（10个）限制的数量。</td>
</tr>
<tr>
<td align="left">listeners(event)</td>
<td align="left">返回指定事件的监听器数组。</td>
</tr>
<tr>
<td align="left">emit(event, [arg1], [arg2], […])</td>
<td align="left">按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</td>
</tr>
</tbody></table>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">listenerCount(emitter, event)</td>
<td align="left">返回指定事件的监听器数量。</td>
</tr>
</tbody></table>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><ul>
<li>newListener<ul>
<li>event - 字符串，事件名称</li>
<li>listener - 处理事件函数</li>
</ul>
</li>
</ul>
<p>该事件在添加新监听器时被触发。</p>
<ul>
<li>removeListener<ul>
<li>event - 字符串，事件名称</li>
<li>listener - 处理事件函数</li>
</ul>
</li>
</ul>
<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p>
<h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>在遇到异常的时候通常会触发 error 事件。此时如果没有响应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>一般要<strong>为会触发 error 事件的对象设置监听器</strong>，避免遇到错误后整个程序崩溃。</p>
<h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
<h1 id="6-Node-js-Buffer-缓冲区"><a href="#6-Node-js-Buffer-缓冲区" class="headerlink" title="6. Node.js Buffer(缓冲区)"></a>6. Node.js Buffer(缓冲区)</h1><p>在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p>
<h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><ul>
<li>Buffer 提供了以下 API 来创建 Buffer 类：Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li>
<li>Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li>
<li>Buffer.allocUnsafeSlow(size)</li>
<li>Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li>
<li>Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li>Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li>Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</li>
</ul>
<h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>string - 写入缓冲区的字符串。</li>
<li>offset - 缓冲区开始写入的索引值，默认为 0 。</li>
<li>length - 写入的字节数，默认为 buffer.length。</li>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。</li>
</ul>
<p>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</p>
<h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure>

<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。</li>
<li>start - 指定开始读取的索引位置，默认为 0。</li>
<li>end - 结束位置，默认为缓冲区的末尾。</li>
</ul>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>解码缓冲区数据并使用指定的编码返回字符串。</p>
<p>将 Buffer 转换为 JSON 对象</p>
<h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>

<p>当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>返回 JSON 对象。</p>
<h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>

<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul>
<li>list - 用于合并的 Buffer 对象数组列表。</li>
<li>totalLength - 指定合并后Buffer对象的总长度。</li>
</ul>
<h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>返回一个多个成员合并的新 Buffer 对象。</p>
<h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.compare(otherBuffer);</span><br></pre></td></tr></table></figure>

<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><ul>
<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</li>
</ul>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</p>
<h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span><br></pre></td></tr></table></figure>

<h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul>
<li>targetBuffer - 要拷贝的 Buffer 对象。</li>
<li>targetStart - 数字, 可选, 默认: 0</li>
<li>sourceStart - 数字, 可选, 默认: 0</li>
<li>sourceEnd - 数字, 可选, 默认: buffer.length</li>
</ul>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>没有返回值。</p>
<h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.slice([start[, end]])</span><br></pre></td></tr></table></figure>

<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><ul>
<li>start - 数字, 可选, 默认: 0</li>
<li>end - 数字, 可选, 默认: buffer.length</li>
</ul>
<h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。</p>
<h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.length;</span><br></pre></td></tr></table></figure>

<h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>返回 Buffer 对象所占据的内存长度。</p>
<h1 id="7-Node-js-Stream-流"><a href="#7-Node-js-Stream-流" class="headerlink" title="7. Node.js Stream(流)"></a>7. Node.js Stream(流)</h1><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。</p>
<p>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。</li>
<li>Writable - 可写操作。</li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li>finish - 所有数据已被写入到底层系统时触发。</li>
</ul>
<h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p>
<h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。</p>
<h1 id="8-Node-js模块系统"><a href="#8-Node-js模块系统" class="headerlink" title="8. Node.js模块系统"></a>8. Node.js模块系统</h1><p>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的，即<strong>一个 Node.js 文件就是一个模块</strong>。(这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展)</p>
<p>Node.js 提供了 exports 和 require 两个对象，其中 <strong>exports 是模块公开的接口</strong>，<strong>require 用于从外部获取一个模块的接口</strong>，即所获取模块的 exports 对象。</p>
<h1 id="9-Node-js-全局对象"><a href="#9-Node-js-全局对象" class="headerlink" title="9. Node.js 全局对象"></a>9. Node.js 全局对象</h1><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 <strong>Node.js 中的全局对象是 global</strong>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<h2 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h2><p><strong>global 最根本的作用是作为全局变量的宿主</strong>。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量</li>
<li>全局对象的属性</li>
<li>隐式定义的变量（未定义直接赋值的变量）</li>
</ul>
<p>定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。</p>
<ul>
<li>在 Node.js 中不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。</li>
<li>最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</li>
</ul>
<h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><p>表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
<h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><p>表示当前执行脚本所在的目录。</p>
<h2 id="setTimeout-cb-ms"><a href="#setTimeout-cb-ms" class="headerlink" title="setTimeout(cb, ms)"></a>setTimeout(cb, ms)</h2><p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>
<ul>
<li>setTimeout() 只执行一次指定函数。</li>
<li>返回一个代表定时器的句柄值。</li>
</ul>
<h2 id="clearTimeout-t"><a href="#clearTimeout-t" class="headerlink" title="clearTimeout(t)"></a>clearTimeout(t)</h2><p>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。</p>
<ul>
<li>参数 t 是通过 setTimeout() 函数创建的定时器。</li>
</ul>
<h2 id="setInterval-cb-ms"><a href="#setInterval-cb-ms" class="headerlink" title="setInterval(cb, ms)"></a>setInterval(cb, ms)</h2><p>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>
<ul>
<li>返回一个代表定时器的句柄值。</li>
<li>可以使用 clearInterval(t) 函数来清除定时器。</li>
<li>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li>
</ul>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>用于提供控制台标准输出。</p>
<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。</p>
<ul>
<li><strong>exit</strong> - 当进程准备退出时触发。</li>
<li><strong>beforeExit</strong> - 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</li>
<li><strong>uncaughtException</strong> - 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</li>
<li><strong>Signal 事件</strong> - 当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</li>
</ul>
<h1 id="10-Node-js-常用工具"><a href="#10-Node-js-常用工具" class="headerlink" title="10. Node.js 常用工具"></a>10. Node.js 常用工具</h1><h2 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h2><figure class="highlight plain"><figcaption><span>superConstructor)``` 是一个实现对象间原型继承的函数。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## util.inspect</span><br><span class="line">```util.inspect(object,[showHidden],[depth],[colors])``` 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。</span><br><span class="line">- 至少接受一个参数 object，即要转换的对象。</span><br><span class="line">- showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</span><br><span class="line">- depth 表示最大递归的层数，如果对象很复杂，可以指定层数以控制输出信息的多 少。</span><br><span class="line">    - 如果不指定depth，默认会递归2层</span><br><span class="line">    - 指定为 null 表示将不限递归层数完整遍历对象。</span><br><span class="line">- 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。</span><br><span class="line"></span><br><span class="line">util.inspect 并不会简单地直接把对象转换为字符串，即使该对象定义了 toString 方法也不会调用。</span><br><span class="line"></span><br><span class="line">## util.isArray(object)</span><br><span class="line">如果给定的参数 &quot;object&quot; 是一个数组返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">## util.isRegExp(object)</span><br><span class="line">如果给定的参数 &quot;object&quot; 是一个正则表达式返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">## util.isDate(object)</span><br><span class="line">如果给定的参数 &quot;object&quot; 是一个日期返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">## util.isError(object)</span><br><span class="line">如果给定的参数 &quot;object&quot; 是一个错误对象返回true，否则返回false。</span><br><span class="line"></span><br><span class="line"># 11. Node.js 文件系统</span><br><span class="line">Node 导入文件系统模块(fs)语法：</span><br></pre></td></tr></table></figure>

<p>var fs = require(“fs”)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 异步和同步</span><br><span class="line">Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本,异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。</span><br><span class="line"></span><br><span class="line">## 打开文件</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.open(path, flags[, mode], callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- path - 文件的路径。</span><br><span class="line">- flags - 文件打开的行为。</span><br><span class="line">- mode - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</span><br><span class="line">- callback - 回调函数，带有两个参数如：callback(err, fd)。</span><br><span class="line"></span><br><span class="line">## 获取文件信息</span><br><span class="line">## 语法</span><br></pre></td></tr></table></figure>

<p>fs.stat(path, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 参数</span><br><span class="line">- path - 文件路径。</span><br><span class="line">- callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。</span><br><span class="line"></span><br><span class="line">fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。</span><br><span class="line"></span><br><span class="line">## 写入文件</span><br></pre></td></tr></table></figure>

<p>fs.writeFile(file, data[, options], callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">writeFile 直接打开文件默认是 w 模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- file - 文件名或文件描述符。</span><br><span class="line">- data - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</span><br><span class="line">- options - 该参数是一个对象，包含 &#123;encoding, mode, flag&#125;。默认编码为 utf8, 模式为 0666 ， flag 为 &apos;w&apos;</span><br><span class="line">- callback - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</span><br><span class="line"></span><br><span class="line">## 读取文件</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.read(fd, buffer, offset, length, position, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该方法使用了文件描述符来读取文件。</span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- fd - 通过 fs.open() 方法返回的文件描述符。</span><br><span class="line">- buffer - 数据写入的缓冲区。</span><br><span class="line">- offset - 缓冲区写入的写入偏移量。</span><br><span class="line">- length - 要从文件中读取的字节数。</span><br><span class="line">- position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</span><br><span class="line">- callback - 回调函数，有三个参数err（错误信息）, bytesRead（读取的字节数）, buffer（缓冲区对象）。</span><br><span class="line"></span><br><span class="line">## 关闭文件</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.close(fd, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该方法使用了文件描述符来读取文件。</span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- fd - 通过 fs.open() 方法返回的文件描述符。</span><br><span class="line">- callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">## 截取文件</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.ftruncate(fd, len, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">该方法使用了文件描述符来读取文件。</span><br><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- fd - 通过 fs.open() 方法返回的文件描述符。</span><br><span class="line">- len - 文件内容截取的长度。</span><br><span class="line">- callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">## 删除文件</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.unlink(path, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- path - 文件路径。</span><br><span class="line">- callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">## 创建目录</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.mkdir(path[, options], callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- path - 文件路径。</span><br><span class="line">- options 参数可以是：</span><br><span class="line">    - recursive - 是否以递归的方式创建目录，默认为 false。</span><br><span class="line">    - mode - 设置目录权限，默认为 0777。</span><br><span class="line">- callback - 回调函数，没有参数。</span><br><span class="line"></span><br><span class="line">## 读取目录</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.readdir(path, callback)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">- path - 文件路径。</span><br><span class="line">- callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</span><br><span class="line"></span><br><span class="line">## 删除目录</span><br><span class="line">#### 语法</span><br></pre></td></tr></table></figure>

<p>fs.rmdir(path, callback)</p>
<pre><code>
#### 参数
- path - 文件路径。
- callback - 回调函数，没有参数。</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/28/快乐暑假第18天——继续学习nodejs/" data-id="cjyql0wp2000evsuwxg8ielgn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第17天——开始学习nodejs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/快乐暑假第17天——开始学习nodejs/" class="article-date">
  <time datetime="2019-07-26T12:58:47.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/快乐暑假第17天——开始学习nodejs/">快乐暑假第17天——开始学习nodejs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-NPM-使用介绍"><a href="#1-NPM-使用介绍" class="headerlink" title="1. NPM 使用介绍"></a>1. NPM 使用介绍</h1><p>Window 系统更新命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>

<h2 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a>使用 npm 命令安装模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;       # 本地安装</span><br><span class="line">npm install &lt;Module Name&gt; -g    # 全局安装</span><br></pre></td></tr></table></figure>

<p>如果出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm err! Error: connect ECONNREFUSED 127.0.0.1:8087</span><br></pre></td></tr></table></figure>

<p>解决办法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set proxy null</span><br></pre></td></tr></table></figure>

<ul>
<li>本地安装<ul>
<li>将安装包放在 ./node _ modules 下（运行 npm 命令时所在的目录），如果没有 node _ modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
</li>
<li>全局安装<ul>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
</li>
</ul>
<h2 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h2><p>查看所有全局安装的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list -g</span><br></pre></td></tr></table></figure>

<p>查看某个模块的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list grunt</span><br></pre></td></tr></table></figure>

<h2 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a>使用 package.json</h2><p>package.json 位于模块的目录下，用于定义包的属性。</p>
<h4 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h4><ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字。</li>
</ul>
<h2 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<h1 id="2-Node-js-REPL-交互式解释器"><a href="#2-Node-js-REPL-交互式解释器" class="headerlink" title="2. Node.js REPL(交互式解释器)"></a>2. Node.js REPL(交互式解释器)</h1><h2 id="简单的表达式运算"><a href="#简单的表达式运算" class="headerlink" title="简单的表达式运算"></a>简单的表达式运算</h2><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>
<h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><p>… 三个点的符号是系统自动生成的，回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<h2 id="下划线-变量"><a href="#下划线-变量" class="headerlink" title="下划线(_)变量"></a>下划线(_)变量</h2><p>可以使用下划线(_)获取上一个表达式的运算结果：</p>
<h1 id="3-Node-js-回调函数"><a href="#3-Node-js-回调函数" class="headerlink" title="3. Node.js 回调函数"></a>3. Node.js 回调函数</h1><p>回调函数一般作为函数的最后一个参数出现。</p>
<p>阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/快乐暑假第17天——开始学习nodejs/" data-id="cjyql0woh0003vsuwky85uhuo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第16天——继续做Bolo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/快乐暑假第16天——继续做Bolo/" class="article-date">
  <time datetime="2019-07-25T13:15:05.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/快乐暑假第16天——继续做Bolo/">快乐暑假第16天——继续做Bolo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>小明早上踩到了一个深坑，不同手机不同系统的默认样式是有差别的，甚至有可能出现各种各样奇怪的效果。</p>
</blockquote>
<ul>
<li>因此最好不用input等本身具备样式的元素，而是改用div，然后再对其设置需要的功能(如点击事件等)。</li>
<li>可输入的框即使设置为不可修改，但是可能仍然会出新光标。这一点等之后遇到了再详细研究。</li>
</ul>
<blockquote>
<p>在百度移动端触摸事件时看到了一个tap事件，于时百度了一下二者的区别</p>
</blockquote>
<ul>
<li>tap和click的区别：两者都会在点击时触发，但是在web手机端，clikc会有200-300ms的延时，所以要用tap代替click作为点击事件，singleTap和doubleTap分别作为单次点击和双击，但是使用tap会带来点透事件(事件穿透)。</li>
<li>tap事件穿透：执行完上层绑定的tap事件后，下层如果绑定这click事件或者本身就存在点击事件（a/input）也会默认触发，这就是tap点透事件</li>
<li>tap点透事件发生的场景：当A/B两个层上下Z轴叠层，上层的A点击后消失或者移开，当B元素本身默认有click事件或者绑定click事件，这种情况下，点击A/B重叠的部分，就会出现点透事件</li>
</ul>
<blockquote>
<p>用document.getElementById获取到的元素和用jq(‘#id’)获取到的元素有区别</p>
</blockquote>
<ul>
<li>dom方法只能操作用dom操作获取到的元素，同理，jq方法也只能由于jq获取的元素</li>
</ul>
<blockquote>
<p>在ios系统上点击具有点击事件的元素时，会出现一个黑色的背景一闪而过，应该是系统默认的回馈效果，百度之后有了解决方案：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</span><br><span class="line">    <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是如果点击到了没有任何元素的区域————比如body之外————仍然会出现这个东西。此时可以给body设一个最小高度100vh。</li>
</ul>
<blockquote>
<p>不同的用户手机浏览器的默认背景颜色可能会有差异，最好给body设置一个白色的背景颜色。</p>
</blockquote>
<blockquote>
<p>让超过一行的文字自动省略</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.object_content</span> &#123;</span><br><span class="line">    width: 61vw;                // 设置固定的宽度</span><br><span class="line">    overflow: hidden;           // 溢出内容隐藏</span><br><span class="line">    white-space: nowrap;        // 不换行</span><br><span class="line">    text-overflow: ellipsis;    // 超出文字省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/快乐暑假第16天——继续做Bolo/" data-id="cjyql0wof0001vsuwx88ak444" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第15天——开始做Bolo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/快乐暑假第15天——开始做Bolo/" class="article-date">
  <time datetime="2019-07-24T13:56:53.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/快乐暑假第15天——开始做Bolo/">快乐暑假第15天——开始做Bolo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天正式开始做Bolo，但是直到刚才我才发现我做了别人的任务。。。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
好的问题不大。今天做的东西比较常规，都是静态页面，没有遇到什么坑。只不过今天用的单位是vw，目前还只能用计算器一个一个手动转换。。。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
由于vh在弹出键盘、横屏等操作时变化较大，故不适合以vh为单位。另外，用rem来规定字体大小的一大好处是可以通过改变页面默认字体大小来改变所有字体的相对大小。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
刚刚操作失误，差点把自己一天的代码全部删了，好恐怖啊。。。。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>
今日无笔记

<p><img src="C:/Users/11691/Desktop/111.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/快乐暑假第15天——开始做Bolo/" data-id="cjyql0wog0002vsuwtva3ihxz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第14天——学习jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/快乐暑假第14天——学习jQuery/" class="article-date">
  <time datetime="2019-07-23T13:33:36.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/快乐暑假第14天——学习jQuery/">快乐暑假第14天——学习jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>基础语法： $(selector).action( )</p>
<ul>
<li>美元符号定义 jQuery</li>
<li>选择符（selector）”查询”和”查找” HTML 元素</li>
<li>jQuery 的 action() 执行对元素的操作</li>
</ul>
<h2 id="文档就绪事件"><a href="#文档就绪事件" class="headerlink" title="文档就绪事件"></a>文档就绪事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用简略形式</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>防止文档在完全加载（就绪）之前运行 jQuery 代码。</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。</p>
<p>jQuery 中所有选择器都以美元符号开头：$()，与css选择器相似：</p>
<ul>
<li>元素选择器</li>
<li>#id 选择器</li>
<li>.class 选择器</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="jQuery-事件方法语法"><a href="#jQuery-事件方法语法" class="headerlink" title="jQuery 事件方法语法"></a>jQuery 事件方法语法</h2><p>以点击事件为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 动作触发后执行的代码!!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2. 效果"></a>2. 效果</h1><h2 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(selector).hide(speed,callback);       //隐藏</span><br><span class="line">$(selector).show(speed,callback);       //显示</span><br><span class="line">$(selector).toggle(speed,callback);     //在 hide() 与 show() 之间进行切换</span><br></pre></td></tr></table></figure>

<ul>
<li>可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。</li>
<li>可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</li>
</ul>
<h2 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(selector).fadeIn(speed,callback);     //用于淡入已隐藏的元素</span><br><span class="line">$(selector).fadeOut(speed,callback);    //用于淡出可见元素</span><br><span class="line">$(selector).fadeToggle(speed,callback); //在 fadeIn() 与 fadeOut() 之间进行切换</span><br><span class="line">$(selector).fadeTo(speed,opacity,callback); //渐变为给定的不透明度（值介于 0 与 1 之间）</span><br></pre></td></tr></table></figure>

<h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(selector).slideDown(speed,callback);      //向下滑动元素</span><br><span class="line">$(selector).slideUp(speed,callback);        //向上滑动元素</span><br><span class="line">$(selector).slideToggle(speed,callback);    //在 slideDown() 与 slideUp() 方法之间进行切换</span><br></pre></td></tr></table></figure>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;,speed,callback);       //创建自定义动画</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>必需的 params 参数</strong>定义形成动画的 CSS 属性</li>
<li>生成动画的过程中<strong>可同时使用多个属性</strong></li>
<li><strong>可以定义相对值</strong>（该值相对于元素的当前值），需要在值的前面加上 += 或 -=</li>
<li>可以把属性的动画值设置为 “show”、”hide” 或 “toggle”</li>
<li>jQuery <strong>提供针对动画的队列功能</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).stop(stopAll,goToEnd);      //用于停止动画或效果，在它们完成之前</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画</li>
<li>可选的 stopAll 参数规定是否应该清除动画队列。<ul>
<li>默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。</li>
</ul>
</li>
<li>可选的 goToEnd 参数规定是否立即完成当前动画。<ul>
<li>默认是 false。</li>
</ul>
</li>
</ul>
<p>因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p>
<h2 id="Callback-方法"><a href="#Callback-方法" class="headerlink" title="Callback 方法"></a>Callback 方法</h2><p>Callback 函数在当前动画 100% 完成之后执行。</p>
<p>如果没有回调函数，动画后面的语句可能会在动画完成前执行。</p>
<h2 id="链-Chaining"><a href="#链-Chaining" class="headerlink" title="链(Chaining)"></a>链(Chaining)</h2><p>可以在一条语句中运行多个 jQuery 方法（在相同的元素上）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#p1"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>)</span><br><span class="line">  .slideUp(<span class="number">2000</span>)</span><br><span class="line">  .slideDown(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-HTML"><a href="#3-HTML" class="headerlink" title="3. HTML"></a>3. HTML</h1><h2 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h2><h3 id="获得、设置内容"><a href="#获得、设置内容" class="headerlink" title="获得、设置内容"></a>获得、设置内容</h3><ul>
<li>text() - 设置或返回所选元素的文本内容</li>
<li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li>
<li>val() - 设置或返回表单字段的值</li>
</ul>
<p>拥有回调函数，以函数新值返回字符串。回调函数有两个参数：</p>
<ol>
<li>被选元素列表中当前元素的下标</li>
<li>原始（旧的）值。</li>
</ol>
<h3 id="获取、设置属性"><a href="#获取、设置属性" class="headerlink" title="获取、设置属性"></a>获取、设置属性</h3><p>jQuery <strong>attr() 方法</strong>用于获取属性值，也可以设置/改变属性值。</p>
<ul>
<li>同时设置多个属性</li>
<li>提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回字符串。</li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>append() - 在被选元素的结尾插入内容（仍然该元素的内部）</li>
<li>prepend() - 在被选元素的开头插入内容</li>
<li>after() - 在被选元素之后插入内容（在该元素外部）</li>
<li>before() - 在被选元素之前插入内容</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>remove() - 删除被选元素（及其子元素）</li>
<li>empty() - 从被选元素中删除子元素</li>
</ul>
<p>remove() 方法也可接受一个参数，可以对被删元素进行过滤。</p>
<p>删除 class=”italic” 的所有 &lt;p&gt; 元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).remove(<span class="string">".italic"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取并设置-CSS-类"><a href="#获取并设置-CSS-类" class="headerlink" title="获取并设置 CSS 类"></a>获取并设置 CSS 类</h2><h3 id="操作-CSS"><a href="#操作-CSS" class="headerlink" title="操作 CSS"></a>操作 CSS</h3><ul>
<li>addClass() - 向被选元素添加一个或多个类</li>
<li>removeClass() - 从被选元素删除一个或多个类</li>
<li>toggleClass() - 对被选元素进行添加/删除类的切换操作</li>
<li>css() - 设置或返回样式属性</li>
</ul>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><h2 id="尺寸方法"><a href="#尺寸方法" class="headerlink" title="尺寸方法"></a>尺寸方法</h2><ul>
<li>width() - 设置或返回元素的宽度（不包括内边距、边框或外边距）</li>
<li>height() - 设置或返回元素的高度（不包括内边距、边框或外边距）</li>
<li>innerWidth() - 返回元素的宽度（包括内边距）</li>
<li>innerHeight() - 返回元素的高度（包括内边距）</li>
<li>outerWidth() - 返回元素的宽度（包括内边距和边框）</li>
<li>outerHeight() - 返回元素的高度（包括内边距和边框）</li>
</ul>
<h1 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h1><h2 id="向上遍历-DOM-树"><a href="#向上遍历-DOM-树" class="headerlink" title="向上遍历 DOM 树"></a>向上遍历 DOM 树</h2><ul>
<li>parent() - 返回被选元素的直接父元素</li>
<li>parents() - 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)</li>
<li>parentsUntil() - 返回介于两个给定元素之间的所有祖先元素</li>
</ul>
<h2 id="向下遍历-DOM-树"><a href="#向下遍历-DOM-树" class="headerlink" title="向下遍历 DOM 树"></a>向下遍历 DOM 树</h2><ul>
<li>children() - 返回被选元素的所有直接子元素，也可以使用可选参数来过滤对子元素的搜索</li>
<li>find() - 返回被选元素的后代元素，一路向下直到最后一个后代</li>
</ul>
<h2 id="在-DOM-树中水平遍历"><a href="#在-DOM-树中水平遍历" class="headerlink" title="在 DOM 树中水平遍历"></a>在 DOM 树中水平遍历</h2><ul>
<li>siblings() - 返回被选元素的所有同胞元素，可以使用可选参数来过滤对同胞元素的搜索</li>
</ul>
<p>向后遍历：</p>
<ul>
<li>next() - 返回被选元素的下一个同胞元素</li>
<li>nextAll() - 返回被选元素的所有跟随的同胞元素</li>
<li>nextUntil() - 返回介于两个给定参数之间的所有跟随的同胞元素</li>
</ul>
<p>向前遍历：</p>
<ul>
<li>prev()</li>
<li>prevAll()</li>
<li>prevUntil()</li>
</ul>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul>
<li>first() - 返回被选元素的首个元素</li>
<li>last() - 返回被选元素的最后一个元素</li>
<li>eq() - 返回被选元素中带有指定索引号的元素（索引号从 0 开始）</li>
<li>filter() - 可以规定一个标准，不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回</li>
<li>not() - 返回不匹配标准的所有元素（与 filter() 相反）</li>
</ul>
<h1 id="5-Ajax"><a href="#5-Ajax" class="headerlink" title="5. Ajax"></a>5. Ajax</h1><h2 id="AJAX-load-方法"><a href="#AJAX-load-方法" class="headerlink" title="AJAX load() 方法"></a>AJAX load() 方法</h2><p>load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback);</span><br></pre></td></tr></table></figure>

<ul>
<li>必需的 URL 参数规定您希望加载的 URL。<ul>
<li>可以把 jQuery 选择器添加到进此参数</li>
</ul>
</li>
<li>可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。</li>
<li>可选的 callback 参数是 load() 方法完成后所执行的函数名称。<ul>
<li>回调函数可以设置不同的参数：<ul>
<li>responseTxt - 包含调用成功时的结果内容</li>
<li>statusTXT - 包含调用的状态</li>
<li>xhr - 包含 XMLHttpRequest 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AJAX-get-和-post-方法"><a href="#AJAX-get-和-post-方法" class="headerlink" title="AJAX get() 和 post() 方法"></a>AJAX get() 和 post() 方法</h2><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据<br>$.post() 方法通过 HTTP POST 请求向服务器提交数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/快乐暑假第14天——学习jQuery/" data-id="cjyql0wo40000vsuws4l33vk2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第13天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/快乐暑假第13天/" class="article-date">
  <time datetime="2019-07-22T12:21:09.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/快乐暑假第13天/">快乐暑假第13天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
今晚还看了一些jq，明天再大概看一下。设计差不多要出稿了，准备开始实践了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="9-async-函数"><a href="#9-async-函数" class="headerlink" title="9. async 函数"></a>9. async 函数</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>
<h2 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9.1 语法"></a>9.1 语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p>async函数返回一个 Promise 对象。</p>
<ul>
<li>内部return语句返回的值，会<strong>成为then方法回调函数的参数</strong>。</li>
<li>async函数内部抛出错误，会导致返回的 Promise 对象<strong>变为reject状态</strong>。抛出的错误对象<strong>会被catch方法回调函数接收到</strong>。</li>
</ul>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async函数返回的 Promise 对象，必须<strong>等到内部所有await命令后面的 Promise 对象执行完</strong>，才会发生状态改变，然后执行then方法指定的回调函数，除非<strong>遇到return语句</strong>或者<strong>抛出错误</strong>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<strong>await命令后面是一个 Promise 对象</strong>，返回该对象的结果。如果不是 Promise 对象，就<strong>直接返回对应的值</strong>。如果后面是一个thenable对象（即定义then方法的对象），那么await会<strong>将其等同于 Promise 对象</strong>。</p>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<ul>
<li>任何一个await语句后面的 Promise 对象变为reject状态，整个async函数都会中断执行。</li>
<li>如果不想中断后面语句的执行，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>
<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<ul>
<li>防止出错的方法，也是将其放在try…catch代码块之中。</li>
<li>如果有多个await命令，可以统一放在try…catch结构中。</li>
</ul>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个操作互相独立，这样做比较耗时</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>

<ul>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li>async 函数可以保留运行堆栈。</li>
</ul>
<h1 id="10-Class-的基本语法"><a href="#10-Class-的基本语法" class="headerlink" title="10. Class 的基本语法"></a>10. Class 的基本语法</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。<strong>Object.assign方法</strong>可以很方便地一次向类添加多个方法。</p>
<p><strong>类的内部所有定义的方法，都是不可枚举的</strong>。这一点与 ES5 的行为不一致。</p>
<p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。<strong>一个类必须有constructor方法</strong>，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<ul>
<li>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象(但会导致实例对象改变)。</li>
</ul>
<p>类必须使用new调用，否则会报错。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<ul>
<li>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</li>
</ul>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Square类的方法名getArea，是从表达式得到的。</li>
</ul>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，<strong>这个类只能用MyClass引用</strong>。</li>
<li>如果类的内部没用到的话，可以省略Me。</li>
</ul>
<p>采用 Class 表达式，可以写出<strong>立即执行的 Class</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用use strict指定运行模式。</li>
<li><strong>类不存在变量提升</strong>（hoist），这一点与 ES5 完全不同。</li>
<li>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</li>
<li>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ol>
<h2 id="10-2-静态方法"><a href="#10-2-静态方法" class="headerlink" title="10.2 静态方法"></a>10.2 静态方法</h2><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果在一个方法前，<strong>加上static关键字，就表示该方法不会被实例继承</strong>，而是直接通过类来调用，这就称为“静态方法”。</p>
<ul>
<li>如果静态方法包含this关键字，这个this指的是类，而不是实例。</li>
<li>静态方法可以与非静态方法重名。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>静态方法也是可以从super对象上调用的。</li>
</ul>
<h2 id="10-3-实例属性的新写法"><a href="#10-3-实例属性的新写法" class="headerlink" title="10.3 实例属性的新写法"></a>10.3 实例属性的新写法</h2><p>实例属性除了定义在constructor()方法里面的this上面，也可以<strong>定义在类的最顶层</strong>。</p>
<h2 id="10-4-静态属性"><a href="#10-4-静态属性" class="headerlink" title="10.4 静态属性"></a>10.4 静态属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</li>
</ul>
<h1 id="11-Class-的继承"><a href="#11-Class-的继承" class="headerlink" title="11. Class 的继承"></a>11. Class 的继承</h1><p>Class 可以通过extends关键字实现继承。</p>
<ul>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</li>
<li>如果子类没有定义constructor方法，这个方法会被默认添加。因此不管有没有显式定义，任何一个子类都有constructor方法。</li>
<li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</li>
<li>父类的静态方法，也会被子类继承。</li>
</ul>
<h2 id="11-1-Object-getPrototypeOf"><a href="#11-1-Object-getPrototypeOf" class="headerlink" title="11.1 Object.getPrototypeOf( )"></a>11.1 Object.getPrototypeOf( )</h2><p>Object.getPrototypeOf方法可以用来从子类上获取父类。<br>因此可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="11-2-super-关键字"><a href="#11-2-super-关键字" class="headerlink" title="11.2 super 关键字"></a>11.2 super 关键字</h2><p>super作为函数调用时，代表父类的构造函数。<strong>作为函数时，super()只能用在子类的构造函数之中</strong>，用在其他地方就会报错。</p>
<p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h1 id="12-Module-的语法"><a href="#12-Module-的语法" class="headerlink" title="12. Module 的语法"></a>12. Module 的语法</h1><p>ES6 的模块自动采用严格模式。</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</p>
<p>模块功能主要由两个命令构成：export和import：</p>
<ul>
<li><strong>export命令用于规定模块的对外接口</strong>。</li>
<li><strong>import命令用于输入其他模块提供的功能</strong>。</li>
</ul>
<h2 id="12-1-export-命令"><a href="#12-1-export-命令" class="headerlink" title="12.1 export 命令"></a>12.1 export 命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果要<strong>让外部能够读取模块内部的某个变量</strong>，就必须使用export关键字输出该变量。</p>
<ul>
<li>export命令除了输出变量，还可以输出函数或类。</li>
<li>通常情况下，export输出的变量就是本来的名字，但是可以<strong>使用as关键字重命名</strong>。</li>
<li>export语句输出的接口，与其对应的值是<strong>动态绑定关系</strong>，即通过该接口，可以取到模块内部实时的值。</li>
<li>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。</li>
</ul>
<h2 id="12-2-import-命令"><a href="#12-2-import-命令" class="headerlink" title="12.2 import 命令"></a>12.2 import 命令</h2><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以<strong>通过import命令加载这个模块</strong>。</p>
<ul>
<li>使用as关键字，将输入的变量重命名。</li>
<li>import命令输入的变量都是<strong>只读</strong>的，因为它的本质是输入接口。</li>
<li>import命令<strong>具有提升效果</strong>，会提升到整个模块的头部，首先执行。(import命令是编译阶段执行的，在代码运行之前)</li>
<li>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li>
</ul>
<h2 id="12-3模块的整体加载"><a href="#12-3模块的整体加载" class="headerlink" title="12.3模块的整体加载"></a>12.3模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即<strong>用星号（*）指定一个对象，所有输出值都加载在这个对象上面</strong>。</p>
<ul>
<li>模块整体加载所在的那个对象，应该是<strong>可以静态分析</strong>的，所以<strong>不允许运行时改变</strong>。</li>
</ul>
<h2 id="12-4-export-default-命令"><a href="#12-4-export-default-命令" class="headerlink" title="12.4 export default 命令"></a>12.4 export default 命令</h2><p>export default命令能为模块指定默认输出。</p>
<ul>
<li>这时import命令后面，不使用大括号。</li>
<li>export default命令也可以用在非匿名函数前。</li>
<li>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</li>
<li>因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</li>
</ul>
<h2 id="12-5-export-与-import-的复合写法"><a href="#12-5-export-与-import-的复合写法" class="headerlink" title="12.5 export 与 import 的复合写法"></a>12.5 export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>foo和bar实际上并没有被导入当前模块</li>
</ul>
<h1 id="13-Module-的加载实现"><a href="#13-Module-的加载实现" class="headerlink" title="13. Module 的加载实现"></a>13. Module 的加载实现</h1><h2 id="13-1-浏览器加载"><a href="#13-1-浏览器加载" class="headerlink" title="13.1 浏览器加载"></a>13.1 浏览器加载</h2><p>浏览器允许脚本异步加载，有两种异步加载的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是“渲染完再执行”，async是“下载完就执行”。</li>
<li>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</li>
</ul>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入<strong>type=”module”属性</strong>。</p>
<ul>
<li>浏览器对于带有 type=”module” 的&lt;script&gt;，都是异步加载，<strong>等同于打开了&lt;script&gt;标签的defer属性</strong>。（会按照出现顺序执行）</li>
<li>async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。（此时<strong>不会按照在页面出现的顺序执行</strong>，而是只要该模块加载完成，就执行该模块）</li>
</ul>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。对于外部的模块脚本（上例是foo.js），有几点需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式。</li>
<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li>
<li>在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/快乐暑假第13天/" data-id="cjyql0wol0007vsuwheo13v8n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第12天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/快乐暑假第12天/" class="article-date">
  <time datetime="2019-07-21T13:33:40.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/21/快乐暑假第12天/">快乐暑假第12天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p><strong>Set函数接受数组作为参数</strong>是一种去除数组重复成员的方法。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>
<p><strong>Array.from方法可以将 Set 结构转为数组</strong>，是去除数组重复成员的另一种方法。</p>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员：</p>
<ul>
<li><strong>Set.prototype.keys( )</strong>：返回键名的遍历器</li>
<li><strong>Set.prototype.values( )</strong>：返回键值的遍历器</li>
<li><strong>Set.prototype.entries( )</strong>：返回键值对的遍历器</li>
<li><strong>Set.prototype.forEach( )</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>Set的遍历顺序就是插入顺序。</strong></p>
<h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<strong>keys方法和values方法的行为完全一致</strong>。entries方法返回的遍历器，同时包括键名和键值。</p>
<p>可以省略values方法，直接用for…of循环遍历 Set。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>用于对每个成员执行某种操作，没有返回值。</p>
<p><strong>forEach方法的参数就是一个处理函数</strong>。</p>
<h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>数组的map和filter方法也可以间接用于 Set ，因此<strong>使用 Set 可以很容易地实现并集、交集和差集</strong>。</p>
<h2 id="7-2-WeakSet"><a href="#7-2-WeakSet" class="headerlink" title="7.2 WeakSet"></a>7.2 WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的<strong>成员只能是对象</strong>。</p>
<p>WeakSet 中的对象都是<strong>弱引用</strong>，如果其他对象都不再引用某一对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。因此 <strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。</p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数(数组的成员只能是对象)，该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<p>WeakSet 结构有以下三个方法：</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet 没有size属性，<strong>没有办法遍历它的成员</strong>(由于弱引用特性，不支持遍历)。</p>
<h2 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h2><p>Map 数据结构类似于对象，是<strong>键值对的集合</strong>，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作键</strong>。</p>
<p>作为构造函数，Map 也可以<strong>接受一个数组作为参数</strong>。该数组的成员是一个个表示键值对的数组。</p>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法：</p>
<ul>
<li><strong>size 属性</strong>：返回 Map 结构的成员总数。</li>
<li><strong>Map.prototype.set(key, value)</strong>：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><strong>Map.prototype.get(key)</strong>：读取key对应的键值，如果找不到key，返回undefined。</li>
<li><strong>Map.prototype.has(key)</strong>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><strong>Map.prototype.delete(key)</strong>：删除某个键，返回true。如果删除失败，返回false。</li>
<li><strong>Map.prototype.clear()</strong>：清除所有成员，没有返回值。</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li><strong>Map.prototype.keys()</strong>：返回键名的遍历器。</li>
<li><strong>Map.prototype.values()</strong>：返回键值的遍历器。</li>
<li><strong>Map.prototype.entries()</strong>：返回所有成员的遍历器。</li>
<li><strong>Map.prototype.forEach()</strong>：遍历 Map 的所有成员。</li>
</ul>
<p><strong>Map 的遍历顺序就是插入顺序。</strong></p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul>
<li>数组与Map的相互转换</li>
<li>对象与Map的相互转换</li>
<li>JSON与Map的相互转换</li>
</ul>
<h2 id="7-4-WeakMap"><a href="#7-4-WeakMap" class="headerlink" title="7.4 WeakMap"></a>7.4 WeakMap</h2><h1 id="8-Promise-对象"><a href="#8-Promise-对象" class="headerlink" title="8. Promise 对象"></a>8. Promise 对象</h1><h2 id="8-1-Promise-的含义"><a href="#8-1-Promise-的含义" class="headerlink" title="8.1 Promise 的含义"></a>8.1 Promise 的含义</h2><p>Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>Promise对象有以下两个特点：</p>
<ul>
<li><strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。(这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的)</li>
</ul>
<h2 id="8-2-基本用法"><a href="#8-2-基本用法" class="headerlink" title="8.2 基本用法"></a>8.2 基本用法</h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，<strong>不用自己部署</strong>。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并<strong>将异步操作的结果，作为参数传递出去</strong>。</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<p>如果<strong>调用resolve函数和reject函数时带有参数</strong>，那么它们的参数会被<strong>传递给回调函数</strong>。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<ul>
<li>then方法可以接受两个回调函数作为参数：第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用(可选)。</li>
<li>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</li>
</ul>
<h2 id="8-3-Promise-prototype-then"><a href="#8-3-Promise-prototype-then" class="headerlink" title="8.3 Promise.prototype.then( )"></a>8.3 Promise.prototype.then( )</h2><p>then方法<strong>返回的是一个新的Promise实例</strong>，因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h2 id="8-4-Promise-prototype-catch"><a href="#8-4-Promise-prototype-catch" class="headerlink" title="8.4 Promise.prototype.catch( )"></a>8.4 Promise.prototype.catch( )</h2><p>是.then(null, rejection)或.then(undefined, rejection)的别名，<strong>用于指定发生错误时的回调函数</strong>。</p>
<p>Promise 对象的错误<strong>具有“冒泡”性质</strong>，会一直向后传递，直到被捕获为止。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），<strong>总是使用catch方法</strong>。catch方法返回的还是一个 Promise 对象，因此<strong>后面还可以接着调用then方法</strong>。</p>
<ul>
<li>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即<strong>不会有任何反应</strong>。</li>
</ul>
<h2 id="8-5-Promise-prototype-finally"><a href="#8-5-Promise-prototype-finally" class="headerlink" title="8.5 Promise.prototype.finally( )"></a>8.5 Promise.prototype.finally( )</h2><p>用于<strong>指定不管 Promise 对象最后状态如何，都会执行的操作</strong>。</p>
<ul>
<li>finally方法的回调函数<strong>不接受任何参数</strong>，故无法知道前面的 Promise 状态到底是fulfilled还是rejected。因此finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
<li>finally本质上是then方法的特例。</li>
<li>finally方法总是会返回原来的值。</li>
</ul>
<h2 id="8-6-Promise-all"><a href="#8-6-Promise-all" class="headerlink" title="8.6 Promise.all( )"></a>8.6 Promise.all( )</h2><p>Promise.all方法用于<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>接受一个数组作为参数，p1、p2、p3都是 Promise 实例。(如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理)</li>
<li>p的状态由p1、p2、p3决定：<ul>
<li>只有p1、p2、p3的状态<strong>都变成fulfilled</strong>，p的状态才会变成fulfilled，此时p1、p2、p3的<strong>返回值组成一个数组，传递给p的回调函数</strong>。</li>
<li>只要p1、p2、p3之中<strong>有一个被rejected</strong>，p的状态就变成rejected，此时<strong>第一个被reject的实例的返回值，会传递给p的回调函数</strong>。</li>
</ul>
</li>
<li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</li>
</ul>
<h2 id="8-7-Promise-race"><a href="#8-7-Promise-race" class="headerlink" title="8.7 Promise.race( )"></a>8.7 Promise.race( )</h2><p>Promise.race方法同样是<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要p1、p2、p3之中<strong>有一个实例率先改变状态，p的状态就跟着改变</strong>。那个<strong>率先改变的 Promise 实例的返回值，就传递给p的回调函数</strong>。</li>
<li>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</li>
</ul>
<h2 id="8-8-Promise-resolve"><a href="#8-8-Promise-resolve" class="headerlink" title="8.8 Promise.resolve( )"></a>8.8 Promise.resolve( )</h2><p>Promise.resolve方法能够<strong>将现有对象转为 Promise 对象</strong>。</p>
<p>Promise.resolve方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<strong>Promise 实例</strong>：不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个<strong>thenable对象</strong>：(thenable对象指的是具有then方法的对象)会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</li>
<li>参数<strong>不是具有then方法的对象，或不是对象</strong>:返回一个新的 Promise 对象，状态为resolved。（Promise.resolve方法的参数，会同时传给回调函数，回调函数会立即执行）</li>
<li><strong>不带有任何参数</strong>：直接返回一个resolved状态的 Promise 对象。<ul>
<li>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li>
</ul>
</li>
</ul>
<h2 id="8-9-Promise-reject"><a href="#8-9-Promise-reject" class="headerlink" title="8.9 Promise.reject( )"></a>8.9 Promise.reject( )</h2><p>Promise.reject(reason)方法也会<strong>返回一个状态为rejected的新的 Promise 实例</strong>。</p>
<ul>
<li>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</li>
</ul>
<h1 id="9-Generator-函数的语法"><a href="#9-Generator-函数的语法" class="headerlink" title="9. Generator 函数的语法"></a>9. Generator 函数的语法</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/快乐暑假第12天/" data-id="cjyql0woi0004vsuwmvnbebmc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第11天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/快乐暑假第11天/" class="article-date">
  <time datetime="2019-07-19T14:02:19.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/快乐暑假第11天/">快乐暑假第11天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中<ul>
<li>如果不需要换行，可以使用trim方法消除它</li>
</ul>
</li>
<li>模板字符串中嵌入变量，需要将变量名写在${}之中<ul>
<li>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</li>
<li>还能调用函数，如果大括号中的值不是字符串，将按照一般的规则转为字符串</li>
<li>如果模板字符串中的变量没有声明，将报错</li>
<li>实际上模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出</li>
</ul>
</li>
<li>模板字符串还能嵌套</li>
<li>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</li>
</ul>
<h1 id="4-函数的扩展"><a href="#4-函数的扩展" class="headerlink" title="4. 函数的扩展"></a>4. 函数的扩展</h1><h2 id="4-1-箭头函数"><a href="#4-1-箭头函数" class="headerlink" title="4.1 箭头函数"></a>4.1 箭头函数</h2><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果箭头函数不需要参数或需要多个参数，就使用一个<strong>圆括号代表参数部分</strong></li>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且<strong>使用return语句返回</strong></li>
<li>由于大括号被解释为代码块，所以如果箭头函数直接<strong>返回一个对象，必须在对象外面加上括号</strong>，否则会报错</li>
<li>箭头函数可以与变量解构结合使用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数的一个用处是简化回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ol>
<li>函数体内的<strong>this对象，就是定义时所在的对象</strong>，而不是使用时所在的对象。</li>
<li><strong>不可以当作构造函数</strong>，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li><strong>不可以使用arguments对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li><strong>不可以使用yield命令</strong>，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</li>
</ul>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this，导致内部的this就是外层代码块的this</strong>。正是因为它没有this，所以也就<strong>不能用作构造函数</strong>。</p>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数：</p>
<ol>
<li>定义对象的方法，且该方法内部包括this</li>
<li>需要动态this的时候，也不应使用箭头函数</li>
</ol>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个函数，可以使用箭头函数改写。</span></span><br><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="function">(<span class="params">&#123;into: (array</span>) =&gt;</span> <span class="function">(<span class="params">&#123;after: (afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-rest-参数"><a href="#4-2-rest-参数" class="headerlink" title="4.2 rest 参数"></a>4.2 rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。</p>
<ul>
<li>rest 参数搭配的变量是一个数组，该变量<strong>将多余的参数放入数组中</strong>。</li>
<li>arguments对象不是数组，而是一个类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。<strong>rest 参数是一个真正的数组，数组特有的方法都可以使用</strong>。</li>
<li>rest 参数之后不能再有其他参数（即<strong>只能是最后一个参数</strong>），否则会报错。</li>
<li><strong>函数的length属性，不包括 rest 参数</strong>。</li>
</ul>
<h2 id="4-3-数组实例的-includes"><a href="#4-3-数组实例的-includes" class="headerlink" title="4.3 数组实例的 includes( )"></a>4.3 数组实例的 includes( )</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
<h1 id="5-数组的扩展"><a href="#5-数组的扩展" class="headerlink" title="5. 数组的扩展"></a>5. 数组的扩展</h1><h2 id="5-1-扩展运算符"><a href="#5-1-扩展运算符" class="headerlink" title="5.1 扩展运算符"></a>5.1 扩展运算符</h2><p>扩展运算符是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<ul>
<li>扩展运算符与正常的函数参数可以结合使用</li>
<li>扩展运算符后面还可以放置表达式</li>
<li>如果扩展运算符后面是一个空数组，则不产生任何效果</li>
<li>只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错</li>
</ul>
<h1 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型。</p>
<ul>
<li>Symbol函数前不能使用new命令，因为生成的 Symbol 是一个原始类型的值，不是对象。它是一种类似于字符串的数据类型。</li>
<li>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。<ul>
<li>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</li>
<li>相同参数的Symbol函数的返回值是不相等的。</li>
</ul>
</li>
<li>Symbol 值不能与其他类型的值进行运算。</li>
<li>Symbol 值可以显式转为字符串。</li>
<li>Symbol 值也可以转为布尔值，但是不能转为数值。</li>
</ul>
<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/快乐暑假第11天/" data-id="cjyql0wok0006vsuwj5s4fsk3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
          </li>
        
          <li>
            <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
          </li>
        
          <li>
            <a href="/2019/07/28/快乐暑假第18天——继续学习nodejs/">快乐暑假第18天——继续学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/26/快乐暑假第17天——开始学习nodejs/">快乐暑假第17天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第16天——继续做Bolo/">快乐暑假第16天——继续做Bolo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>