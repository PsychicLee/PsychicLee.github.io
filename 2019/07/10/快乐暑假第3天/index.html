<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>快乐暑假第3天 | Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今日小结  JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：   进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接 进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算 乘除">
<meta property="og:type" content="article">
<meta property="og:title" content="快乐暑假第3天">
<meta property="og:url" content="http://yoursite.com/2019/07/10/快乐暑假第3天/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:description" content="今日小结  JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：   进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接 进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算 乘除">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-28T01:45:13.683Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="快乐暑假第3天">
<meta name="twitter:description" content="今日小结  JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：   进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接 进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算 乘除">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-快乐暑假第3天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/快乐暑假第3天/" class="article-date">
  <time datetime="2019-07-10T10:05:08.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      快乐暑假第3天
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：

<ul>
<li>进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接</li>
<li>进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算</li>
<li>乘除求模操作时，如果有一个操作数不是数值，则会在后台调用 Number( ) 将其转换为数值再进行计算</li>
<li>关系操作符也会进行一些转换然后进行比较</li>
</ul>
</p>

<p style="font-size:18px;text-align:left;text-indent:2em">
除此之外还有很多操作符都会进行隐式转换，一时半会很难全部记住，还需要在以后的学习和实践中慢慢积累，然后逐渐掌握牢固。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
语句方面大部分语法都与C相同，因此很容易就能记住并使用，但也有一些像for-in语句、label语句之类的之前并没有接触过，感到比较陌生。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
函数方面，我觉得其参数的保存机制挺有意思的，这种类似数组的保存方式也给函数的使用带来了更大的发挥空间。但是任何事物都有两面性，自由宽松或许会容易造成某些错误，这也需要在之后的实践中慢慢摸索。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
学习了作用域以及作用域链的相关工作原理之后也明白了一些之前不是很清楚的东西，比如在一个局部环境中定义一个与上一级环境中某个变量同名的变量是可行的，并且在该局部变量中使用这个变量时并不用担心这个变量的值会不会受到上一级环境中的同名变量的影响。作用域链就像一棵树一样，全局环境是根部，其中又包含了许多互不相干的局部环境，可以在小环境中使用相应父级环境定义的变量或函数，但不能使用子级的任何东西。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
引用类型这部分，虽然书里讲述的意思看懂了，但是总觉得有一点空，对引用类型还没有很好的掌握和理解，还不是很熟悉。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-变量、作用域和内存问题"><a href="#3-变量、作用域和内存问题" class="headerlink" title="3.变量、作用域和内存问题"></a>3.变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>ECMAScipt 变量可能包含两种不同数据类型的值：<ul>
<li>基本类型值：指的是简单的数据段，在内存中占据固定大小空间，因此被保存在<strong>栈内存</strong>中</li>
<li>引用类型值：指那些可能由多个值构成的对象，保存在<strong>堆内存</strong>中</li>
</ul>
</li>
<li>5种基本数据类型是按值访问的，因为<strong>可以操作保存在变量中的实际的值</strong></li>
<li>引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置，也就是说<strong>不能直接操作对象的内存空间</strong></li>
</ul>
<h4 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h4><p>只能给引用类型值动态地添加属性，以便将来使用 (给基本类型值添加属性不会报错，但没有效果)。</p>
<h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><ul>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，二者的值相同但完全独立，进行任何操作都不会互相影响</li>
<li>从一个变量向另一个变量复制引用类型的值，实际上新变量是一个指针，指向一个对象，复制操作结束后二者将引用同一个对象</li>
</ul>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><p>ECMAScript 中所有函数的参数都是按值传递的 (<strong>访问变量有按值和按引用两种方式，而参数只能按值传递</strong>)</p>
<ul>
<li>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数)</li>
<li>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部</li>
</ul>
<p>证明对象是按值传递的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person);  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性为 “Grey” 的新对象，但接下来访问 person.name 时，显示的值仍然是 “Nicholas”</li>
<li>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持不变<br>  实际上，在函数内部重写 obj 时，这个变量引用的就是一个局部对象了 (会在函数执行完毕后被销毁)</li>
</ul>
<p>可以把 ECMAScipt 函数的参数想象成局部变量。</p>
<h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>typeof 操作符在检测引用类型的值时作用不大，当我们想知道某个值是什么类型的对象可以使用 instanceof 操作符</p>
<ul>
<li><p>语法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量是给定引用类型的实例，那么 instanceof 操作符就会返回 true，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//变量 person 是 Object 吗？</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">//变量 colors 是 Array 吗？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有引用类型的值都是 Object 的实例，因此在检测一个引用类型的值和 Object 构造函数时，始终返回 true</p>
</li>
<li><p>如果使用 instanceof 操作符检测基本类型的值，则始终返回 false</p>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
<p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中，虽然代码无法访问，但解析器处理数据时会用到它。</p>
<p>在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法去创造的。</p>
<p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数也随之销毁(全局执行环境直到应用程序退出————例如关闭网页或浏览器————时才会被销毁)。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问，其前端始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。</p>
<ul>
<li>活动对象在最开始时只包含一个变量，即 arguments 对象(找个对象在全局环境中是不存在的)</li>
</ul>
<p>作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境(全局执行环境的变量对象始终是作用域链中的最后一个对象)。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终<strong>从作用域链的前端开始，逐级向后回溯</strong>，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。</p>
<p><strong>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数</strong>。</p>
<p>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>当执行流进入下列任何一个语句时，作用域链就会得到加长(这两个语句都会在作用域链的前端添加一个变量对象)：</p>
<ol>
<li>try-catch 语句的 catch 块<ul>
<li>会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</li>
</ul>
</li>
<li>with 语句<ul>
<li>会将指定的对象添加到作用域链中</li>
</ul>
</li>
</ol>
<h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><p>在其他类 C 语言中，由花括号封闭的代码都有自己的块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure>

<p>对于有块级作用域的语言来说，for 循环初始化的变量 i 只会存在于循环的环境中；而对于 JavaScript 来说，for 创建的 i 即使在循环结束之后，也会存在于循环的外部环境中。</p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>使用 var 声明的变量会自动添加到<strong>最接近</strong>的环境中(如果初始化变量时没有使用 var 声明，该变量会自动添加到全局环境)</p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>搜索过程<strong>从作用域链的前端开始</strong>，向上级查询与给定名字匹配的标识符，如果在局部环境找到了该标识符，搜索过程停止(<strong>如果局部环境存在着同名标识符，就不会使用位于父环境的标识符</strong>)。</p>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>执行环境会负责管理代码执行过程中使用的内存，所需内存的分配以及无用内存的回收完全实现了自动管理。机制为<strong>周期性执行</strong>：找出无用变量，将其所占内存释放。</p>
<ul>
<li>用于标识无用变量的策略通常有两个：标记清除(最常用)、引用计数(少用)</li>
</ul>
<p><strong>管理内存</strong>：优化占用内存的最佳方式就是执行中的代码只保存必要的数据，一旦数据不再有用，将其值设置为 null 来释放其引用，称为<strong>解除引用</strong>(局部变量会在离开执行环境时自动被解除引用，全局变量需要手工为它解除引用)。</p>
<h1 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4. 引用类型"></a>4. 引用类型</h1><blockquote>
<p>引用类型的值(对象)是引用类型的一个实例<br><br>在 JavaScript 中引用类型是一种数据结构，用于将数据和功能组织在一起<br><br>引用类型有时候也被称为对象定义,因为它们描述的是一类对象所具有的属性和方法,对象是某个特定引用类型的实例</p>
</blockquote>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建 Object 实例的方式有两种</p>
<ol>
<li><p>使用 new 操作符后跟 Object 构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处的左花括号表示一个表达式的开始</p>
</li>
<li><p>在对象字面量中，<strong>使用逗号来分隔不同的属性，在最后一个属性后面不能加逗号</strong></p>
</li>
<li><p><strong>属性名也可以使用字符串</strong>，如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line"><span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的数值属性名会自动转换为字符串</li>
</ul>
</li>
<li><p>如果留空其花括号，则<strong>可以定义只包含默认属性和方法的对象</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; &#125;    <span class="comment">// 与 new Object() 相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数</p>
</li>
<li><p>是<strong>向函数传递大量可选参数的首选方式</strong><br>访问对象属性时一般用点表示法，也可以使用方括号表示法，二者在功能上没有区别，但通常使用点表示法：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]);  <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将要访问的属性以字符串的形式放在方括号中，<strong>主要优点是可以通过变量来访问属性</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]);    <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性名包含会导致语法错误的特殊字符(如空格)，或属性名使用的是关键字或保留字，也可以用方括号表示法。</strong></p>
</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScipt 数组的每一项可以保存任何类型的数据，数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新的数据。<br><br>创建数组的基本方式有两种：</p>
<ol>
<li><p>使用 Array 构造函数</p>
<ul>
<li><p>如果预先知道数组的长度，可以给构造函数传递该数量(会自动变成lenghth属性的值)</p>
</li>
<li><p>可以向 Array 构造函数传递数组中应该包含的项</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给构造函数传递一个值也可以创建数组，但此时如果传递的是数值，则会按照数值创建包含指定项数的数组</p>
</li>
<li><p>使用 Array 构造函数时也可以省略 new 操作符</p>
</li>
</ul>
</li>
<li><p>使用数组字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// 使用方括号</span></span><br><span class="line"><span class="keyword">var</span> names = [ ];                        <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数</li>
</ul>
</li>
</ol>
<ul>
<li>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，索引小于数组项数，则返回对应项的值，否则返回 undefined 值；设置数组的值也使用相同的语法，但会替换指定位置的值，但<strong>如果设置某个值的索引超过了数组现有项数，数组就会自动长度。</strong></li>
<li>数组的项数保存在其 length 属性中，<strong>可以通过设置 length 属性从数组的末尾移除项或向数组中添加新项</strong>(新增的每一项为 “undefined” 值)。</li>
</ul>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul>
<li>对于一个网页或者一个全局作用域而言，使用 instanceof 就可以确定某个对象是不是数组</li>
<li>Array.isArray( ) 方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的</li>
</ul>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>所有对象都具有 都具有 toLocaleString( ) 、 toString( ) 和 valueOf( ) 方法：</p>
<ul>
<li><p>调用 valueOf( ) 返回的还是数组本身</p>
</li>
<li><p>调用数组的 toString( ) 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串(实际上,为了创建这个字符串会调用数组每一项的 toString( ) 方法)</p>
</li>
<li><p>调用数组的 toLocaleString( ) 方法时，它也会创建一个数组值的以逗号分隔的字符串(为了取得每一项的值，调用的是每一项的 toLocaleString( ) 方法)<br>数组继承的 toLocaleString( ) 、 tostring( ) 和 valueof( ) 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项<br>如果使用 join( ) 方法，则可以使用不同的分隔符来构建这个字符串</p>
</li>
<li><p>join( ) 方法只接收一个参数，即用作分隔符的字符串</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果数组中某一项值是 <strong>null 或 undefined，则该值在返回结果中以空字符串表示</strong>。</p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>数组可以表现得像<strong>栈</strong>一样：</p>
<ul>
<li>栈是一种 LIFO ( Last-In-First-Out ,后进先出 ) 的数据结构，也就是最新添加的项最早被移除</li>
<li>栈中项的插入(叫做<strong>推入</strong>)和移除(叫做<strong>弹出</strong>)只发生在栈的顶部</li>
</ul>
<p>ECMAScipt 为数组提供了 push( ) 和 pop( ) 方法，以便实现类似栈的行为：</p>
<ul>
<li>push( ) 方法可以接收任意数量的参数，将其逐个添加到数组末尾，并返回修改后数组的长度</li>
<li>pop( ) 方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO ( First-In-First-Out ,先进先出 ) ，队列在列表的末端添加项，从列表的前端移除项。</p>
<p>结合使用 push( ) 和 shift( ) 方法，可以像使用队列一样使用数组：</p>
<ul>
<li>shift( ) 方法能够移除数组中的第一个项并返回该项，同时将数组长度减 1</li>
</ul>
<p>结合使用 pop( ) 方法和 unshift( ) 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末尾移除项：</p>
<ul>
<li>unshift( ) 方法能在数组前端添加任意个项并返回数组长度</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><ul>
<li><p>reverse( ) 方法：会反转数组项的顺序</p>
</li>
<li><p>sort( ) 方法：按升序排列数组项</p>
<ul>
<li><p>会调用每个数组项的 toString( ) 转型方法，然后比较得到的字符串，以确定如何排序</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort( );</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 10, 15, 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>很多情况下都不是最佳方案，因此 sort( ) 方法可以接收一个比较函数作为参数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 5, 10, 15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果第一个应该位于第二个之前则返回一个负数，两个参数相等则返回 0 ，如果第一个参数应该位于第二个之后则返回一个正数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>reverse( ) 方法和 sort( ) 方法的返回值是经过排序之后的数组</p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><p>两种查找方法：</p>
<ul>
<li>indexOf( ) 方法：从数组的开头(位置 0 )开始向后查找</li>
<li>lastIndexOf( ) 方法：从数组的末尾开始向前查找</li>
</ul>
<p>二者都接收两个参数：要查找的项和表示查找起点位置的索引(可选)，在比较第一个参数与数组中的每一项时<strong>使用全等操作符</strong>(要求查找的项严格相等)。二者都返回要查找的项在数组中的位置，没找到则返回 -1。</p>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li>ECMAScript 5 为数组定义了 5 个迭代方法：<ol>
<li>every( ) : 对数组中每一项都运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li>filter( ) : 对数组中每一项都运行给定函数，返回该函数会返回 true 的项组成的数组</li>
<li>forEach ( ) : 对数组中每一项都运行给定函数，没有返回值</li>
<li>map( ) : 对数组中每一项都运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>some( ) : 对数组中每一项都运行给定函数，如果该函数对任一项返回 true，则返回 true</li>
</ol>
</li>
<li>每个方法都接收两个参数：<ol>
<li>要在每一项上都运行的函数<ul>
<li>传入这些方法的函数会接收三个参数：数组的项、该项在数组中的位置、数组对象本身</li>
</ul>
</li>
<li>(可选)运行该函数的作用域对象————影响 this 的值</li>
</ol>
</li>
</ul>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li>ECMAScript 5 新增了两个归并数组的方法，二者都会迭代数组的所有项，然后构建一个最终返回的值：<ol>
<li>reduce( ) ：从数组第一项开始逐个遍历到最后</li>
<li>reduceRight( ) ：从数组最后一项开始遍历到第一项</li>
</ol>
</li>
<li>二者都接收两个参数：<ol>
<li>一个在每一项上调用的函数<ul>
<li>函数接收四个参数：前一个值、当前值、项的索引、数组对象</li>
<li>这个函数返回的任何值都会作为第一个参数自动传给下一项(第一次迭代发生在数组的第二项上)</li>
</ul>
</li>
<li>(可选)作为归并基础的初始值</li>
</ol>
</li>
</ul>
<h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul>
<li><p>要创建一个日期对象，使用 new 操作符和 Date 构造函数</p>
<ul>
<li>不传递参数时，新创建的对象自动获得当前日期和时间</li>
<li>如果想创建特定日期对象，必须传入表示该日期的毫秒数(即从 UTC 时间 1 月 1 日午夜起至该日期经过的毫秒数)</li>
</ul>
</li>
<li><p>为了简化计算，ECMAScript 5 提供了两个方法：</p>
<ol>
<li>Data.parse( ) :接受一个表示日期的字符串参数，然后返回相应的毫秒数<ul>
<li>如果传入的字符串不能表示日期，则返回 NaN</li>
<li>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Data.parse( )</li>
</ul>
</li>
<li>Date.UTC( ) ：参数分别是年份、基于 0 的月份(一月是 0 )、月中的哪一天( 1 到 31 )、小时数( 0 到 23 )、分钟、秒、毫秒数，返回表示日期的毫秒数<ul>
<li>参数中只有年和月是必须的，其他假设为 0 或 1 (范围内最小)</li>
<li>Date 构造函数也会模仿 Date.UTC( ) ，但日期和时间都基于本地时区而非 GMT 来创建</li>
</ul>
</li>
</ol>
</li>
<li><p>Date.now( ) 方法返回表示调用这个方法的日期和时间的毫秒数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();     <span class="comment">// 获得开始的时间</span></span><br><span class="line">doSomething();              <span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();      <span class="comment">// 取得停止时间</span></span><br><span class="line">    result = top - start;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在不支持Date.now( ) 方法的浏览器中，使用 + 操作符获取对象 Date 的时间戳也可达到相同的目的</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><ul>
<li>与其他引用类型一样，Date 类型也重写了 toLacaleString( )、toString( ) 和 valueOf( ) 方法<ul>
<li>toLacaleString( ) 方法会按照与浏览器设置的地区相适应的格式返回日期和时间(因浏览器而异)</li>
<li>toString( ) 方法则通常返回带有时区信息的日期和时间，其中一般以军用时间(即小时的范围是 0 到 23)表示(因浏览器而异)</li>
<li>valueOf( ) 方法不返回字符串，而是返回日期的毫秒表示，因此可以使用比较操作符来比较日期值</li>
</ul>
</li>
</ul>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><ul>
<li>Date类型还有一些专门用于将日期格式化为字符串的方法：<ol>
<li>toDateString( ) : 以特定于实现的格式显示星期几、月、日和年</li>
<li>toTimeString( ) : 以特定于实现的格式显示时、分、秒和时区</li>
<li>toLocaleDateString( ) : 以特定于地区的格式显示星期几、月、日和年</li>
<li>toLocaleTimeString( ) : 以特定于实现的格式显示时、分、秒</li>
<li>toUTCString( ) : 以特定于实现的格式完整的UTC日期</li>
</ol>
</li>
<li>以上这些字符串格式式方法的输出也是因浏览器而异的</li>
</ul>
<h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><h2 id="RexExp-类型"><a href="#RexExp-类型" class="headerlink" title="RexExp 类型"></a>RexExp 类型</h2><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>可以用函数声明语法或者函数表达式来定义函数。</p>
<p>函数实际上是对象，是Function类型的实例，因此函数名就是一个指向函数对象的指针，不会与某个函数绑定。由于函数名的指针性质，一个函数可能会有很多名字。</p>
<p>使用不带圆括号的函数命是访问函数指针，而不是调用函数。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>创建两个同名函数，第二个函数会覆盖第一个。</p>
<h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><ul>
<li>解析器会先读取函数声明，，并使其在执行任何代码之前可用</li>
<li>函数表达式则必须等到解析器执行到它所在的代码行才会被解释执行</li>
</ul>
<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>由于函数名本身就是变量，所以函数也可以作为值来使用(可以把函数传递给另一个函数，也可以将一个函数作为另一个函数的结果返回)</p>
<h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><p>函数内部有两个特殊的对象：arguments和this：</p>
<ul>
<li>arguments：主要用途是保存函数参数，还有一个名叫 callee 的属性，该属性是一个指向拥有这个arguments对象的函数的指针(可以消除递归算法中函数命耦合的问题)</li>
<li>this：引用的是函数执行的环境对象</li>
</ul>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/快乐暑假第3天/" data-id="cjyql0wpc000jvsuwuoazwiwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/11/快乐暑假第4天/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          快乐暑假第4天
        
      </div>
    </a>
  
  
    <a href="/2019/07/09/快乐暑假第2天/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">快乐暑假第2天</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
          </li>
        
          <li>
            <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
          </li>
        
          <li>
            <a href="/2019/07/28/快乐暑假第18天——继续学习nodejs/">快乐暑假第18天——继续学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/26/快乐暑假第17天——开始学习nodejs/">快乐暑假第17天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第16天——继续做Bolo/">快乐暑假第16天——继续做Bolo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>