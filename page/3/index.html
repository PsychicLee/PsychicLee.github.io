<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lee&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lee&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-快乐暑假第3天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/快乐暑假第3天/" class="article-date">
  <time datetime="2019-07-10T10:05:08.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/快乐暑假第3天/">快乐暑假第3天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：

<ul>
<li>进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接</li>
<li>进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算</li>
<li>乘除求模操作时，如果有一个操作数不是数值，则会在后台调用 Number( ) 将其转换为数值再进行计算</li>
<li>关系操作符也会进行一些转换然后进行比较</li>
</ul>
</p>

<p style="font-size:18px;text-align:left;text-indent:2em">
除此之外还有很多操作符都会进行隐式转换，一时半会很难全部记住，还需要在以后的学习和实践中慢慢积累，然后逐渐掌握牢固。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
语句方面大部分语法都与C相同，因此很容易就能记住并使用，但也有一些像for-in语句、label语句之类的之前并没有接触过，感到比较陌生。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
函数方面，我觉得其参数的保存机制挺有意思的，这种类似数组的保存方式也给函数的使用带来了更大的发挥空间。但是任何事物都有两面性，自由宽松或许会容易造成某些错误，这也需要在之后的实践中慢慢摸索。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
学习了作用域以及作用域链的相关工作原理之后也明白了一些之前不是很清楚的东西，比如在一个局部环境中定义一个与上一级环境中某个变量同名的变量是可行的，并且在该局部变量中使用这个变量时并不用担心这个变量的值会不会受到上一级环境中的同名变量的影响。作用域链就像一棵树一样，全局环境是根部，其中又包含了许多互不相干的局部环境，可以在小环境中使用相应父级环境定义的变量或函数，但不能使用子级的任何东西。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
引用类型这部分，虽然书里讲述的意思看懂了，但是总觉得有一点空，对引用类型还没有很好的掌握和理解，还不是很熟悉。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-变量、作用域和内存问题"><a href="#3-变量、作用域和内存问题" class="headerlink" title="3.变量、作用域和内存问题"></a>3.变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>ECMAScipt 变量可能包含两种不同数据类型的值：<ul>
<li>基本类型值：指的是简单的数据段，在内存中占据固定大小空间，因此被保存在<strong>栈内存</strong>中</li>
<li>引用类型值：指那些可能由多个值构成的对象，保存在<strong>堆内存</strong>中</li>
</ul>
</li>
<li>5种基本数据类型是按值访问的，因为<strong>可以操作保存在变量中的实际的值</strong></li>
<li>引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置，也就是说<strong>不能直接操作对象的内存空间</strong></li>
</ul>
<h4 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h4><p>只能给引用类型值动态地添加属性，以便将来使用 (给基本类型值添加属性不会报错，但没有效果)。</p>
<h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><ul>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，二者的值相同但完全独立，进行任何操作都不会互相影响</li>
<li>从一个变量向另一个变量复制引用类型的值，实际上新变量是一个指针，指向一个对象，复制操作结束后二者将引用同一个对象</li>
</ul>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><p>ECMAScript 中所有函数的参数都是按值传递的 (<strong>访问变量有按值和按引用两种方式，而参数只能按值传递</strong>)</p>
<ul>
<li>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数)</li>
<li>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部</li>
</ul>
<p>证明对象是按值传递的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person);  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性为 “Grey” 的新对象，但接下来访问 person.name 时，显示的值仍然是 “Nicholas”</li>
<li>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持不变<br>  实际上，在函数内部重写 obj 时，这个变量引用的就是一个局部对象了 (会在函数执行完毕后被销毁)</li>
</ul>
<p>可以把 ECMAScipt 函数的参数想象成局部变量。</p>
<h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>typeof 操作符在检测引用类型的值时作用不大，当我们想知道某个值是什么类型的对象可以使用 instanceof 操作符</p>
<ul>
<li><p>语法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量是给定引用类型的实例，那么 instanceof 操作符就会返回 true，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//变量 person 是 Object 吗？</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">//变量 colors 是 Array 吗？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有引用类型的值都是 Object 的实例，因此在检测一个引用类型的值和 Object 构造函数时，始终返回 true</p>
</li>
<li><p>如果使用 instanceof 操作符检测基本类型的值，则始终返回 false</p>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
<p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中，虽然代码无法访问，但解析器处理数据时会用到它。</p>
<p>在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法去创造的。</p>
<p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数也随之销毁(全局执行环境直到应用程序退出————例如关闭网页或浏览器————时才会被销毁)。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问，其前端始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。</p>
<ul>
<li>活动对象在最开始时只包含一个变量，即 arguments 对象(找个对象在全局环境中是不存在的)</li>
</ul>
<p>作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境(全局执行环境的变量对象始终是作用域链中的最后一个对象)。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终<strong>从作用域链的前端开始，逐级向后回溯</strong>，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。</p>
<p><strong>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数</strong>。</p>
<p>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>当执行流进入下列任何一个语句时，作用域链就会得到加长(这两个语句都会在作用域链的前端添加一个变量对象)：</p>
<ol>
<li>try-catch 语句的 catch 块<ul>
<li>会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</li>
</ul>
</li>
<li>with 语句<ul>
<li>会将指定的对象添加到作用域链中</li>
</ul>
</li>
</ol>
<h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><p>在其他类 C 语言中，由花括号封闭的代码都有自己的块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure>

<p>对于有块级作用域的语言来说，for 循环初始化的变量 i 只会存在于循环的环境中；而对于 JavaScript 来说，for 创建的 i 即使在循环结束之后，也会存在于循环的外部环境中。</p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>使用 var 声明的变量会自动添加到<strong>最接近</strong>的环境中(如果初始化变量时没有使用 var 声明，该变量会自动添加到全局环境)</p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>搜索过程<strong>从作用域链的前端开始</strong>，向上级查询与给定名字匹配的标识符，如果在局部环境找到了该标识符，搜索过程停止(<strong>如果局部环境存在着同名标识符，就不会使用位于父环境的标识符</strong>)。</p>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>执行环境会负责管理代码执行过程中使用的内存，所需内存的分配以及无用内存的回收完全实现了自动管理。机制为<strong>周期性执行</strong>：找出无用变量，将其所占内存释放。</p>
<ul>
<li>用于标识无用变量的策略通常有两个：标记清除(最常用)、引用计数(少用)</li>
</ul>
<p><strong>管理内存</strong>：优化占用内存的最佳方式就是执行中的代码只保存必要的数据，一旦数据不再有用，将其值设置为 null 来释放其引用，称为<strong>解除引用</strong>(局部变量会在离开执行环境时自动被解除引用，全局变量需要手工为它解除引用)。</p>
<h1 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4. 引用类型"></a>4. 引用类型</h1><blockquote>
<p>引用类型的值(对象)是引用类型的一个实例<br><br>在 JavaScript 中引用类型是一种数据结构，用于将数据和功能组织在一起<br><br>引用类型有时候也被称为对象定义,因为它们描述的是一类对象所具有的属性和方法,对象是某个特定引用类型的实例</p>
</blockquote>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建 Object 实例的方式有两种</p>
<ol>
<li><p>使用 new 操作符后跟 Object 构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处的左花括号表示一个表达式的开始</p>
</li>
<li><p>在对象字面量中，<strong>使用逗号来分隔不同的属性，在最后一个属性后面不能加逗号</strong></p>
</li>
<li><p><strong>属性名也可以使用字符串</strong>，如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line"><span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的数值属性名会自动转换为字符串</li>
</ul>
</li>
<li><p>如果留空其花括号，则<strong>可以定义只包含默认属性和方法的对象</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; &#125;    <span class="comment">// 与 new Object() 相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数</p>
</li>
<li><p>是<strong>向函数传递大量可选参数的首选方式</strong><br>访问对象属性时一般用点表示法，也可以使用方括号表示法，二者在功能上没有区别，但通常使用点表示法：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]);  <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将要访问的属性以字符串的形式放在方括号中，<strong>主要优点是可以通过变量来访问属性</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]);    <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性名包含会导致语法错误的特殊字符(如空格)，或属性名使用的是关键字或保留字，也可以用方括号表示法。</strong></p>
</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScipt 数组的每一项可以保存任何类型的数据，数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新的数据。<br><br>创建数组的基本方式有两种：</p>
<ol>
<li><p>使用 Array 构造函数</p>
<ul>
<li><p>如果预先知道数组的长度，可以给构造函数传递该数量(会自动变成lenghth属性的值)</p>
</li>
<li><p>可以向 Array 构造函数传递数组中应该包含的项</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给构造函数传递一个值也可以创建数组，但此时如果传递的是数值，则会按照数值创建包含指定项数的数组</p>
</li>
<li><p>使用 Array 构造函数时也可以省略 new 操作符</p>
</li>
</ul>
</li>
<li><p>使用数组字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// 使用方括号</span></span><br><span class="line"><span class="keyword">var</span> names = [ ];                        <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数</li>
</ul>
</li>
</ol>
<ul>
<li>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，索引小于数组项数，则返回对应项的值，否则返回 undefined 值；设置数组的值也使用相同的语法，但会替换指定位置的值，但<strong>如果设置某个值的索引超过了数组现有项数，数组就会自动长度。</strong></li>
<li>数组的项数保存在其 length 属性中，<strong>可以通过设置 length 属性从数组的末尾移除项或向数组中添加新项</strong>(新增的每一项为 “undefined” 值)。</li>
</ul>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul>
<li>对于一个网页或者一个全局作用域而言，使用 instanceof 就可以确定某个对象是不是数组</li>
<li>Array.isArray( ) 方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的</li>
</ul>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>所有对象都具有 都具有 toLocaleString( ) 、 toString( ) 和 valueOf( ) 方法：</p>
<ul>
<li><p>调用 valueOf( ) 返回的还是数组本身</p>
</li>
<li><p>调用数组的 toString( ) 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串(实际上,为了创建这个字符串会调用数组每一项的 toString( ) 方法)</p>
</li>
<li><p>调用数组的 toLocaleString( ) 方法时，它也会创建一个数组值的以逗号分隔的字符串(为了取得每一项的值，调用的是每一项的 toLocaleString( ) 方法)<br>数组继承的 toLocaleString( ) 、 tostring( ) 和 valueof( ) 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项<br>如果使用 join( ) 方法，则可以使用不同的分隔符来构建这个字符串</p>
</li>
<li><p>join( ) 方法只接收一个参数，即用作分隔符的字符串</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果数组中某一项值是 <strong>null 或 undefined，则该值在返回结果中以空字符串表示</strong>。</p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>数组可以表现得像<strong>栈</strong>一样：</p>
<ul>
<li>栈是一种 LIFO ( Last-In-First-Out ,后进先出 ) 的数据结构，也就是最新添加的项最早被移除</li>
<li>栈中项的插入(叫做<strong>推入</strong>)和移除(叫做<strong>弹出</strong>)只发生在栈的顶部</li>
</ul>
<p>ECMAScipt 为数组提供了 push( ) 和 pop( ) 方法，以便实现类似栈的行为：</p>
<ul>
<li>push( ) 方法可以接收任意数量的参数，将其逐个添加到数组末尾，并返回修改后数组的长度</li>
<li>pop( ) 方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO ( First-In-First-Out ,先进先出 ) ，队列在列表的末端添加项，从列表的前端移除项。</p>
<p>结合使用 push( ) 和 shift( ) 方法，可以像使用队列一样使用数组：</p>
<ul>
<li>shift( ) 方法能够移除数组中的第一个项并返回该项，同时将数组长度减 1</li>
</ul>
<p>结合使用 pop( ) 方法和 unshift( ) 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末尾移除项：</p>
<ul>
<li>unshift( ) 方法能在数组前端添加任意个项并返回数组长度</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><ul>
<li><p>reverse( ) 方法：会反转数组项的顺序</p>
</li>
<li><p>sort( ) 方法：按升序排列数组项</p>
<ul>
<li><p>会调用每个数组项的 toString( ) 转型方法，然后比较得到的字符串，以确定如何排序</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort( );</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 10, 15, 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>很多情况下都不是最佳方案，因此 sort( ) 方法可以接收一个比较函数作为参数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 5, 10, 15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果第一个应该位于第二个之前则返回一个负数，两个参数相等则返回 0 ，如果第一个参数应该位于第二个之后则返回一个正数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>reverse( ) 方法和 sort( ) 方法的返回值是经过排序之后的数组</p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><p>两种查找方法：</p>
<ul>
<li>indexOf( ) 方法：从数组的开头(位置 0 )开始向后查找</li>
<li>lastIndexOf( ) 方法：从数组的末尾开始向前查找</li>
</ul>
<p>二者都接收两个参数：要查找的项和表示查找起点位置的索引(可选)，在比较第一个参数与数组中的每一项时<strong>使用全等操作符</strong>(要求查找的项严格相等)。二者都返回要查找的项在数组中的位置，没找到则返回 -1。</p>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li>ECMAScript 5 为数组定义了 5 个迭代方法：<ol>
<li>every( ) : 对数组中每一项都运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li>filter( ) : 对数组中每一项都运行给定函数，返回该函数会返回 true 的项组成的数组</li>
<li>forEach ( ) : 对数组中每一项都运行给定函数，没有返回值</li>
<li>map( ) : 对数组中每一项都运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>some( ) : 对数组中每一项都运行给定函数，如果该函数对任一项返回 true，则返回 true</li>
</ol>
</li>
<li>每个方法都接收两个参数：<ol>
<li>要在每一项上都运行的函数<ul>
<li>传入这些方法的函数会接收三个参数：数组的项、该项在数组中的位置、数组对象本身</li>
</ul>
</li>
<li>(可选)运行该函数的作用域对象————影响 this 的值</li>
</ol>
</li>
</ul>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li>ECMAScript 5 新增了两个归并数组的方法，二者都会迭代数组的所有项，然后构建一个最终返回的值：<ol>
<li>reduce( ) ：从数组第一项开始逐个遍历到最后</li>
<li>reduceRight( ) ：从数组最后一项开始遍历到第一项</li>
</ol>
</li>
<li>二者都接收两个参数：<ol>
<li>一个在每一项上调用的函数<ul>
<li>函数接收四个参数：前一个值、当前值、项的索引、数组对象</li>
<li>这个函数返回的任何值都会作为第一个参数自动传给下一项(第一次迭代发生在数组的第二项上)</li>
</ul>
</li>
<li>(可选)作为归并基础的初始值</li>
</ol>
</li>
</ul>
<h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul>
<li><p>要创建一个日期对象，使用 new 操作符和 Date 构造函数</p>
<ul>
<li>不传递参数时，新创建的对象自动获得当前日期和时间</li>
<li>如果想创建特定日期对象，必须传入表示该日期的毫秒数(即从 UTC 时间 1 月 1 日午夜起至该日期经过的毫秒数)</li>
</ul>
</li>
<li><p>为了简化计算，ECMAScript 5 提供了两个方法：</p>
<ol>
<li>Data.parse( ) :接受一个表示日期的字符串参数，然后返回相应的毫秒数<ul>
<li>如果传入的字符串不能表示日期，则返回 NaN</li>
<li>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Data.parse( )</li>
</ul>
</li>
<li>Date.UTC( ) ：参数分别是年份、基于 0 的月份(一月是 0 )、月中的哪一天( 1 到 31 )、小时数( 0 到 23 )、分钟、秒、毫秒数，返回表示日期的毫秒数<ul>
<li>参数中只有年和月是必须的，其他假设为 0 或 1 (范围内最小)</li>
<li>Date 构造函数也会模仿 Date.UTC( ) ，但日期和时间都基于本地时区而非 GMT 来创建</li>
</ul>
</li>
</ol>
</li>
<li><p>Date.now( ) 方法返回表示调用这个方法的日期和时间的毫秒数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();     <span class="comment">// 获得开始的时间</span></span><br><span class="line">doSomething();              <span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();      <span class="comment">// 取得停止时间</span></span><br><span class="line">    result = top - start;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在不支持Date.now( ) 方法的浏览器中，使用 + 操作符获取对象 Date 的时间戳也可达到相同的目的</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><ul>
<li>与其他引用类型一样，Date 类型也重写了 toLacaleString( )、toString( ) 和 valueOf( ) 方法<ul>
<li>toLacaleString( ) 方法会按照与浏览器设置的地区相适应的格式返回日期和时间(因浏览器而异)</li>
<li>toString( ) 方法则通常返回带有时区信息的日期和时间，其中一般以军用时间(即小时的范围是 0 到 23)表示(因浏览器而异)</li>
<li>valueOf( ) 方法不返回字符串，而是返回日期的毫秒表示，因此可以使用比较操作符来比较日期值</li>
</ul>
</li>
</ul>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><ul>
<li>Date类型还有一些专门用于将日期格式化为字符串的方法：<ol>
<li>toDateString( ) : 以特定于实现的格式显示星期几、月、日和年</li>
<li>toTimeString( ) : 以特定于实现的格式显示时、分、秒和时区</li>
<li>toLocaleDateString( ) : 以特定于地区的格式显示星期几、月、日和年</li>
<li>toLocaleTimeString( ) : 以特定于实现的格式显示时、分、秒</li>
<li>toUTCString( ) : 以特定于实现的格式完整的UTC日期</li>
</ol>
</li>
<li>以上这些字符串格式式方法的输出也是因浏览器而异的</li>
</ul>
<h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><h2 id="RexExp-类型"><a href="#RexExp-类型" class="headerlink" title="RexExp 类型"></a>RexExp 类型</h2><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>可以用函数声明语法或者函数表达式来定义函数。</p>
<p>函数实际上是对象，是Function类型的实例，因此函数名就是一个指向函数对象的指针，不会与某个函数绑定。由于函数名的指针性质，一个函数可能会有很多名字。</p>
<p>使用不带圆括号的函数命是访问函数指针，而不是调用函数。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>创建两个同名函数，第二个函数会覆盖第一个。</p>
<h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><ul>
<li>解析器会先读取函数声明，，并使其在执行任何代码之前可用</li>
<li>函数表达式则必须等到解析器执行到它所在的代码行才会被解释执行</li>
</ul>
<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>由于函数名本身就是变量，所以函数也可以作为值来使用(可以把函数传递给另一个函数，也可以将一个函数作为另一个函数的结果返回)</p>
<h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><p>函数内部有两个特殊的对象：arguments和this：</p>
<ul>
<li>arguments：主要用途是保存函数参数，还有一个名叫 callee 的属性，该属性是一个指向拥有这个arguments对象的函数的指针(可以消除递归算法中函数命耦合的问题)</li>
<li>this：引用的是函数执行的环境对象</li>
</ul>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/快乐暑假第3天/" data-id="ck08xcp4x000mz4uwa94p12ag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第2天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/09/快乐暑假第2天/" class="article-date">
  <time datetime="2019-07-09T12:46:57.000Z" itemprop="datePublished">2019-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/快乐暑假第2天/">快乐暑假第2天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天是暑假培训第二天，今天开始学习js高程，其实前几章我之前就看过了，也做了一些笔记。但是现在再翻开书却发现相当多的内容都已经忘记了，因此我又从头开始看起。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
前三章讲的是一些基本的语法和概念，给我的感受大概是js的语法更加宽松和自由，例如声明变量都是用var来进行、不同类型的值能一起进行运算等等。但其实这些内容都比较琐碎，也比较难一次性就记得清楚，不应该在这部分花太多精力去死记硬背。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
计划明天上午看完第三四章(即语法概念部分和作用域链等)，然后将主要精力放在后面的重点上。
</p>


<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-在-HTML-中使用-JavaScript"><a href="#1-在-HTML-中使用-JavaScript" class="headerlink" title="1. 在 HTML 中使用 JavaScript"></a>1. 在 HTML 中使用 JavaScript</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>主要使用 <script> 元素向 HTML 页面中插入 JavaScript ，而其中又有两种使用方式，包括直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript 文件：</p>
<ul>
<li>直接嵌入代码：此时只需要为 <script> 指定 type 属性，然后直接把代码放在元素内部<ul>
<li>若使用这种方法，代码中不能出现"</script>“字符串，可以使用转义字符”&quot;解决这个问题如：alert(“&lt;/script&gt;”);


<li>包含外部文件：此时要设置 src 属性，属性值就是所指向的文件的地址<ul>
<li>不能再在标签之间包含额外的代码</li>
</ul>
</li>

</p><h2 id="lt-script-gt-其他属性"><a href="#lt-script-gt-其他属性" class="headerlink" title="&lt;script&gt; 其他属性"></a>&lt;script&gt; 其他属性</h2><p>有一些属性很少用或者已经废弃了，以下几个属性平时可能会用得上：</p>
<ul>
<li>async：可选。表示应该立即下载脚本。只对外部脚本文件有效<ul>
<li>异步脚本，表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，目的是不让页面等待脚本下载和执行。但不能保证异步脚本按照在页面中的出现顺序执行</li>
</ul>
</li>
<li>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效<ul>
<li>将延迟脚本放在页面底部是最佳选择</li>
</ul>
</li>
<li>type：可选。表示编写代码使用的脚本语言的内容类型</li>
<li>src：可选。表示包含要执行代码的外部文件</li>
</ul>
<blockquote>
<p>如果不存在 async 和 defer 属性，浏览器会按照 &lt;script&gt; 出现的先后顺序来进行解析</p>
</blockquote>
<h2 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h2><p>为了避免各种各样的问题，一般把全部 JavaScript 引用放在<body>元素中页面内容的后面</body></p>
<h2 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><noscript> 元素</noscript></h2><p>用以在不支持 JavaScript 的浏览器中显示替换的内容</p>
<h1 id="2-语法和基本概念"><a href="#2-语法和基本概念" class="headerlink" title="2. 语法和基本概念"></a>2. 语法和基本概念</h1><blockquote>
<p>ECMAScript 语法大量借鉴了类 C 语言的语法，但相比之下更让人感到自由和宽松。</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h4><p>变量、函数名、操作符都区分大小写</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符就是指变量、函数、属性的名字或者函数的参数，有一定的格式规则：</p>
<ol>
<li>第一个字符必须是一个字母、下划线”_”或一个美元符号”$”</li>
<li>其他字符可以是字母、下划线或者数字</li>
</ol>
<p>不能把关键字、保留字等用作标识符。按照惯例，标识符采用驼峰大小写格式。</p>
<h4 id="注释和语句"><a href="#注释和语句" class="headerlink" title="注释和语句"></a>注释和语句</h4><p>注释有两种方式，双斜杠(单行)和斜杠星(多行)。<br>一个语句以分号结尾，分号可以省略，但可能会造成各种各样难以描述的错误。<br>始终在控制语句中使用代码块是个好习惯。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>这一点与之前学习过的 C 语言有着很大的区别， ECMAScript 的变量是松散型的，可以用来保存任何类型的数据，相当于每个变量只是一个占位符，里面放什么数据都没问题。<br>定义变量用 var 操作符。</p>
<ul>
<li>可以在定义的同时初始化变量(未经初始化的变量会保存一个undefined值)</li>
<li>可以修改成类型不同的值，但最好不要这么做</li>
<li>在函数中var的变量是一个局部变量，函数退出后即销毁(可以省略var来创建一个全局变量)</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5种简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String，1种复杂数据类型：Object。<br>不支持任何创建自定义类型的机制，因此所有的值最终都是6种数据类型之一。</p>
<h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>var出来的变量可以是任何类型的数据，因此需要一个用来<strong>检测给定变量的数据类型</strong>的手段。<br><br>对一个值使用typeof操作符后可能会返回某个字符串：</p>
<ul>
<li>“undefined”: 值未定义</li>
<li>“boolean”: 值是布尔值</li>
<li>“string”: 值是字符串</li>
<li>“number”: 值是数值</li>
<li>“object”: 值是对象或null<ul>
<li>特殊值null会被认为是一个空的对象引用</li>
</ul>
</li>
<li>“function”: 值是函数<ul>
<li>从技术角度讲，函数是对象，不是数据类型，但有必要区分函数和其他对象</li>
</ul>
</li>
</ul>
<h4 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h4><p>此类型只有一个特殊值 undefined ，用var声明但未对其加以初始化的变量就保存着undefined值。与显式初始化为 undefined 的效果是一样的。<br><br>但是，<strong>包含 undefined 的变量和未声明的变量还是不一样的</strong>：对于尚未声明过的变量，只能执行typeof操作，且也会返回undefined值。因此，如果能够做到显式地初始化变量，当typeof返回”undefined”时就能够知道被检测的变量是还没有被声明，而不是尚未初始化。</p>
<h4 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h4><p>此类型也只有一个特殊值 null ，从逻辑角度看表示一个<strong>空对象指针</strong>(因此使用typeof检测会返回”object”)。<br><br>可以把准备用来保存对象的变量初始化为null，这样一来，就可以通过检测变量值是否为null来判断该变量是否已经保存了一个对象的引用。<br><br>undefined值是派生自null值的，因此对二者的<strong>相等性测试要返回 true</strong>。</p>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p>该类型有 true 和 false 两个字面值，区分大小写。这两个值与数字值不是一回事，即 true 不一定等于 1 ，flase不一定等于 0 。<br><br><strong>转型函数Boolean( )</strong>:用于将一个值转化为其对应的 Boolean 值，可以对任何类型的值调用，其转换规则如下<br>| 数据类型 | 转换为true的值 | 转换为false的值 |<br>| :- | :- | :- |<br>| Boolean | true | false |<br>| String | 任何非空字符串 | “ “(空字符串) |<br>| Number | 任何非零数值(包括无穷大) | 0和null |<br>| Object | 任何对象 | null |<br>| Undefined | n/a(不适用) | undefined |</p>
<blockquote>
<p>控制流语句 (如 if ) 自动执行 Boolean 转换就是按照上面的规则来转换</p>
</blockquote>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number( ) 类型"></a>Number( ) 类型</h4><p>JavaScript总是会不失时机地<strong>把浮点数转换为整数来保存</strong>，例如小数点后没有数字，或者浮点数本身就是表示一个整数的时候，都会被转换为整数。</p>
<p><strong>e表示法</strong>(科学记数法)：3.125e7 = 3.125E7 = 31250000 (一般会默认将小数点后带有6个0以上的浮点数值转换为e表示法表示的数值)</p>
<p>十进制是最基本的数值字面量格式，因此可以在代码中直接输入十进制数值。在进行算术计算时，八进制和十六进制的数值最终都会转换为十进制数值。</p>
<ul>
<li>八进制：第一位是0，后跟0 ~ 7(如果超出范围，则会按照十进制数值解析)。</li>
<li>十六进制：前两位是0x，后跟0 ~ 9及A ~ F(与标识符不一样，这里的字母大小写均可)。</li>
</ul>
<blockquote>
<p>可以保存+0和-0，但认为二者相等。</p>
</blockquote>
<p>由于计算方式的问题，在进行<strong>浮点数的算术计算时精确度不高</strong>，因此不要做浮点数相应的运算测试如 if ( a + b == 0.3 );</p>
<p>由于内存限制，所能表示的数值是有一定范围的，其中最小的数值保存在 <strong>Number.MIN_VALUE</strong> 中，最大的数值保存在 <strong>Number.MAX_VALUE</strong> 中,超过这两个值的数值表示为 -Infinity 或 Infinity 。<strong>(Infinity不能参与计算)</strong>。<br><br>正负无穷分别保存在 <strong>Number.NEGATIVE_INFINITY</strong> 和 <strong>Number.POSITIVE_INFINITY</strong> 中，用来在在执行极大数值和极小数值时监测监控这些值。</p>
<p><strong>NaN</strong>:用于表示一个本来要返回数值的操作数未返回数值的情况。</p>
<ul>
<li>任何涉及 NaN 的操作都会返回 NaN</li>
<li>NaN 与任何值都不相等，包括它本身</li>
</ul>
<p><strong>isNaN( )函数</strong>：用于检测一个数值是否为 NaN ，如果接收的参数无法转换为数值，就会返回 true。</p>
<p>有3个函数可以把非数值转换为数值：</p>
<ul>
<li>Number( )：适用于任何数据类型<ul>
<li>Boolean值，true和false分别转换为1和0</li>
<li>数字值，只是简单的传入和返回</li>
<li>null值，返回0</li>
<li>undefined，返回NaN</li>
<li>字符串，遵循下列规则<ul>
<li>只包含数字(包括带正负号的情况)，则转换为十进制数(会忽略前导0)</li>
<li>包含有效的浮点格式，则转换为对应的浮点数值(也会忽略前导0)</li>
<li>包含有效的十六进制格式，则转换为相同大小的十进制整数值</li>
<li>空字符串，则转换为0</li>
<li>包含上述格式之外的字符，则转换为NaN</li>
<li>对象，则调用对象的valueOf( )方法，然后依照前面的规则转换返回的值。若转换结果是NaN，则调用对象的toString( )方法，然后再次依照前面的规则转换返回的字符串值</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Number( )函数由于其繁杂性和不合理性，实际使用较少，更常用的是 parseInt( ) 函数和 parseFloat( ) 函数。</p>
</blockquote>
<ul>
<li>parseInt( )：专门由于把字符串转换为数值<ul>
<li>会忽略字符串前面的空格，如果第一个非空格字符不是数字字符或符号，则返回 NaN ( 即对空字符串返回NaN，而Number( )返回0 )</li>
<li>如果第一个非空格字符是数字，则会继续解析下一个字符，直到解析完成或遇到非数字字符</li>
<li>可以提供第二个参数，即转换使用的基数，最好是每次都明确基数</li>
</ul>
</li>
<li>parseFloat( )：也是专门由于把字符串转换为数值<ul>
<li><strong>只解析十进制</strong></li>
<li>字符串中第一个小数点是有效的，后面的无效</li>
<li>按照上面的说法，当字符串包含的是可以解析为整数的数，则会返回整数</li>
</ul>
</li>
</ul>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String( ) 类型"></a>String( ) 类型</h4><p>字符串由双引号或单引号来表示。<br><br><strong>转义序列</strong>：作为一个字符来解析。<br><br><strong>length 属性</strong>:任何字符串都可以通过访问此属性来取得其长度。<br><br>字符串是不可变的，即要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。<br><br>将一个值转换为字符串有2种方式：</p>
<ul>
<li>toString( ) 方法：<ul>
<li>数值、布尔值、对象和字符都有该方法，但null和undefined没有</li>
<li>一般不用传递参数，也可以传递输出数值的基数(默认以十进制返回)</li>
</ul>
</li>
<li>转型函数 String( )：能够将任何类型的值转换为字符串<ul>
<li>null 和 undefined 分别转换为 “null” 和 “undefined”</li>
<li>如果值有toString( ) 方法则调用该方法</li>
</ul>
</li>
</ul>
<h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><p>对象就是一组数据和功能的集合，可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。<br><br>也可以创建自定义对象。<br><br>Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在，其中，作为参数的属性名(propertyName)必须以字符串形式指定，例如：o.hasOwnProperty(“name”);</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型(第5章将讨论原型)</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚，作为参数的属性名必须以字符串形式指定</li>
<li>toLocaleString( )：返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString( ):返回对象的字符串表示</li>
<li>valueOf( )：返回对象的字符串、数值或布尔值表示，通常与 toString( ) 方法的返回值相同</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>即只能操作一个值的操作符<br><strong>递增递减操作符</strong><br><strong>一元加和减操作符</strong></p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p><strong>按位非 (NOT)</strong></p>
<p><strong>按位与 (AND)</strong></p>
<p><strong>按位或 (OR)</strong></p>
<p><strong>按位异或 (XOR)</strong></p>
<p><strong>左移</strong></p>
<p><strong>有符号的右移</strong></p>
<p><strong>无符号右移</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/09/快乐暑假第2天/" data-id="ck08xcp4n000iz4uwk23kodgm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第1天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/快乐暑假第1天/" class="article-date">
  <time datetime="2019-07-08T10:51:01.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/快乐暑假第1天/">快乐暑假第1天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>快乐的暑假开始了！！！今天主要学习了git相关的一些东西，以及搭建了自己的博客，虽然在我出色的操作下，遇到了各种各样的奇葩问题</p>
</blockquote>
<h1 id="一、-git相关操作"><a href="#一、-git相关操作" class="headerlink" title="一、 git相关操作"></a>一、 git相关操作</h1><blockquote>
<p>在多人协作完成一个项目的情况下，如果只靠将文件传来传去这种老方法是十分麻烦的，而且人一多就极其容易发生各种各样的错误。因此在多人协作时，需要依靠git这种卓越的工具</p>
</blockquote>
<ol>
<li><p><strong>将远程库的内容克隆到本地</strong><br></p>
<p> 使用命令 <strong>git clone</strong> ，后跟从GitHub复制来的地址</p>
</li>
<li><p><strong>创建自己的分支</strong></p>
<blockquote>
<p>为了避免各种各样的错误，应该创建自己的分支，并在自己的分支里进行各种各样的修改和操作</p>
</blockquote>
<p> 使用命令 <strong>git checkout -b</strong> ,后跟自己分支的名字，此时<strong>head</strong>的指向从<strong>master</strong>变成自己创建的分支</p>
</li>
<li><p><strong>将修改后的文件添加到暂存区</strong></p>
<blockquote>
<p>文件修改后需要先 add 到暂存区，否则无法 commit 到 master 上，可以 add 多个文件之后再 commit</p>
</blockquote>
<p> 使用命令 <strong>git add</strong> ，后跟要添加的文件名或者”.”(表示所有文件)</p>
</li>
<li><p><strong>将暂存区中的文件提交到分支上</strong></p>
<p> 使用命令 <strong>git commit -m “注释”</strong></p>
</li>
<li><p><strong>抓取远程库的文件资源</strong></p>
<blockquote>
<p>自己修改完文件后，可能团队的其他人在此期间内也修改了文件并且已经提交到远程库上，因此在将本地分支推送到远程库之前，为了更新资源避免错误，需要将远程库上的资源抓取到本地</p>
</blockquote>
<p> 使用命令 <strong>git pull</strong></p>
</li>
<li><p><strong>合并分支</strong></p>
<p> 先使用 <strong>git checkout master</strong> 让 head 指向 master 分支，然后使用 <strong>git merge <name></name></strong> 来合并分支</p>
</li>
<li><p><strong>将本地分支推送到远程库中</strong>、</p>
<blockquote>
<p>本地分支他人是不可见的，因此需要将本地分支推送到远程库中</p>
</blockquote>
<p> 使用命令 <strong>git push</strong></p>
</li>
</ol>
<h1 id="二、-hexo博客"><a href="#二、-hexo博客" class="headerlink" title="二、 hexo博客"></a>二、 hexo博客</h1><ul>
<li><strong>hexo n “title”</strong> :创建一篇标题为 title 的博客</li>
<li><strong>hexo g</strong> :生成静态文章</li>
<li><strong>hexo s</strong> :启动本地服务器，用于预览主题</li>
<li><strong>hexo d</strong> :自动生成网站静态文件，并部署到设定的仓库</li>
</ul>
<h1 id="三、-小结"><a href="#三、-小结" class="headerlink" title="三、 小结"></a>三、 小结</h1><ul>
<li>今天是培训第一天，我格外适应这种一坐几个小时都不用动的生活</li>
<li>今天了解了git的一些基本操作，但还不是很熟练，还需要多练习几次</li>
<li>今天开始贯彻落实每天运动的基本方针，强身健体，提神醒脑</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/快乐暑假第1天/" data-id="ck08xcp440007z4uw1hcn7uh2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/05/2019暑假总结/">2019暑假总结</a>
          </li>
        
          <li>
            <a href="/2019/08/02/快乐暑假第22天——学习Vue-js/">快乐暑假第22天——学习Vue.js</a>
          </li>
        
          <li>
            <a href="/2019/07/31/快乐暑假第21天——nodejs简单实现登陆注册/">快乐暑假第21天——nodejs简单实现登陆注册</a>
          </li>
        
          <li>
            <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
          </li>
        
          <li>
            <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>