<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lee&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lee&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-快乐暑假第十七天——开始学习nodejs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/快乐暑假第十七天——开始学习nodejs/" class="article-date">
  <time datetime="2019-07-26T12:58:47.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/快乐暑假第十七天——开始学习nodejs/">快乐暑假第十七天——开始学习nodejs</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-NPM-使用介绍"><a href="#1-NPM-使用介绍" class="headerlink" title="1. NPM 使用介绍"></a>1. NPM 使用介绍</h1><p>Window 系统更新命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>

<h2 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a>使用 npm 命令安装模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a>全局安装与本地安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;       # 本地安装</span><br><span class="line">npm install &lt;Module Name&gt; -g    # 全局安装</span><br></pre></td></tr></table></figure>

<p>如果出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm err! Error: connect ECONNREFUSED 127.0.0.1:8087</span><br></pre></td></tr></table></figure>

<p>解决办法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config set proxy null</span><br></pre></td></tr></table></figure>

<ul>
<li>本地安装<ul>
<li>将安装包放在 ./node _ modules 下（运行 npm 命令时所在的目录），如果没有 node _ modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
</li>
<li>全局安装<ul>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
</li>
</ul>
<h2 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a>查看安装信息</h2><p>查看所有全局安装的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list -g</span><br></pre></td></tr></table></figure>

<p>查看某个模块的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm list grunt</span><br></pre></td></tr></table></figure>

<h2 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a>使用 package.json</h2><p>package.json 位于模块的目录下，用于定义包的属性。</p>
<h4 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h4><ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字。</li>
</ul>
<h2 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a>更新模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm update &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<h1 id="2-Node-js-REPL-交互式解释器"><a href="#2-Node-js-REPL-交互式解释器" class="headerlink" title="2. Node.js REPL(交互式解释器)"></a>2. Node.js REPL(交互式解释器)</h1><h2 id="简单的表达式运算"><a href="#简单的表达式运算" class="headerlink" title="简单的表达式运算"></a>简单的表达式运算</h2><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。</p>
<p>使用 var 关键字的变量可以使用 console.log() 来输出变量。</p>
<h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><p>… 三个点的符号是系统自动生成的，回车换行后即可。Node 会自动检测是否为连续的表达式。</p>
<h2 id="下划线-变量"><a href="#下划线-变量" class="headerlink" title="下划线(_)变量"></a>下划线(_)变量</h2><p>可以使用下划线(_)获取上一个表达式的运算结果：</p>
<h1 id="3-Node-js-回调函数"><a href="#3-Node-js-回调函数" class="headerlink" title="3. Node.js 回调函数"></a>3. Node.js 回调函数</h1><p>回调函数一般作为函数的最后一个参数出现。</p>
<p>阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/快乐暑假第十七天——开始学习nodejs/" data-id="cjymaa6z50005lguwjsbegsy7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十六天——继续做Bolo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/快乐暑假第十六天——继续做Bolo/" class="article-date">
  <time datetime="2019-07-25T13:15:05.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/快乐暑假第十六天——继续做Bolo/">快乐暑假第十六天——继续做Bolo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>小明早上踩到了一个深坑，不同手机不同系统的默认样式是有差别的，甚至有可能出现各种各样奇怪的效果。</p>
</blockquote>
<ul>
<li>因此最好不用input等本身具备样式的元素，而是改用div，然后再对其设置需要的功能(如点击事件等)。</li>
<li>可输入的框即使设置为不可修改，但是可能仍然会出新光标。这一点等之后遇到了再详细研究。</li>
</ul>
<blockquote>
<p>在百度移动端触摸事件时看到了一个tap事件，于时百度了一下二者的区别</p>
</blockquote>
<ul>
<li>tap和click的区别：两者都会在点击时触发，但是在web手机端，clikc会有200-300ms的延时，所以要用tap代替click作为点击事件，singleTap和doubleTap分别作为单次点击和双击，但是使用tap会带来点透事件(事件穿透)。</li>
<li>tap事件穿透：执行完上层绑定的tap事件后，下层如果绑定这click事件或者本身就存在点击事件（a/input）也会默认触发，这就是tap点透事件</li>
<li>tap点透事件发生的场景：当A/B两个层上下Z轴叠层，上层的A点击后消失或者移开，当B元素本身默认有click事件或者绑定click事件，这种情况下，点击A/B重叠的部分，就会出现点透事件</li>
</ul>
<blockquote>
<p>用document.getElementById获取到的元素和用jq(‘#id’)获取到的元素有区别</p>
</blockquote>
<ul>
<li>dom方法只能操作用dom操作获取到的元素，同理，jq方法也只能由于jq获取的元素</li>
</ul>
<blockquote>
<p>在ios系统上点击具有点击事件的元素时，会出现一个黑色的背景一闪而过，应该是系统默认的回馈效果，百度之后有了解决方案：</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</span><br><span class="line">    <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>但是如果点击到了没有任何元素的区域————比如body之外————仍然会出现这个东西。此时可以给body设一个最小高度100vh。</li>
</ul>
<blockquote>
<p>不同的用户手机浏览器的默认背景颜色可能会有差异，最好给body设置一个白色的背景颜色。</p>
</blockquote>
<blockquote>
<p>让超过一行的文字自动省略</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.object_content</span> &#123;</span><br><span class="line">    width: 61vw;                // 设置固定的宽度</span><br><span class="line">    overflow: hidden;           // 溢出内容隐藏</span><br><span class="line">    white-space: nowrap;        // 不换行</span><br><span class="line">    text-overflow: ellipsis;    // 超出文字省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/快乐暑假第十六天——继续做Bolo/" data-id="cjymaa6z80007lguwicjcoq6b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十五天——开始做Bolo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/快乐暑假第十五天——开始做Bolo/" class="article-date">
  <time datetime="2019-07-24T13:56:53.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/快乐暑假第十五天——开始做Bolo/">快乐暑假第十五天——开始做Bolo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天正式开始做Bolo，但是直到刚才我才发现我做了别人的任务。。。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
好的问题不大。今天做的东西比较常规，都是静态页面，没有遇到什么坑。只不过今天用的单位是vw，目前还只能用计算器一个一个手动转换。。。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
由于vh在弹出键盘、横屏等操作时变化较大，故不适合以vh为单位。另外，用rem来规定字体大小的一大好处是可以通过改变页面默认字体大小来改变所有字体的相对大小。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
刚刚操作失误，差点把自己一天的代码全部删了，好恐怖啊。。。。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>
今日无笔记

<p><img src="C:/Users/11691/Desktop/111.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/快乐暑假第十五天——开始做Bolo/" data-id="cjymaa6z60006lguwbqvjnjeh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十四天——学习jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/快乐暑假第十四天——学习jQuery/" class="article-date">
  <time datetime="2019-07-23T13:33:36.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/快乐暑假第十四天——学习jQuery/">快乐暑假第十四天——学习jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>基础语法： $(selector).action( )</p>
<ul>
<li>美元符号定义 jQuery</li>
<li>选择符（selector）”查询”和”查找” HTML 元素</li>
<li>jQuery 的 action() 执行对元素的操作</li>
</ul>
<h2 id="文档就绪事件"><a href="#文档就绪事件" class="headerlink" title="文档就绪事件"></a>文档就绪事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用简略形式</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>防止文档在完全加载（就绪）之前运行 jQuery 代码。</li>
</ul>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>基于已经存在的 CSS 选择器，除此之外，它还有一些自定义的选择器。</p>
<p>jQuery 中所有选择器都以美元符号开头：$()，与css选择器相似：</p>
<ul>
<li>元素选择器</li>
<li>#id 选择器</li>
<li>.class 选择器</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="jQuery-事件方法语法"><a href="#jQuery-事件方法语法" class="headerlink" title="jQuery 事件方法语法"></a>jQuery 事件方法语法</h2><p>以点击事件为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 动作触发后执行的代码!!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="2-效果"><a href="#2-效果" class="headerlink" title="2. 效果"></a>2. 效果</h1><h2 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(selector).hide(speed,callback);       //隐藏</span><br><span class="line">$(selector).show(speed,callback);       //显示</span><br><span class="line">$(selector).toggle(speed,callback);     //在 hide() 与 show() 之间进行切换</span><br></pre></td></tr></table></figure>

<ul>
<li>可选的 speed 参数规定隐藏/显示的速度，可以取以下值：”slow”、”fast” 或毫秒。</li>
<li>可选的 callback 参数是隐藏或显示完成后所执行的函数名称。</li>
</ul>
<h2 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(selector).fadeIn(speed,callback);     //用于淡入已隐藏的元素</span><br><span class="line">$(selector).fadeOut(speed,callback);    //用于淡出可见元素</span><br><span class="line">$(selector).fadeToggle(speed,callback); //在 fadeIn() 与 fadeOut() 之间进行切换</span><br><span class="line">$(selector).fadeTo(speed,opacity,callback); //渐变为给定的不透明度（值介于 0 与 1 之间）</span><br></pre></td></tr></table></figure>

<h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(selector).slideDown(speed,callback);      //向下滑动元素</span><br><span class="line">$(selector).slideUp(speed,callback);        //向上滑动元素</span><br><span class="line">$(selector).slideToggle(speed,callback);    //在 slideDown() 与 slideUp() 方法之间进行切换</span><br></pre></td></tr></table></figure>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).animate(&#123;params&#125;,speed,callback);       //创建自定义动画</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>必需的 params 参数</strong>定义形成动画的 CSS 属性</li>
<li>生成动画的过程中<strong>可同时使用多个属性</strong></li>
<li><strong>可以定义相对值</strong>（该值相对于元素的当前值），需要在值的前面加上 += 或 -=</li>
<li>可以把属性的动画值设置为 “show”、”hide” 或 “toggle”</li>
<li>jQuery <strong>提供针对动画的队列功能</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).stop(stopAll,goToEnd);      //用于停止动画或效果，在它们完成之前</span><br></pre></td></tr></table></figure>

<ul>
<li>适用于所有 jQuery 效果函数，包括滑动、淡入淡出和自定义动画</li>
<li>可选的 stopAll 参数规定是否应该清除动画队列。<ul>
<li>默认是 false，即仅停止活动的动画，允许任何排入队列的动画向后执行。</li>
</ul>
</li>
<li>可选的 goToEnd 参数规定是否立即完成当前动画。<ul>
<li>默认是 false。</li>
</ul>
</li>
</ul>
<p>因此，默认地，stop() 会清除在被选元素上指定的当前动画。</p>
<h2 id="Callback-方法"><a href="#Callback-方法" class="headerlink" title="Callback 方法"></a>Callback 方法</h2><p>Callback 函数在当前动画 100% 完成之后执行。</p>
<p>如果没有回调函数，动画后面的语句可能会在动画完成前执行。</p>
<h2 id="链-Chaining"><a href="#链-Chaining" class="headerlink" title="链(Chaining)"></a>链(Chaining)</h2><p>可以在一条语句中运行多个 jQuery 方法（在相同的元素上）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#p1"</span>).css(<span class="string">"color"</span>,<span class="string">"red"</span>)</span><br><span class="line">  .slideUp(<span class="number">2000</span>)</span><br><span class="line">  .slideDown(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-HTML"><a href="#3-HTML" class="headerlink" title="3. HTML"></a>3. HTML</h1><h2 id="操作-DOM"><a href="#操作-DOM" class="headerlink" title="操作 DOM"></a>操作 DOM</h2><h3 id="获得、设置内容"><a href="#获得、设置内容" class="headerlink" title="获得、设置内容"></a>获得、设置内容</h3><ul>
<li>text() - 设置或返回所选元素的文本内容</li>
<li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li>
<li>val() - 设置或返回表单字段的值</li>
</ul>
<p>拥有回调函数，以函数新值返回字符串。回调函数有两个参数：</p>
<ol>
<li>被选元素列表中当前元素的下标</li>
<li>原始（旧的）值。</li>
</ol>
<h3 id="获取、设置属性"><a href="#获取、设置属性" class="headerlink" title="获取、设置属性"></a>获取、设置属性</h3><p>jQuery <strong>attr() 方法</strong>用于获取属性值，也可以设置/改变属性值。</p>
<ul>
<li>同时设置多个属性</li>
<li>提供回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回字符串。</li>
</ul>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>append() - 在被选元素的结尾插入内容（仍然该元素的内部）</li>
<li>prepend() - 在被选元素的开头插入内容</li>
<li>after() - 在被选元素之后插入内容（在该元素外部）</li>
<li>before() - 在被选元素之前插入内容</li>
</ul>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>remove() - 删除被选元素（及其子元素）</li>
<li>empty() - 从被选元素中删除子元素</li>
</ul>
<p>remove() 方法也可接受一个参数，可以对被删元素进行过滤。</p>
<p>删除 class=”italic” 的所有 &lt;p&gt; 元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).remove(<span class="string">".italic"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取并设置-CSS-类"><a href="#获取并设置-CSS-类" class="headerlink" title="获取并设置 CSS 类"></a>获取并设置 CSS 类</h2><h3 id="操作-CSS"><a href="#操作-CSS" class="headerlink" title="操作 CSS"></a>操作 CSS</h3><ul>
<li>addClass() - 向被选元素添加一个或多个类</li>
<li>removeClass() - 从被选元素删除一个或多个类</li>
<li>toggleClass() - 对被选元素进行添加/删除类的切换操作</li>
<li>css() - 设置或返回样式属性</li>
</ul>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><h2 id="尺寸方法"><a href="#尺寸方法" class="headerlink" title="尺寸方法"></a>尺寸方法</h2><ul>
<li>width() - 设置或返回元素的宽度（不包括内边距、边框或外边距）</li>
<li>height() - 设置或返回元素的高度（不包括内边距、边框或外边距）</li>
<li>innerWidth() - 返回元素的宽度（包括内边距）</li>
<li>innerHeight() - 返回元素的高度（包括内边距）</li>
<li>outerWidth() - 返回元素的宽度（包括内边距和边框）</li>
<li>outerHeight() - 返回元素的高度（包括内边距和边框）</li>
</ul>
<h1 id="4-遍历"><a href="#4-遍历" class="headerlink" title="4. 遍历"></a>4. 遍历</h1><h2 id="向上遍历-DOM-树"><a href="#向上遍历-DOM-树" class="headerlink" title="向上遍历 DOM 树"></a>向上遍历 DOM 树</h2><ul>
<li>parent() - 返回被选元素的直接父元素</li>
<li>parents() - 返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (&lt;html&gt;)</li>
<li>parentsUntil() - 返回介于两个给定元素之间的所有祖先元素</li>
</ul>
<h2 id="向下遍历-DOM-树"><a href="#向下遍历-DOM-树" class="headerlink" title="向下遍历 DOM 树"></a>向下遍历 DOM 树</h2><ul>
<li>children() - 返回被选元素的所有直接子元素，也可以使用可选参数来过滤对子元素的搜索</li>
<li>find() - 返回被选元素的后代元素，一路向下直到最后一个后代</li>
</ul>
<h2 id="在-DOM-树中水平遍历"><a href="#在-DOM-树中水平遍历" class="headerlink" title="在 DOM 树中水平遍历"></a>在 DOM 树中水平遍历</h2><ul>
<li>siblings() - 返回被选元素的所有同胞元素，可以使用可选参数来过滤对同胞元素的搜索</li>
</ul>
<p>向后遍历：</p>
<ul>
<li>next() - 返回被选元素的下一个同胞元素</li>
<li>nextAll() - 返回被选元素的所有跟随的同胞元素</li>
<li>nextUntil() - 返回介于两个给定参数之间的所有跟随的同胞元素</li>
</ul>
<p>向前遍历：</p>
<ul>
<li>prev()</li>
<li>prevAll()</li>
<li>prevUntil()</li>
</ul>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul>
<li>first() - 返回被选元素的首个元素</li>
<li>last() - 返回被选元素的最后一个元素</li>
<li>eq() - 返回被选元素中带有指定索引号的元素（索引号从 0 开始）</li>
<li>filter() - 可以规定一个标准，不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回</li>
<li>not() - 返回不匹配标准的所有元素（与 filter() 相反）</li>
</ul>
<h1 id="5-Ajax"><a href="#5-Ajax" class="headerlink" title="5. Ajax"></a>5. Ajax</h1><h2 id="AJAX-load-方法"><a href="#AJAX-load-方法" class="headerlink" title="AJAX load() 方法"></a>AJAX load() 方法</h2><p>load() 方法从服务器加载数据，并把返回的数据放入被选元素中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(selector).load(URL,data,callback);</span><br></pre></td></tr></table></figure>

<ul>
<li>必需的 URL 参数规定您希望加载的 URL。<ul>
<li>可以把 jQuery 选择器添加到进此参数</li>
</ul>
</li>
<li>可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。</li>
<li>可选的 callback 参数是 load() 方法完成后所执行的函数名称。<ul>
<li>回调函数可以设置不同的参数：<ul>
<li>responseTxt - 包含调用成功时的结果内容</li>
<li>statusTXT - 包含调用的状态</li>
<li>xhr - 包含 XMLHttpRequest 对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AJAX-get-和-post-方法"><a href="#AJAX-get-和-post-方法" class="headerlink" title="AJAX get() 和 post() 方法"></a>AJAX get() 和 post() 方法</h2><p>$.get() 方法通过 HTTP GET 请求从服务器上请求数据<br>$.post() 方法通过 HTTP POST 请求向服务器提交数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/快乐暑假第十四天——学习jQuery/" data-id="cjymaa6z90008lguw6pv1ixnn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十三天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/快乐暑假第十三天/" class="article-date">
  <time datetime="2019-07-22T12:21:09.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/快乐暑假第十三天/">快乐暑假第十三天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
今晚还看了一些jq，明天再大概看一下。设计差不多要出稿了，准备开始实践了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="9-async-函数"><a href="#9-async-函数" class="headerlink" title="9. async 函数"></a>9. async 函数</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>
<h2 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9.1 语法"></a>9.1 语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p>async函数返回一个 Promise 对象。</p>
<ul>
<li>内部return语句返回的值，会<strong>成为then方法回调函数的参数</strong>。</li>
<li>async函数内部抛出错误，会导致返回的 Promise 对象<strong>变为reject状态</strong>。抛出的错误对象<strong>会被catch方法回调函数接收到</strong>。</li>
</ul>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async函数返回的 Promise 对象，必须<strong>等到内部所有await命令后面的 Promise 对象执行完</strong>，才会发生状态改变，然后执行then方法指定的回调函数，除非<strong>遇到return语句</strong>或者<strong>抛出错误</strong>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<strong>await命令后面是一个 Promise 对象</strong>，返回该对象的结果。如果不是 Promise 对象，就<strong>直接返回对应的值</strong>。如果后面是一个thenable对象（即定义then方法的对象），那么await会<strong>将其等同于 Promise 对象</strong>。</p>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<ul>
<li>任何一个await语句后面的 Promise 对象变为reject状态，整个async函数都会中断执行。</li>
<li>如果不想中断后面语句的执行，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>
<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<ul>
<li>防止出错的方法，也是将其放在try…catch代码块之中。</li>
<li>如果有多个await命令，可以统一放在try…catch结构中。</li>
</ul>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个操作互相独立，这样做比较耗时</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>

<ul>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li>async 函数可以保留运行堆栈。</li>
</ul>
<h1 id="10-Class-的基本语法"><a href="#10-Class-的基本语法" class="headerlink" title="10. Class 的基本语法"></a>10. Class 的基本语法</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。<strong>Object.assign方法</strong>可以很方便地一次向类添加多个方法。</p>
<p><strong>类的内部所有定义的方法，都是不可枚举的</strong>。这一点与 ES5 的行为不一致。</p>
<p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。<strong>一个类必须有constructor方法</strong>，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<ul>
<li>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象(但会导致实例对象改变)。</li>
</ul>
<p>类必须使用new调用，否则会报错。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<ul>
<li>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</li>
</ul>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Square类的方法名getArea，是从表达式得到的。</li>
</ul>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，<strong>这个类只能用MyClass引用</strong>。</li>
<li>如果类的内部没用到的话，可以省略Me。</li>
</ul>
<p>采用 Class 表达式，可以写出<strong>立即执行的 Class</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用use strict指定运行模式。</li>
<li><strong>类不存在变量提升</strong>（hoist），这一点与 ES5 完全不同。</li>
<li>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</li>
<li>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ol>
<h2 id="10-2-静态方法"><a href="#10-2-静态方法" class="headerlink" title="10.2 静态方法"></a>10.2 静态方法</h2><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果在一个方法前，<strong>加上static关键字，就表示该方法不会被实例继承</strong>，而是直接通过类来调用，这就称为“静态方法”。</p>
<ul>
<li>如果静态方法包含this关键字，这个this指的是类，而不是实例。</li>
<li>静态方法可以与非静态方法重名。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>静态方法也是可以从super对象上调用的。</li>
</ul>
<h2 id="10-3-实例属性的新写法"><a href="#10-3-实例属性的新写法" class="headerlink" title="10.3 实例属性的新写法"></a>10.3 实例属性的新写法</h2><p>实例属性除了定义在constructor()方法里面的this上面，也可以<strong>定义在类的最顶层</strong>。</p>
<h2 id="10-4-静态属性"><a href="#10-4-静态属性" class="headerlink" title="10.4 静态属性"></a>10.4 静态属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</li>
</ul>
<h1 id="11-Class-的继承"><a href="#11-Class-的继承" class="headerlink" title="11. Class 的继承"></a>11. Class 的继承</h1><p>Class 可以通过extends关键字实现继承。</p>
<ul>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</li>
<li>如果子类没有定义constructor方法，这个方法会被默认添加。因此不管有没有显式定义，任何一个子类都有constructor方法。</li>
<li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</li>
<li>父类的静态方法，也会被子类继承。</li>
</ul>
<h2 id="11-1-Object-getPrototypeOf"><a href="#11-1-Object-getPrototypeOf" class="headerlink" title="11.1 Object.getPrototypeOf( )"></a>11.1 Object.getPrototypeOf( )</h2><p>Object.getPrototypeOf方法可以用来从子类上获取父类。<br>因此可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="11-2-super-关键字"><a href="#11-2-super-关键字" class="headerlink" title="11.2 super 关键字"></a>11.2 super 关键字</h2><p>super作为函数调用时，代表父类的构造函数。<strong>作为函数时，super()只能用在子类的构造函数之中</strong>，用在其他地方就会报错。</p>
<p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h1 id="12-Module-的语法"><a href="#12-Module-的语法" class="headerlink" title="12. Module 的语法"></a>12. Module 的语法</h1><p>ES6 的模块自动采用严格模式。</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</p>
<p>模块功能主要由两个命令构成：export和import：</p>
<ul>
<li><strong>export命令用于规定模块的对外接口</strong>。</li>
<li><strong>import命令用于输入其他模块提供的功能</strong>。</li>
</ul>
<h2 id="12-1-export-命令"><a href="#12-1-export-命令" class="headerlink" title="12.1 export 命令"></a>12.1 export 命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果要<strong>让外部能够读取模块内部的某个变量</strong>，就必须使用export关键字输出该变量。</p>
<ul>
<li>export命令除了输出变量，还可以输出函数或类。</li>
<li>通常情况下，export输出的变量就是本来的名字，但是可以<strong>使用as关键字重命名</strong>。</li>
<li>export语句输出的接口，与其对应的值是<strong>动态绑定关系</strong>，即通过该接口，可以取到模块内部实时的值。</li>
<li>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。</li>
</ul>
<h2 id="12-2-import-命令"><a href="#12-2-import-命令" class="headerlink" title="12.2 import 命令"></a>12.2 import 命令</h2><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以<strong>通过import命令加载这个模块</strong>。</p>
<ul>
<li>使用as关键字，将输入的变量重命名。</li>
<li>import命令输入的变量都是<strong>只读</strong>的，因为它的本质是输入接口。</li>
<li>import命令<strong>具有提升效果</strong>，会提升到整个模块的头部，首先执行。(import命令是编译阶段执行的，在代码运行之前)</li>
<li>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li>
</ul>
<h2 id="12-3模块的整体加载"><a href="#12-3模块的整体加载" class="headerlink" title="12.3模块的整体加载"></a>12.3模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即<strong>用星号（*）指定一个对象，所有输出值都加载在这个对象上面</strong>。</p>
<ul>
<li>模块整体加载所在的那个对象，应该是<strong>可以静态分析</strong>的，所以<strong>不允许运行时改变</strong>。</li>
</ul>
<h2 id="12-4-export-default-命令"><a href="#12-4-export-default-命令" class="headerlink" title="12.4 export default 命令"></a>12.4 export default 命令</h2><p>export default命令能为模块指定默认输出。</p>
<ul>
<li>这时import命令后面，不使用大括号。</li>
<li>export default命令也可以用在非匿名函数前。</li>
<li>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</li>
<li>因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</li>
</ul>
<h2 id="12-5-export-与-import-的复合写法"><a href="#12-5-export-与-import-的复合写法" class="headerlink" title="12.5 export 与 import 的复合写法"></a>12.5 export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>foo和bar实际上并没有被导入当前模块</li>
</ul>
<h1 id="13-Module-的加载实现"><a href="#13-Module-的加载实现" class="headerlink" title="13. Module 的加载实现"></a>13. Module 的加载实现</h1><h2 id="13-1-浏览器加载"><a href="#13-1-浏览器加载" class="headerlink" title="13.1 浏览器加载"></a>13.1 浏览器加载</h2><p>浏览器允许脚本异步加载，有两种异步加载的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是“渲染完再执行”，async是“下载完就执行”。</li>
<li>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</li>
</ul>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入<strong>type=”module”属性</strong>。</p>
<ul>
<li>浏览器对于带有 type=”module” 的&lt;script&gt;，都是异步加载，<strong>等同于打开了&lt;script&gt;标签的defer属性</strong>。（会按照出现顺序执行）</li>
<li>async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。（此时<strong>不会按照在页面出现的顺序执行</strong>，而是只要该模块加载完成，就执行该模块）</li>
</ul>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。对于外部的模块脚本（上例是foo.js），有几点需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式。</li>
<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li>
<li>在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/快乐暑假第十三天/" data-id="cjymaa6zl000elguwfpegrre0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十二天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/快乐暑假第十二天/" class="article-date">
  <time datetime="2019-07-21T13:33:40.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/21/快乐暑假第十二天/">快乐暑假第十二天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p><strong>Set函数接受数组作为参数</strong>是一种去除数组重复成员的方法。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>
<p><strong>Array.from方法可以将 Set 结构转为数组</strong>，是去除数组重复成员的另一种方法。</p>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员：</p>
<ul>
<li><strong>Set.prototype.keys( )</strong>：返回键名的遍历器</li>
<li><strong>Set.prototype.values( )</strong>：返回键值的遍历器</li>
<li><strong>Set.prototype.entries( )</strong>：返回键值对的遍历器</li>
<li><strong>Set.prototype.forEach( )</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>Set的遍历顺序就是插入顺序。</strong></p>
<h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<strong>keys方法和values方法的行为完全一致</strong>。entries方法返回的遍历器，同时包括键名和键值。</p>
<p>可以省略values方法，直接用for…of循环遍历 Set。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>用于对每个成员执行某种操作，没有返回值。</p>
<p><strong>forEach方法的参数就是一个处理函数</strong>。</p>
<h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>数组的map和filter方法也可以间接用于 Set ，因此<strong>使用 Set 可以很容易地实现并集、交集和差集</strong>。</p>
<h2 id="7-2-WeakSet"><a href="#7-2-WeakSet" class="headerlink" title="7.2 WeakSet"></a>7.2 WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的<strong>成员只能是对象</strong>。</p>
<p>WeakSet 中的对象都是<strong>弱引用</strong>，如果其他对象都不再引用某一对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。因此 <strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。</p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数(数组的成员只能是对象)，该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<p>WeakSet 结构有以下三个方法：</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet 没有size属性，<strong>没有办法遍历它的成员</strong>(由于弱引用特性，不支持遍历)。</p>
<h2 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h2><p>Map 数据结构类似于对象，是<strong>键值对的集合</strong>，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作键</strong>。</p>
<p>作为构造函数，Map 也可以<strong>接受一个数组作为参数</strong>。该数组的成员是一个个表示键值对的数组。</p>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法：</p>
<ul>
<li><strong>size 属性</strong>：返回 Map 结构的成员总数。</li>
<li><strong>Map.prototype.set(key, value)</strong>：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><strong>Map.prototype.get(key)</strong>：读取key对应的键值，如果找不到key，返回undefined。</li>
<li><strong>Map.prototype.has(key)</strong>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><strong>Map.prototype.delete(key)</strong>：删除某个键，返回true。如果删除失败，返回false。</li>
<li><strong>Map.prototype.clear()</strong>：清除所有成员，没有返回值。</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li><strong>Map.prototype.keys()</strong>：返回键名的遍历器。</li>
<li><strong>Map.prototype.values()</strong>：返回键值的遍历器。</li>
<li><strong>Map.prototype.entries()</strong>：返回所有成员的遍历器。</li>
<li><strong>Map.prototype.forEach()</strong>：遍历 Map 的所有成员。</li>
</ul>
<p><strong>Map 的遍历顺序就是插入顺序。</strong></p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul>
<li>数组与Map的相互转换</li>
<li>对象与Map的相互转换</li>
<li>JSON与Map的相互转换</li>
</ul>
<h2 id="7-4-WeakMap"><a href="#7-4-WeakMap" class="headerlink" title="7.4 WeakMap"></a>7.4 WeakMap</h2><h1 id="8-Promise-对象"><a href="#8-Promise-对象" class="headerlink" title="8. Promise 对象"></a>8. Promise 对象</h1><h2 id="8-1-Promise-的含义"><a href="#8-1-Promise-的含义" class="headerlink" title="8.1 Promise 的含义"></a>8.1 Promise 的含义</h2><p>Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>Promise对象有以下两个特点：</p>
<ul>
<li><strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。(这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的)</li>
</ul>
<h2 id="8-2-基本用法"><a href="#8-2-基本用法" class="headerlink" title="8.2 基本用法"></a>8.2 基本用法</h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，<strong>不用自己部署</strong>。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并<strong>将异步操作的结果，作为参数传递出去</strong>。</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<p>如果<strong>调用resolve函数和reject函数时带有参数</strong>，那么它们的参数会被<strong>传递给回调函数</strong>。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<ul>
<li>then方法可以接受两个回调函数作为参数：第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用(可选)。</li>
<li>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</li>
</ul>
<h2 id="8-3-Promise-prototype-then"><a href="#8-3-Promise-prototype-then" class="headerlink" title="8.3 Promise.prototype.then( )"></a>8.3 Promise.prototype.then( )</h2><p>then方法<strong>返回的是一个新的Promise实例</strong>，因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h2 id="8-4-Promise-prototype-catch"><a href="#8-4-Promise-prototype-catch" class="headerlink" title="8.4 Promise.prototype.catch( )"></a>8.4 Promise.prototype.catch( )</h2><p>是.then(null, rejection)或.then(undefined, rejection)的别名，<strong>用于指定发生错误时的回调函数</strong>。</p>
<p>Promise 对象的错误<strong>具有“冒泡”性质</strong>，会一直向后传递，直到被捕获为止。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），<strong>总是使用catch方法</strong>。catch方法返回的还是一个 Promise 对象，因此<strong>后面还可以接着调用then方法</strong>。</p>
<ul>
<li>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即<strong>不会有任何反应</strong>。</li>
</ul>
<h2 id="8-5-Promise-prototype-finally"><a href="#8-5-Promise-prototype-finally" class="headerlink" title="8.5 Promise.prototype.finally( )"></a>8.5 Promise.prototype.finally( )</h2><p>用于<strong>指定不管 Promise 对象最后状态如何，都会执行的操作</strong>。</p>
<ul>
<li>finally方法的回调函数<strong>不接受任何参数</strong>，故无法知道前面的 Promise 状态到底是fulfilled还是rejected。因此finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
<li>finally本质上是then方法的特例。</li>
<li>finally方法总是会返回原来的值。</li>
</ul>
<h2 id="8-6-Promise-all"><a href="#8-6-Promise-all" class="headerlink" title="8.6 Promise.all( )"></a>8.6 Promise.all( )</h2><p>Promise.all方法用于<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>接受一个数组作为参数，p1、p2、p3都是 Promise 实例。(如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理)</li>
<li>p的状态由p1、p2、p3决定：<ul>
<li>只有p1、p2、p3的状态<strong>都变成fulfilled</strong>，p的状态才会变成fulfilled，此时p1、p2、p3的<strong>返回值组成一个数组，传递给p的回调函数</strong>。</li>
<li>只要p1、p2、p3之中<strong>有一个被rejected</strong>，p的状态就变成rejected，此时<strong>第一个被reject的实例的返回值，会传递给p的回调函数</strong>。</li>
</ul>
</li>
<li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</li>
</ul>
<h2 id="8-7-Promise-race"><a href="#8-7-Promise-race" class="headerlink" title="8.7 Promise.race( )"></a>8.7 Promise.race( )</h2><p>Promise.race方法同样是<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要p1、p2、p3之中<strong>有一个实例率先改变状态，p的状态就跟着改变</strong>。那个<strong>率先改变的 Promise 实例的返回值，就传递给p的回调函数</strong>。</li>
<li>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</li>
</ul>
<h2 id="8-8-Promise-resolve"><a href="#8-8-Promise-resolve" class="headerlink" title="8.8 Promise.resolve( )"></a>8.8 Promise.resolve( )</h2><p>Promise.resolve方法能够<strong>将现有对象转为 Promise 对象</strong>。</p>
<p>Promise.resolve方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<strong>Promise 实例</strong>：不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个<strong>thenable对象</strong>：(thenable对象指的是具有then方法的对象)会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</li>
<li>参数<strong>不是具有then方法的对象，或不是对象</strong>:返回一个新的 Promise 对象，状态为resolved。（Promise.resolve方法的参数，会同时传给回调函数，回调函数会立即执行）</li>
<li><strong>不带有任何参数</strong>：直接返回一个resolved状态的 Promise 对象。<ul>
<li>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li>
</ul>
</li>
</ul>
<h2 id="8-9-Promise-reject"><a href="#8-9-Promise-reject" class="headerlink" title="8.9 Promise.reject( )"></a>8.9 Promise.reject( )</h2><p>Promise.reject(reason)方法也会<strong>返回一个状态为rejected的新的 Promise 实例</strong>。</p>
<ul>
<li>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</li>
</ul>
<h1 id="9-Generator-函数的语法"><a href="#9-Generator-函数的语法" class="headerlink" title="9. Generator 函数的语法"></a>9. Generator 函数的语法</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/快乐暑假第十二天/" data-id="cjymaa6zn000flguwiifm5ait" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十一天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/快乐暑假第十一天/" class="article-date">
  <time datetime="2019-07-19T14:02:19.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/快乐暑假第十一天/">快乐暑假第十一天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中<ul>
<li>如果不需要换行，可以使用trim方法消除它</li>
</ul>
</li>
<li>模板字符串中嵌入变量，需要将变量名写在${}之中<ul>
<li>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</li>
<li>还能调用函数，如果大括号中的值不是字符串，将按照一般的规则转为字符串</li>
<li>如果模板字符串中的变量没有声明，将报错</li>
<li>实际上模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出</li>
</ul>
</li>
<li>模板字符串还能嵌套</li>
<li>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</li>
</ul>
<h1 id="4-函数的扩展"><a href="#4-函数的扩展" class="headerlink" title="4. 函数的扩展"></a>4. 函数的扩展</h1><h2 id="4-1-箭头函数"><a href="#4-1-箭头函数" class="headerlink" title="4.1 箭头函数"></a>4.1 箭头函数</h2><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果箭头函数不需要参数或需要多个参数，就使用一个<strong>圆括号代表参数部分</strong></li>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且<strong>使用return语句返回</strong></li>
<li>由于大括号被解释为代码块，所以如果箭头函数直接<strong>返回一个对象，必须在对象外面加上括号</strong>，否则会报错</li>
<li>箭头函数可以与变量解构结合使用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数的一个用处是简化回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ol>
<li>函数体内的<strong>this对象，就是定义时所在的对象</strong>，而不是使用时所在的对象。</li>
<li><strong>不可以当作构造函数</strong>，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li><strong>不可以使用arguments对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li><strong>不可以使用yield命令</strong>，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</li>
</ul>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this，导致内部的this就是外层代码块的this</strong>。正是因为它没有this，所以也就<strong>不能用作构造函数</strong>。</p>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数：</p>
<ol>
<li>定义对象的方法，且该方法内部包括this</li>
<li>需要动态this的时候，也不应使用箭头函数</li>
</ol>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个函数，可以使用箭头函数改写。</span></span><br><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="function">(<span class="params">&#123;into: (array</span>) =&gt;</span> <span class="function">(<span class="params">&#123;after: (afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-rest-参数"><a href="#4-2-rest-参数" class="headerlink" title="4.2 rest 参数"></a>4.2 rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。</p>
<ul>
<li>rest 参数搭配的变量是一个数组，该变量<strong>将多余的参数放入数组中</strong>。</li>
<li>arguments对象不是数组，而是一个类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。<strong>rest 参数是一个真正的数组，数组特有的方法都可以使用</strong>。</li>
<li>rest 参数之后不能再有其他参数（即<strong>只能是最后一个参数</strong>），否则会报错。</li>
<li><strong>函数的length属性，不包括 rest 参数</strong>。</li>
</ul>
<h2 id="4-3-数组实例的-includes"><a href="#4-3-数组实例的-includes" class="headerlink" title="4.3 数组实例的 includes( )"></a>4.3 数组实例的 includes( )</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
<h1 id="5-数组的扩展"><a href="#5-数组的扩展" class="headerlink" title="5. 数组的扩展"></a>5. 数组的扩展</h1><h2 id="5-1-扩展运算符"><a href="#5-1-扩展运算符" class="headerlink" title="5.1 扩展运算符"></a>5.1 扩展运算符</h2><p>扩展运算符是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<ul>
<li>扩展运算符与正常的函数参数可以结合使用</li>
<li>扩展运算符后面还可以放置表达式</li>
<li>如果扩展运算符后面是一个空数组，则不产生任何效果</li>
<li>只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错</li>
</ul>
<h1 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型。</p>
<ul>
<li>Symbol函数前不能使用new命令，因为生成的 Symbol 是一个原始类型的值，不是对象。它是一种类似于字符串的数据类型。</li>
<li>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。<ul>
<li>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</li>
<li>相同参数的Symbol函数的返回值是不相等的。</li>
</ul>
</li>
<li>Symbol 值不能与其他类型的值进行运算。</li>
<li>Symbol 值可以显式转为字符串。</li>
<li>Symbol 值也可以转为布尔值，但是不能转为数值。</li>
</ul>
<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/快乐暑假第十一天/" data-id="cjymaa6zk000dlguwy7worlq3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第十天——学习ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/快乐暑假第十天——学习ES6/" class="article-date">
  <time datetime="2019-07-18T13:04:59.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/快乐暑假第十天——学习ES6/">快乐暑假第十天——学习ES6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，并且二者相互独立，不会互相影响。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h1><h2 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了let命令，用来声明变量。用法类似于var，但是<strong>所声明的变量，只在let命令所在的代码块内有效。</strong></p>
<ul>
<li><p>for循环的计数器，就很合适使用let命令。在for循环内定义的计数器变量不会影响到外部变量。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量(JavaScript 引擎内部会记住上一轮循环的值)。</li>
<li>for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
</ul>
</li>
</ul>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>let声明的变量一定要在<strong>声明后使用</strong>，否则报错。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内<strong>存在let命令</strong>，它所声明的变量就“绑定”（binding）这个区域，<strong>不受外部的影响</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就<strong>形成了封闭作用域</strong>。凡是在声明之前就使用这些变量，就会报错。</li>
<li>语法上，称为“暂时性死区”。</li>
</ul>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作：</p>
<ul>
<li>如果在用let声明的变量之前对其使用typeOf，则会报错</li>
<li>如果一个变量根本没有被声明，使用typeof反而不会报错(在没有let之前，typeof运算符是百分之百安全的)</li>
</ul>
<p>有些“死区”比较隐蔽，不太容易发现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = x;  <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;  <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在变量x的声明语句还没有执行完成前，就去取x的值，导致报错“x 未定义”</li>
</ul>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。因此<strong>不能在函数内部重新声明参数</strong>。</p>
<h2 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景：</p>
<ul>
<li>内层变量可能会覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>let实际上为 JavaScript 新增了块级作用域，外层代码块不受内层代码块的影响。</p>
<p>块级作用域必须有<strong>大括号</strong>。</p>
<p>块级作用域的出现，使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<p>块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<p>考虑到环境导致的行为差异太大，应该<strong>避免在块级作用域内声明函数</strong>。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明一个<strong>只读</strong>的常量，一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须<strong>立即初始化</strong>，不能留到以后赋值。</p>
<p>与let特性相似：</p>
<ul>
<li>只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
</ul>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
<ul>
<li><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
</li>
<li><p>对于复合类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const<strong>只能保证这个指针是固定的</strong>（即总是指向另一个固定的地址），至于它<strong>指向的数据结构是不是可变的，就完全不能控制了</strong>。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错，不能改变指针的指向</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果真的想将对象冻结，应该使用Object.freeze方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>;     <span class="comment">// 常规模式时不起作用；严格模式时会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>var命令和function命令、let命令和const命令、import命令和class命令。</p>
<h2 id="1-4-顶层对象的属性"><a href="#1-4-顶层对象的属性" class="headerlink" title="1.4 顶层对象的属性"></a>1.4 顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的，这带来了各种各样的问题。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<strong>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</strong>。</p>
<h2 id="1-5-globalThis-对象"><a href="#1-5-globalThis-对象" class="headerlink" title="1.5 globalThis 对象"></a>1.5 globalThis 对象</h2><p>在有一个提案，在语言标准的层面，<strong>引入globalThis作为顶层对象</strong>。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p>
<p>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</p>
<h1 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h1><h2 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中<strong>提取值</strong>，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</li>
<li>本质上，这种写法属于 <strong>“模式匹配”</strong> ，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</li>
</ul>
<p>如果<strong>解构不成功</strong>，变量的值就等于undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>以上两种情况都属于解构不成功，foo的值都会等于undefined。</li>
</ul>
<p>另一种情况是<strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个例子，都属于不完全解构，但是可以成功。</li>
</ul>
<p>如果等号的右边不是数组（严格地说，不是可遍历的结构），那么将会报错。</p>
<p>事实上，只要某种数据结构<strong>具有 Iterator 接口</strong>，都可以采用数组形式的解构赋值。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值<strong>允许指定默认值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>

<p>ES6 内部<strong>使用严格相等运算符（===）</strong>，判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>因为x能取到值，所以函数f根本不会执行。</li>
</ul>
<p>默认值可以引用解构赋值的其他变量，但该变量<strong>必须已经声明</strong>。</p>
<h2 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再<strong>赋给对应的变量</strong>。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</li>
</ul>
<p>与数组一样，解构也<strong>可以用于嵌套结构的对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;    <span class="comment">//foo这时等于undefined，再取子属性就会报错</span></span><br></pre></td></tr></table></figure>

<p>对象的解构赋值<strong>可以取到继承的属性</strong>。</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。默认值生效的条件是，<strong>对象的属性值严格等于undefined</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有<strong>不将大括号写在行首</strong>，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。</p>
</li>
<li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-数值和布尔值的解构赋值"><a href="#2-4-数值和布尔值的解构赋值" class="headerlink" title="2.4 数值和布尔值的解构赋值"></a>2.4 数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就<strong>先将其转为对象</strong>。由于<strong>undefined和null无法转为对象</strong>，所以对它们进行解构赋值，都会报错。</p>
<h2 id="2-5-函数参数的解构赋值"><a href="#2-5-函数参数的解构赋值" class="headerlink" title="2.5 函数参数的解构赋值"></a>2.5 函数参数的解构赋值</h2><h2 id="2-6-圆括号问题"><a href="#2-6-圆括号问题" class="headerlink" title="2.6 圆括号问题"></a>2.6 圆括号问题</h2><p>建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号：</p>
<ol>
<li>变量声明语句</li>
<li>函数参数</li>
<li>赋值语句的模式</li>
</ol>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<h2 id="2-7-用途"><a href="#2-7-用途" class="headerlink" title="2.7 用途"></a>2.7 用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数参数的定义</li>
</ol>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<ol start="4">
<li>提取 JSON 数据</li>
<li>函数参数的默认值</li>
<li>遍历 Map 结构</li>
<li>输入模块的指定方法</li>
</ol>
<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-5-模板字符串"><a href="#3-5-模板字符串" class="headerlink" title="3.5 模板字符串"></a>3.5 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/快乐暑假第十天——学习ES6/" data-id="cjymaa6zo000glguw8goqtvby" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第九天——学习移动端网页制作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/快乐暑假第九天——学习移动端网页制作/" class="article-date">
  <time datetime="2019-07-17T13:35:49.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/快乐暑假第九天——学习移动端网页制作/">快乐暑假第九天——学习移动端网页制作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
用vw和vh能很好地实现响应式布局，但是这两个单位的兼容性不强，只有较新版本的浏览器才能使用。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
移动端的网页与PC端相比，少了鼠标悬浮和鼠标移开等事件，多了触摸事件，可以用监听器来对touchstart、touchmove和touchend进行监听。要想让某个元素随手指移动而移动，可以监听touchstart事件，当手指触碰到屏幕时获取此时的位置。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
要想让某个元素随手指移动而移动，可以监听touchstart事件，当手指触碰到屏幕时通过clientX和clientY属性获取此时的位置；监听touchmove事件，随时获取此时的位置，然后计算出位移，再进行移动。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-vw、vh、vmin、vmax-简介"><a href="#1-vw、vh、vmin、vmax-简介" class="headerlink" title="1. vw、vh、vmin、vmax 简介"></a>1. vw、vh、vmin、vmax 简介</h1><p>这些单位是一种视窗单位，也是相对单位(相对于视窗)。</p>
<ul>
<li>视窗(Viewport)是浏览器实际显示内容的区域，即不包括工具栏和按钮的网页浏览器。</li>
<li>具体描述：<ul>
<li><strong>vw</strong>：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）</li>
<li><strong>vh</strong>：视窗高度的百分比</li>
<li><strong>vmin</strong>：当前 vw 和 vh 中较小的一个值</li>
<li><strong>vmax</strong>：当前 vw 和 vh 中较大的一个值</li>
</ul>
</li>
</ul>
<h2 id="vw、vh-与百分比-的区别"><a href="#vw、vh-与百分比-的区别" class="headerlink" title="vw、vh 与百分比 % 的区别"></a>vw、vh 与百分比 % 的区别</h2><ul>
<li>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的</li>
<li>vw、vh <strong>能够直接获取高度</strong>，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的</li>
</ul>
<h2 id="vmin、vmax-用处"><a href="#vmin、vmax-用处" class="headerlink" title="vmin、vmax 用处"></a>vmin、vmax 用处</h2><p>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的(因为两种状态下视窗宽高会发生变化)。此时就可以用 vmin 和 vmax <strong>使得文字大小在横竖屏下保持一致</strong>。</p>
<h2 id="vw、vh-实现垂直居中"><a href="#vw、vh-实现垂直居中" class="headerlink" title="vw、vh 实现垂直居中"></a>vw、vh 实现垂直居中</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vh</span>; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25vh</span> auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-移动端触屏滑动事件"><a href="#2-移动端触屏滑动事件" class="headerlink" title="2. 移动端触屏滑动事件"></a>2. 移动端触屏滑动事件</h1><h2 id="四种-touch-事件"><a href="#四种-touch-事件" class="headerlink" title="四种 touch 事件"></a>四种 touch 事件</h2><ul>
<li><strong>touchstart</strong>: 手指放到屏幕上时触发</li>
<li><strong>touchmove</strong>: 手指在屏幕上滑动式触发</li>
<li><strong>touchend</strong>: 手指离开屏幕时触发</li>
<li><strong>touchcancel</strong>: 系统取消touch事件的时候触发(这个好像比较少用)</li>
</ul>
<h2 id="跟踪触摸"><a href="#跟踪触摸" class="headerlink" title="跟踪触摸"></a>跟踪触摸</h2><p>每个触摸事件被触发后，会生成一个event对象，event对象里额外包括以下三个触摸列表：</p>
<ul>
<li><strong>touches</strong>：表示当前跟踪的触摸操作的touch对象的数组。<ul>
<li>当一个手指在触屏上时，event.touches.length=1,当两个手指在触屏上时，event.touches.length=2，以此类推。</li>
</ul>
</li>
<li><strong>targetTouches</strong>：特定于事件目标的touch对象数组。<ul>
<li>因为touch事件是会冒泡的，所以利用这个属性指出目标对象。</li>
</ul>
</li>
<li><strong>changedTouches</strong>：表示自上次触摸以来发生了什么改变的touch对象的数组。</li>
</ul>
<p>这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下：</p>
<ul>
<li><strong>clientX</strong> / <strong>clientY</strong>：触摸目标在视口中的 x / y 坐标</li>
<li><strong>identifier</strong>：标识触摸的唯一ID</li>
<li><strong>pageX</strong> /  <strong>pageY</strong>：触摸目标在页面中的 x / y 坐标</li>
<li><strong>screenX</strong> / <strong>screenY</strong>：触摸目标在屏幕中的 x / y 坐标</li>
<li><strong>target</strong>：触摸的DOM节点目标</li>
</ul>
<h2 id="禁止缩放和滚动"><a href="#禁止缩放和滚动" class="headerlink" title="禁止缩放和滚动"></a>禁止缩放和滚动</h2><p>手指在滑动整个屏幕时，会影响浏览器的行为，比如滚动和缩放。所以在调用touch事件时，要注意禁止缩放和滚动。</p>
<h4 id="禁止缩放"><a href="#禁止缩放" class="headerlink" title="禁止缩放"></a>禁止缩放</h4><p>通过meta元标签来设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"target-densitydpi=320,width=640,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="禁止滚动"><a href="#禁止滚动" class="headerlink" title="禁止滚动"></a>禁止滚动</h4><p><strong>event.preventDefault()</strong>： preventDefault 是阻止默认行为，touch事件的默认行为就是滚动。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(div,<span class="string">"touchstart"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  div.innerHTML=event.touches[<span class="number">0</span>].clientX+<span class="string">','</span>+event.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(div,<span class="string">"touchmove"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  div.innerHTML=event.touches[<span class="number">0</span>].clientX;</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(div,<span class="string">"touchend"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  div.innerHTML=event.changedTouches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用clientX……时，必须要指明具体的touch对象，而不要直接指明数组:<br><code>event.touches[0]</code></li>
<li>在touchend事件处理函数中，当该事件发生时，touches里面已经没有任何的touch对象了，此时，就要使用changeTouches集合。</li>
</ul>
<h2 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h2><p>只有两个手指都触摸到事件的接收容器时才触发这些手势事件:</p>
<ul>
<li>gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。</li>
<li>gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。</li>
<li>gestureend：当任何一个手指从屏幕上面移开时触发。</li>
</ul>
<h4 id="触摸事件与手势事件之间的关系"><a href="#触摸事件与手势事件之间的关系" class="headerlink" title="触摸事件与手势事件之间的关系"></a>触摸事件与手势事件之间的关系</h4><ul>
<li>当一个手指放在屏幕上时，会触发touchstart事件，如果另一个手指又放在了屏幕上，则会触发gesturestart事件，随后触发基于该手指的touchstart事件。</li>
<li>如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件，但只要有一个手指移开，则会触发gestureend事件，紧接着又会触发toucheend事件。</li>
</ul>
<h4 id="手势的专有属性"><a href="#手势的专有属性" class="headerlink" title="手势的专有属性"></a>手势的专有属性</h4><ul>
<li>rotation：表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从零开始。</li>
<li>scale：表示两个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始，并随距离拉大而增长。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/快乐暑假第九天——学习移动端网页制作/" data-id="cjymaa6yu0003lguw87zqgs3n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第八天——学习canvas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/快乐暑假第八天——学习canvas/" class="article-date">
  <time datetime="2019-07-16T14:05:05.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/快乐暑假第八天——学习canvas/">快乐暑假第八天——学习canvas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天画钟画的有点心塞。再一次体会到了真正开始动手才会发现各种各样的问题。其实最后能让时针按照真实时间动起来，还是参考了网上的例子，一步一步模仿下来的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
大概总结一下今天做完时钟之后印象深刻的东西吧：<br>
canvas有自己的宽高，超出的部分不会显示；<br>
可以用moveTo方法改变画笔的位置，用来画不连续的线段；<br>
路径画好之后需要用stroke()来着色；<br>
可以设置线段的宽度、颜色；<br>
像画圆形的时候，边框的宽度不会遮住圆形本体；<br>
有时候用图形变换(旋转、平移等)可以省很大力气；<br>
在操作圆形之类的对称图形的时候，把原点放到画布中央更方便；<br>
写好注释，利人利己。<br>
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<p>&lt;canvas&gt;是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素，默认大小为300px × 150px，也可以自定义宽高。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><canvas> 元素</canvas></h2><p>&lt;canvas&gt; 标签只有 width 和 height 两个<strong>属性</strong>。</p>
<ul>
<li>应该用width和height属性为 &lt;canvas&gt; 明确规定宽高，而不是使用CSS(可能会出现扭曲)</li>
<li>&lt;canvas&gt;元素也有margin，border，background等等属性，且这些样式不会影响在canvas中的实际图像</li>
</ul>
<p>可以定义一些<strong>替换内容</strong>，在不支持此元素的浏览器上会展示这些替换内容，如文字描述或静态图片(使用&lt;img&gt;标签)。</p>
<h2 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h2><p>canvas起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。</p>
<ul>
<li><strong>getContext( ) 方法</strong>：用来获得渲染上下文和它的绘画功能。只有一个参数——上下文的格式。</li>
<li>可以通过测试 getContext( ) 方法的存在来检查编程的支持性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (canvas.getContext)&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="comment">// drawing code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h1><h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p><img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" alt="image"></p>
<ul>
<li>通常来说网格中的一个单元相当于canvas元素中的一像素。</li>
<li>栅格的起点为左上角（坐标为（0,0）），所有元素的位置都相对于原点定位。</li>
</ul>
<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>canvas只支持一种原生的图形绘制：矩形。</p>
<p>canvas提供了三种方法绘制矩形：</p>
<ol>
<li><strong>fillRect(x, y, width, height)</strong>：绘制一个填充的矩形</li>
<li><strong>strokeRect(x, y, width, height)</strong>：绘制一个矩形的边框</li>
<li><strong>clearRect(x, y, width, height)</strong>：清除指定矩形区域，让清除部分完全透明。</li>
</ol>
<p>以上的三个函数绘制之后会马上显现在canvas上。其中，x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。</p>
<ul>
<li><strong>beginPath()</strong>：新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>
<li><strong>closePath()</strong>：闭合路径之后图形绘制命令又重新指向到上下文中。</li>
<li><strong>stroke()</strong>：通过线条来绘制图形轮廓。</li>
<li><strong>fill()</strong>：通过填充路径的内容区域生成实心的图形。</li>
</ul>
<p>使用路径绘制图的步骤：</p>
<ol>
<li>生成路径 beginPath( ) 。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。每次这个方法调用之后，列表清空重置，然后就可以重新绘制新的图形。</li>
<li>调用函数指定绘制路径。</li>
<li>闭合路径 closePath( ) ,不是必需的。通过绘制一条从当前点到开始点的直线来闭合图形(如果图形已经闭合，即当前点为开始点，该函数什么也不做)。<ul>
<li>当调用 fill( ) 函数时，所有没有闭合的形状都会自动闭合，此时不需要调用 closePath( ) 函数。</li>
</ul>
</li>
</ol>
<h4 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h4><p><strong>moveTo(x, y)</strong>：将笔触移动到指定的坐标x以及y上。</p>
<ul>
<li>当canvas初始化或者beginPath()调用后，通常会使用moveTo()函数设置起点</li>
<li>也可以使用moveTo()绘制一些不连续的路径</li>
</ul>
<h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><p><strong>lineTo(x, y)</strong>：绘制一条从当前位置到指定x以及y位置的直线。</p>
<ul>
<li>该方法有两个参数：x以及y ，代表坐标系中直线结束的点</li>
</ul>
<h4 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h4><p><strong>arc(x, y, radius, startAngle, endAngle, anticlockwise)</strong>：画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。</p>
<ul>
<li>参数anticlockwise为一个布尔值。<strong>为true时，是逆时针方向</strong>，否则顺时针方向</li>
<li>函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式: <strong>弧度=(Math.PI/180)*角度</strong></li>
</ul>
<h4 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h4><p><img src="https://mdn.mozillademos.org/files/223/Canvas_curves.png" alt="image"></p>
<ul>
<li>红色点为控制点，蓝色点为开始点和结束点</li>
</ul>
<p><strong>quadraticCurveTo(cp1x, cp1y, x, y)</strong>：绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br><strong>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</strong>：绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p>
<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p><strong>rect(x, y, width, height)</strong>：绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</p>
<ul>
<li>当该方法执行的时候，当前笔触自动重置回默认坐标。</li>
</ul>
<h2 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h2><p><strong>Path2D( )</strong>：会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。</p>
<ul>
<li>所有的路径方法比如moveTo, rect, arc或quadraticCurveTo等都可以在Path2D中使用。</li>
<li>Path2D API 添加了 addPath 作为将path结合起来的方法。当你想要从几个元素中来创建对象时，这将会很实用。比如：<figure class="highlight plain"><figcaption><span>[, transform])```添加了一条路径到当前路径（可能添加了一个变换矩阵）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 使用样式和颜色</span><br><span class="line">## 色彩 Colors</span><br><span class="line">有两个重要的属性可以给图像上色：</span><br><span class="line">- **fillStyle = color**：设置图形的填充颜色。</span><br><span class="line">- **strokeStyle = color**：设置图形轮廓的颜色。</span><br><span class="line"></span><br><span class="line">color 可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象。默认情况下，线条和填充颜色都是黑色。</span><br><span class="line"></span><br><span class="line">一旦设置了 strokeStyle 或者 fillStyle 的值，这个新值就会成为新绘制的图形的默认值。</span><br><span class="line"></span><br><span class="line">## 透明度 Transparency</span><br><span class="line">**globalAlpha = transparencyValue**：这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</span><br><span class="line"></span><br><span class="line">strokeStyle 和 fillStyle 属性接受符合 CSS 3 规范的颜色值，因此 rgba( )  方法可以直接设置颜色透明度。</span><br><span class="line"></span><br><span class="line">## 线型 Line styles</span><br><span class="line">可以通过一系列属性来设置线的样式。</span><br><span class="line">- **lineWidth = value**：设置线条宽度。</span><br><span class="line">- **lineCap = type**：设置线条末端样式。</span><br><span class="line">- **lineJoin = type**：设定线条与线条间接合处的样式。</span><br><span class="line">- **miterLimit = value**：限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</span><br><span class="line">- **getLineDash()**：返回一个包含当前虚线样式，长度为非负偶数的数组。</span><br><span class="line">- **setLineDash(segments)**：设置当前虚线样式。</span><br><span class="line">- **lineDashOffset = value**：设置虚线样式的起始偏移量。</span><br><span class="line"></span><br><span class="line">#### lineWidth 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/201/canvas-grid.png)</span><br><span class="line">- 出现图二情况时会以实际笔触颜色一半色调的颜色来填充剩下的半个像素</span><br><span class="line"></span><br><span class="line">#### lineCap 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/236/Canvas_linecap.png)</span><br><span class="line"></span><br><span class="line">属性 lineCap 的值决定了线段端点显示的样子：**butt**，**round** 和 **square**。默认是 butt。</span><br><span class="line"></span><br><span class="line">#### lineJoin 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/237/Canvas_linejoin.png)</span><br><span class="line"></span><br><span class="line">lineJoin 的属性值决定了图形中两线段连接处所显示的样子：**round**, **bevel** 和 **miter**。默认是 miter。</span><br><span class="line"></span><br><span class="line">#### miterLimit 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/240/Canvas_miterlimit.png)</span><br><span class="line"></span><br><span class="line">lineJoin 属性应用 miter 时，当夹角减少时，交点距离会呈指数级增大。</span><br><span class="line"></span><br><span class="line">miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了 bevel。</span><br><span class="line"></span><br><span class="line">#### 使用虚线</span><br><span class="line">用 **setLineDash( ) 方法**和 **lineDashOffset 属性**来制定虚线样式.</span><br><span class="line">- setLineDash( ) 方法接受一个数组，来指定线段与间隙的交替</span><br><span class="line">- lineDashOffset 属性设置起始偏移量</span><br><span class="line"></span><br><span class="line">## 渐变 Gradients</span><br><span class="line">有两种方法可以新建一个 canvasGradient 对象：</span><br><span class="line">- **createLinearGradient(x1, y1, x2, y2)**:表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</span><br><span class="line">- **createRadialGradient(x1, y1, r1, x2, y2, r2)**:，前三个参数定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</span><br><span class="line"></span><br><span class="line">创建出 canvasGradient 对象后，就可以用 addColorStop 方法上色：</span><br><span class="line">- **addColorStop(position, color)**：position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置；color 参数必须是一个有效的 CSS 颜色值。</span><br><span class="line"></span><br><span class="line">## 图案样式 Patterns</span><br><span class="line">**createPattern(image, type)**：Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。</span><br><span class="line"></span><br><span class="line">图案的应用跟渐变类似，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。</span><br><span class="line">- 要使用 Image 对象的 onload 来确保设置图案之前图像已经装载完毕</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">  // 创建新 image 对象，用作图案</span><br><span class="line">  var img = new Image();</span><br><span class="line">  img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;</span><br><span class="line">  img.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">    // 创建图案</span><br><span class="line">    var ptrn = ctx.createPattern(img, &apos;repeat&apos;);</span><br><span class="line">    ctx.fillStyle = ptrn;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><ul>
<li><strong>shadowOffsetX = float</strong> 和 <strong>shadowOffsetY = float</strong>：shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li>
<li><strong>shadowBlur = float</strong>：shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li>
<li><strong>shadowColor = color</strong>：shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</li>
</ul>
<h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当用到 fill（或者 clip和isPointinPath ）时，可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。</p>
<p>两个可能的值：</p>
<ol>
<li><strong>“nonzero”</strong>: non-zero winding rule, 默认值</li>
<li><strong>“evenodd”</strong>:  even-odd winding rule</li>
</ol>
<h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>canvas 提供了两种方法来渲染文本:</p>
<ul>
<li><strong>fillText(text, x, y [, maxWidth])</strong>：在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</li>
<li><strong>strokeText(text, x, y [, maxWidth])</strong>：在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</li>
</ul>
<h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>以下属性可以改变 canvas 显示文本的方式：</p>
<ul>
<li><strong>font = value</strong>：当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。</li>
<li><strong>textAlign = value</strong>：文本对齐选项。可选的值包括：start, end, left, right 或 center. 默认值是 start。</li>
<li><strong>textBaseline = value</strong>：基线对齐选项。可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</li>
<li><strong>direction = value</strong>：文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</li>
</ul>
<h2 id="预测量文本宽度"><a href="#预测量文本宽度" class="headerlink" title="预测量文本宽度"></a>预测量文本宽度</h2><ul>
<li><strong>measureText( ) 方法</strong>：将返回一个 TextMetrics 对象的宽度、所在像素，这些体现文本特性的属性。</li>
</ul>
<h1 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h1><p>引入图像到canvas里需要以下两步基本操作：</p>
<ol>
<li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片</li>
<li>使用drawImage()函数将图片绘制到画布上</li>
</ol>
<h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2><p>canvas的API可以使用下面这些类型中的一种作为图片的源：</p>
<ul>
<li><strong>HTMLImageElement</strong>：这些图片是由Image()函数构造出来的，或者任何的 &lt;img&gt; 元素</li>
<li><strong>HTMLVideoElement</strong>：用一个HTML的 &lt;video&gt; 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</li>
<li><strong>HTMLCanvasElement</strong>：可以使用另一个 &lt;canvas&gt; 元素作为你的图片源。</li>
<li><strong>ImageBitmap</strong>：这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。</li>
</ul>
<p>这些源统一由 CanvasImageSource 类型来引用。</p>
<h4 id="使用相同页面内的图片"><a href="#使用相同页面内的图片" class="headerlink" title="使用相同页面内的图片"></a>使用相同页面内的图片</h4><p>可以通过下列方法来获得与canvas相同页面内的图片的引用：</p>
<ul>
<li><strong>document.images 集合</strong></li>
<li><strong>document.getElementsByTagName( ) 方法</strong></li>
<li><strong>document.getElementById( ) 方法</strong></li>
</ul>
<h4 id="使用其它域名下的图片"><a href="#使用其它域名下的图片" class="headerlink" title="使用其它域名下的图片"></a>使用其它域名下的图片</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/快乐暑假第八天——学习canvas/" data-id="cjymaa6zj000clguwbcgyv5zw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/26/快乐暑假第十七天——开始学习nodejs/">快乐暑假第十七天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第十六天——继续做Bolo/">快乐暑假第十六天——继续做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/24/快乐暑假第十五天——开始做Bolo/">快乐暑假第十五天——开始做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/23/快乐暑假第十四天——学习jQuery/">快乐暑假第十四天——学习jQuery</a>
          </li>
        
          <li>
            <a href="/2019/07/22/快乐暑假第十三天/">快乐暑假第十三天</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>