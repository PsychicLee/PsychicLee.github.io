<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lee&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lee&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-快乐暑假第七天——学习Ajax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/快乐暑假第七天——学习Ajax/" class="article-date">
  <time datetime="2019-07-15T13:32:25.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/快乐暑假第七天——学习Ajax/">快乐暑假第七天——学习Ajax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把之前六七章的笔记又回顾了一下，感觉已经比之前第一次看的时候要熟悉许多。然后在w3school上看了一下Ajax(貌似没有专门讲Ajax的博客)，大概就是XMLHttpRequest对象极其open( )和send( )方法、responseTex和responseXML两种获取内容的属性、onreadystatechange 事件这几个方面。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-创建-XMLHttpRequest-对象"><a href="#1-创建-XMLHttpRequest-对象" class="headerlink" title="1. 创建 XMLHttpRequest 对象"></a>1. 创建 XMLHttpRequest 对象</h1><p>XMLHttpRequest 对象是 AJAX 的基础，用于在后台与服务器交换数据。</p>
<ul>
<li>创建 XMLHttpRequest 对象的语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>(老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象)</p>
<p>为了兼容所有浏览器，可写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2. 向服务器发送请求"></a>2. 向服务器发送请求</h1><p>使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">open(method, url, async)</td>
<td align="left">method：请求的类型；GET 或 POST<br>url：文件在服务器上的位置<br>async：true（异步）或 false（同步）</td>
</tr>
<tr>
<td align="left">send(string)</td>
<td align="left">string：仅用于 POST 请求</td>
</tr>
</tbody></table>
<h2 id="GET-和-POST-的选择"><a href="#GET-和-POST-的选择" class="headerlink" title="GET 和 POST 的选择"></a>GET 和 POST 的选择</h2><p>GET 更简单也更快，但在以下情况中，必须使用 POST 请求：</p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ol>
<h1 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3. 服务器响应"></a>3. 服务器响应</h1><p>如需获得来自服务器的响应，需要使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性：</p>
<ul>
<li>responseText ： 获得字符串形式的响应数据</li>
<li>responseXML ： 获得 XML 形式的响应数据</li>
</ul>
<h1 id="4-onreadystatechange-事件"><a href="#4-onreadystatechange-事件" class="headerlink" title="4. onreadystatechange 事件"></a>4. onreadystatechange 事件</h1><p>XMLHttpRequest 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onreadystatechange</td>
<td align="left">存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td align="left">readyState</td>
<td align="left">存有 XMLHttpRequest 的状态,从 0 到 4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">200: “OK”<br>404: 未找到页面</td>
</tr>
</tbody></table>
<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/快乐暑假第七天——学习Ajax/" data-id="cjyk44b8q000048uwbca0izls" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第六天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/快乐暑假第六天/" class="article-date">
  <time datetime="2019-07-14T12:48:14.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/快乐暑假第六天/">快乐暑假第六天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
在看过王福朋的博客之后，对instanceof以及对象和函数的关系有了更清晰和更深入的理解，但是仍然有一些地方如this的指向，还是感觉比较别扭和生疏。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="6-函数表达式"><a href="#6-函数表达式" class="headerlink" title="6. 函数表达式"></a>6. 函数表达式</h1><p>定义函数的方式有两种：函数声明，函数表达式。</p>
<p>函数声明有一个重要特性：<strong>函数声明提升</strong>，即在执行代码之前会先读取函数声明。(因此函数声明可以放在调用语句后面)</p>
<p>函数表达式与其他表达式一样，在使用前必须先赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要这样做</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Yo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用的是函数表达式就没有问题了</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的。</p>
<p>在编写递归函数时，使用 arguments.callee (指向正在执行函数的指针) 代替函数名更保险。或者使用命名函数表达式来达成相同的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> faactorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是<strong>在一个函数内部创建另一个函数</strong>。</p>
<p>后台的每个执行环境都有一个表示变量的对象————<strong>变量对象</strong>。</p>
<p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>
<p>在另一个函数内部定义的函数会将包含函数的活动对象添加到它的作用域中。</p>
<h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个函数的作用域中都保存着creatFunctions( )函数的活动对象，所以它们引用的都是同一个变量 i <strong>(闭包只能取得包含函数中任何变量的最后一个值)</strong></li>
</ul>
<p>可以将函数改为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h4><p>this 对象是在运行时基于函数的执行环境绑定的。但匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
<p>如果想访问作用域中的 this 和 arguments 对象，必须将该对象的引用保存到另一个闭包能够访问的变量中。</p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>多次声明同一个变量时，会对后续的声明视而不见(不过，会执行后续声明的初始化)。</p>
<p>函数声明后面不能跟圆括号，而函数表达式可以。给函数声明加上一对圆括号即可将其转换为函数表达式。</p>
<p>无论在什么地方，如果临时需要一些变量，就可以使用私有作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    </span><br><span class="line">    alert(i);   <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>在任何函数中定义的变量，都可以认为是私有变量(包括函数的参数、局部变量、函数内部定义的其他函数)。</p>
<p>有权访问私有变量和私有函数的公有方法称为<strong>特权方法</strong>，有两种在对象上创建特权方法的方式：</p>
<ul>
<li>在构造函数中定义特权方法(缺点是必须使用构造函数模式来达到这个目的)</li>
<li>使用静态私有变量来实现特权方法</li>
</ul>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/快乐暑假第六天/" data-id="cjyk44b90000448uwuhik9w93" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第五天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/12/快乐暑假第五天/" class="article-date">
  <time datetime="2019-07-12T11:50:17.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/12/快乐暑假第五天/">快乐暑假第五天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
在我的不懈努力下，今天终于将第六章看完了。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
明显能感觉到第六章对比起前面几章更难理解，有点像上学期学C语言链表那一部分时的感觉，一开始会感觉很绕，记住了构造函数、原型、实例之间的关系之后，继承部分也就能慢慢看懂了。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
单一地使用一种方法可能会有这样那样的问题，但是结合起来、取长补短，或许能获得满意的结果。
</p>


<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>(接前一天笔记)

<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>由于实例与原型之间的松散连接关系(二者之间的联系的一个指针，而不是一个副本)，在原型中添加属性和方法可以立即在实例中反映出来。</p>
<p>重写原型对象会切断现有原型与之前已经存在的对象实例之间的联系，这些实例引用的仍然是最初的原型。</p>
<h5 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h5><p>不仅是创建自定义类型，所有原生的引用类型(Object、Array等)都是采用原型模式创建的。</p>
<p>通过元素对象的原型，可以取得所有默认方法发引用，也可以定义新的方法(跟自定义类型一样)。</p>
<h5 id="原型对象的缺点"><a href="#原型对象的缺点" class="headerlink" title="原型对象的缺点"></a>原型对象的缺点</h5><p>省略了为构造函数传递初始化参数这一环节，因此所有实例在默认情况下都将取得相同的属性值。</p>
<p>对于包含引用类型值的属性来说，这种共享会导致一些问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，可以使每个实例都有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度地节省了内存。这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>person1.friends和person2.friends分别引用了不同的数组，不会互相影响</li>
</ul>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//properties</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//methods</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>

<ul>
<li>if 语句检查的可以是初始化之后应该存在的任何属性或方法，且只需要检查其中一个就好。</li>
</ul>
<h4 id="寄生构造函数模式-不建议"><a href="#寄生构造函数模式-不建议" class="headerlink" title="寄生构造函数模式(不建议)"></a>寄生构造函数模式(不建议)</h4><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式其实跟工厂模式是一样的。这个模式可以在特殊情况下用来为对象创建构造函数。</p>
<p>构造函数在不返回值的情况下，默认会返回新对象实例，而再构造函数末尾添加return语句可以重写调用构造函数使返回的值。</p>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象：指的是没有公共属性，且其方法也不引用this的对象。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>只支持实现继承，而实现继承主要是依靠原型链来实现的。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想是利用原型链让一个引用类型继承另一个引用类型的属性和方法。</p>
<h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认都继承了Object(也是通过原型链实现的)，因此所有自定义类型都会继承toString( )、valueOf( )等默认方法。</p>
<h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><p>可以通过两种方式来确定原型和实例的关系：</p>
<ul>
<li>使用instanceof操作符：用这个操作符来测试与原型链中<strong>出现过的</strong>构造函数，就会返回true</li>
<li>使用isPrototypeOf( )方法：只要是原型链中<strong>出现过的</strong>原型，都会返回true</li>
</ul>
<h5 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h5><p>给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p>在通过原型链实现继承时，不能使用对象字面量创建原型方法，否则会重写原型链。</p>
<h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><p>最主要的问题来自包含引用类型值的原型，也是由于属性共享带来的问题。</p>
<p>在创建子类型的实例时，不能向超类型的构造函数中传递参数(实际上是无法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)。</p>
<p>因此实践中很少单独使用原型链。</p>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>思路为在子类型构造函数的内部调用超类型构造函数。</p>
<p>借用构造函数可以在子类型构造函数中向超类型构造函数传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//继承了 SuperType ，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);    <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age);     <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<ul>
<li>为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</li>
</ul>
<p>借用构造函数也有一些缺点，因此很少单独使用。</p>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>指的是将原型链和借用构造函数的技术组合到一块的一种继承模式。</p>
<p>思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。</p>
<p>最常用的继承模式。</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有对象创建新对象，且不必因此创建自定义类型。</p>
<p>Object.creat( ) 方法规范化了原型式继承。接收两个参数：一个用作新对象原型的对象和一个为新对象定义额外属性的对象(可选)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line">alert(anotherPerson.name);  <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>包含引用类型值的属性始终会共享相应的值。</li>
</ul>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>组合继承最大的问题就是无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<p>寄生组合式继承指：通过借用构造函数来继承属性，通过原型链的混成方式来继承方法。<br><br>本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<p>寄生组合式继承的基本模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);   <span class="comment">//创建对象(创建超类型原型的一个副本)</span></span><br><span class="line">    prototype.constructor = subType;               <span class="comment">//增强对象(为创建的副本添加因重写原型而失去的默认 constructor 属性)</span></span><br><span class="line">    subType.prototype = prototype;                 <span class="comment">//指定对象(将创建的新对象——即副本——赋值给子类型的原型)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以调用inheritPrototype( )函数的语句去替换为子类型原型赋值的语句</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/12/快乐暑假第五天/" data-id="cjyk44b9c000a48uwbs3pf19n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第四天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/快乐暑假第四天/" class="article-date">
  <time datetime="2019-07-11T13:16:02.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/快乐暑假第四天/">快乐暑假第四天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
进入第六章的学习，感觉有一点绕，原型对象、构造对象、实例之间的关系以及联系它们的一些方法。但花点时间理解一下之后也渐渐地有一点概念了。
</p>

<p style="font-size:18px;text-align:left;text-indent:2em">
接下来强行总结一波：我早上吃了超市买的4块钱三明治和一瓶蒙牛纯牛奶，中午吃了一盘不知道叫什么的菜和一碗白米饭，晚上吃的是豆角和豆腐。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
ps：今天没抽卡。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="5-面向对象的程序设计"><a href="#5-面向对象的程序设计" class="headerlink" title="5. 面向对象的程序设计"></a>5. 面向对象的程序设计</h1><p>对象的定义为：无序属性的集合，其属性可以包含基本值、对象或函数。</p>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ECMAScript 中有两种属性：</p>
<ul>
<li><p>数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<ul>
<li><p>数据属性有4个描述其行为的特性：</p>
<ol>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Enumerable]]:表示能否通过 fot-in 循环返回属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Writable]]:表示能否修改属性的值。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Value]]:包含这个属性的数据值。读取属性的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。(这个特性的默认值为undefined)</li>
</ol>
</li>
<li><p>修改属性默认特性必须使用 Object.defineProperty( ) 方法，该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符对象的属性必须是：configurable、enumerable、writable、value。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一旦把属性定义为不可配置的(configurable: false)，就不能再把它变回可配置了，此时再调用Object.defineProperty( )方法修改除writable之外的特性都会导致错误。</li>
<li>在调用该方法创建新属性时，如果不指定，configurable、enumerable、writable特性的默认值都是false；如果只是修改已定义的属性的特性则无此限制。</li>
</ul>
</li>
</ul>
</li>
<li><p>访问器属性：不包含数据值，包含一对getter和setter函数(但这两个函数都不是必需的)。</p>
<ul>
<li><p>访问器属性有4个特性：</p>
<ol>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特<br>性,或者能否把属性修改为数据属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Enumerable]]:表示能否通过 fot-in 循环返回属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Get]]：读取属性时调用的函数。(默认值为undefined)</li>
<li>[[Set]]：写入属性时调用的函数。(默认值为undefined)</li>
</ol>
</li>
<li><p>访问器属性不能直接定义，必须使用Object.defineProperty( )来定义。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。将year属性修改为2005会导致 _year 变成2005，而 edition 变为2。</li>
<li>这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</li>
</ul>
</li>
<li><p>只指定getter意味着属性是不能写，尝试写入属性会被忽略；只指定setter函数的属性不能读，否则会返回undefined。</p>
</li>
</ul>
</li>
</ul>
<h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>利用Object.defineProperties( )方法可以通过描述符一次定义多个属性。</p>
<p>该方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    year: &#123;            </span><br><span class="line">        <span class="keyword">get</span>: function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>Object.getOwnPropertyDescriptor( )方法可以取得给定属性的<strong>描述符</strong>。</p>
<p>该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。</p>
<p><strong>返回值是一个对象</strong>：</p>
<ul>
<li>若是访问器属性，则这个对象的属性有configurable、enumerable、get、set</li>
<li>若是数据属性，则这个对象的属性有configurable、enumerable、writable、value</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用Object构造函数或对象字面量来创建很多对象时会产生大量重复的代码。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>用函数来封装以特定接口创建对象的细节：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">            o.name = name;</span><br><span class="line">            o.age = age;</span><br><span class="line">            o.job = job;</span><br><span class="line">            o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;;    </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">        <span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">        </span><br><span class="line">        person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line">        person2.sayName();   <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.job = job;</span><br><span class="line">            <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">        <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>用new操作符调用构造函数会经过以下4个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(因此this就指向了这个新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象<br>返回的对象都有一个constructor(构造函数)属性，该属性指向对应的构造函数。</li>
</ol>
<h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><p>任何函数，只要通过new操作符来调用，就可以作为构造函数；任何函数，如果不通过new操作符来调用，就是普通函数。</p>
<h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>不同实例上的同名函数是不相等的，因此会创建许多相同的Function实例。</p>
<p>由于this对象的存在，可以将函数的定义转移到构造函数外部。</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<h5 id="原型对象的性质"><a href="#原型对象的性质" class="headerlink" title="原型对象的性质"></a>原型对象的性质</h5><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性(可以自定义添加)，其他方法则都是从Object继承而来的。</p>
<p>调用构造函数创建一个新的实例后，该实例内部包含一个指针(内部指针)叫[[Prototype]]，这个连接存在于实例和构造函数的原型对象之间(实例与构造函数之间没有直接的关系)。</p>
<p>虽然无法访问到[[Prototype]]，但可以通过 isPrototpyeOf( ) 方法来确定对象之间是否存在这种关系。如果[[Prototype]]指向调用该方法的对象，则会返回true。</p>
<p><strong>Object.getPrototypeOf( )方法</strong>可以用来取得[[Prototype]]的值(即指向的原型对象)。</p>
<p>当代码读取某个对象的某个属性时，会先从对象实例本身开始搜索给定名字的属性，如果没找到，则继续搜索指针指向的原型对象，若搜索到了这个属性，则返回该属性的值。(多个对象实例共享原型所保存的属性和方法的基本原理)<br><br>可以通过对象实例访问保存在原型中的值，但<strong>不能改写</strong>。如果在实例中添加的新属性与实例原型中的属性同名，则新属性会屏蔽原型中的那个属性。</p>
<p>delete操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p>
<p>hasOwnProperty( )方法可以检测一个属性是存在于实例中还是存在于原型中。当给定属性存在于实例中时，返回true。</p>
<h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><p>有两种方式使用 in 操作符：<br>    - 单独使用：会在通过对象能够访问给定的属性时返回 true ，无论该属性存在于实例中还是原型中。<br>    - 在 for-in 循环中使用：返回的是所有能够通过对象访问的、可枚举的(enumerable)属性，包括存在于实例中和原型中的属性。屏蔽了原型中不可枚举属性(即[[enumerable]]标记为false)的实例属性也会返回。</p>
<p>Object.keys( ) 方法能取得对象上所有可枚举的实例属性，接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<p>Object.keys( ) 和 Object.getOwnPropertyNames( ) 方法都可以用来替代 for-in 循环。</p>
<h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">    </span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></span><br><span class="line">alert(friend.constructor == Person);  <span class="comment">//false</span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时用constructor属性不再指向Person，而是指向Object。</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/快乐暑假第四天/" data-id="cjyk44b9l000h48uw6l50iufx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第三天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/快乐暑假第三天/" class="article-date">
  <time datetime="2019-07-10T10:05:08.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/快乐暑假第三天/">快乐暑假第三天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
JavaScript 中有许多操作都会隐式地转换数据类型，最常见的就是转换为布尔值、字符串或者数值，例如：

<ul>
<li>进行加法操作时，如果有一个操作数是字符串，则会将另一个操作数转换为字符串，然后进行字符串的拼接</li>
<li>进行减法操作时，如果有一个操作数是字符串、布尔值、null 或 undefined ,则先在后台调用 Number () 函数将其转换为数值，然后再根据相关的规则执行减法计算</li>
<li>乘除求模操作时，如果有一个操作数不是数值，则会在后台调用 Number( ) 将其转换为数值再进行计算</li>
<li>关系操作符也会进行一些转换然后进行比较</li>
</ul>
</p>

<p style="font-size:18px;text-align:left;text-indent:2em">
除此之外还有很多操作符都会进行隐式转换，一时半会很难全部记住，还需要在以后的学习和实践中慢慢积累，然后逐渐掌握牢固。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
语句方面大部分语法都与C相同，因此很容易就能记住并使用，但也有一些像for-in语句、label语句之类的之前并没有接触过，感到比较陌生。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
函数方面，我觉得其参数的保存机制挺有意思的，这种类似数组的保存方式也给函数的使用带来了更大的发挥空间。但是任何事物都有两面性，自由宽松或许会容易造成某些错误，这也需要在之后的实践中慢慢摸索。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
学习了作用域以及作用域链的相关工作原理之后也明白了一些之前不是很清楚的东西，比如在一个局部环境中定义一个与上一级环境中某个变量同名的变量是可行的，并且在该局部变量中使用这个变量时并不用担心这个变量的值会不会受到上一级环境中的同名变量的影响。作用域链就像一棵树一样，全局环境是根部，其中又包含了许多互不相干的局部环境，可以在小环境中使用相应父级环境定义的变量或函数，但不能使用子级的任何东西。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
引用类型这部分，虽然书里讲述的意思看懂了，但是总觉得有一点空，对引用类型还没有很好的掌握和理解，还不是很熟悉。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-变量、作用域和内存问题"><a href="#3-变量、作用域和内存问题" class="headerlink" title="3.变量、作用域和内存问题"></a>3.变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><ul>
<li>ECMAScipt 变量可能包含两种不同数据类型的值：<ul>
<li>基本类型值：指的是简单的数据段，在内存中占据固定大小空间，因此被保存在<strong>栈内存</strong>中</li>
<li>引用类型值：指那些可能由多个值构成的对象，保存在<strong>堆内存</strong>中</li>
</ul>
</li>
<li>5种基本数据类型是按值访问的，因为<strong>可以操作保存在变量中的实际的值</strong></li>
<li>引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置，也就是说<strong>不能直接操作对象的内存空间</strong></li>
</ul>
<h4 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h4><p>只能给引用类型值动态地添加属性，以便将来使用 (给基本类型值添加属性不会报错，但没有效果)。</p>
<h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><ul>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，二者的值相同但完全独立，进行任何操作都不会互相影响</li>
<li>从一个变量向另一个变量复制引用类型的值，实际上新变量是一个指针，指向一个对象，复制操作结束后二者将引用同一个对象</li>
</ul>
<h4 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h4><p>ECMAScript 中所有函数的参数都是按值传递的 (<strong>访问变量有按值和按引用两种方式，而参数只能按值传递</strong>)</p>
<ul>
<li>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数)</li>
<li>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数外部</li>
</ul>
<p>证明对象是按值传递的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person);  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果 person 是按引用传递的，那么 person 就会自动被修改为指向其 name 属性为 “Grey” 的新对象，但接下来访问 person.name 时，显示的值仍然是 “Nicholas”</li>
<li>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持不变<br>  实际上，在函数内部重写 obj 时，这个变量引用的就是一个局部对象了 (会在函数执行完毕后被销毁)</li>
</ul>
<p>可以把 ECMAScipt 函数的参数想象成局部变量。</p>
<h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>typeof 操作符在检测引用类型的值时作用不大，当我们想知道某个值是什么类型的对象可以使用 instanceof 操作符</p>
<ul>
<li><p>语法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量是给定引用类型的实例，那么 instanceof 操作符就会返回 true，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">//变量 person 是 Object 吗？</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">//变量 colors 是 Array 吗？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>所有引用类型的值都是 Object 的实例，因此在检测一个引用类型的值和 Object 构造函数时，始终返回 true</p>
</li>
<li><p>如果使用 instanceof 操作符检测基本类型的值，则始终返回 false</p>
</li>
</ul>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
<p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中，虽然代码无法访问，但解析器处理数据时会用到它。</p>
<p>在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法去创造的。</p>
<p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数也随之销毁(全局执行环境直到应用程序退出————例如关闭网页或浏览器————时才会被销毁)。</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问，其前端始终是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其<strong>活动对象</strong>作为变量对象。</p>
<ul>
<li>活动对象在最开始时只包含一个变量，即 arguments 对象(找个对象在全局环境中是不存在的)</li>
</ul>
<p>作用域链的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境，这样一直延续到全局执行环境(全局执行环境的变量对象始终是作用域链中的最后一个对象)。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终<strong>从作用域链的前端开始，逐级向后回溯</strong>，直到找到标识符为止(如果找不到标识符，通常会导致错误发生)。</p>
<p><strong>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数</strong>。</p>
<p>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>当执行流进入下列任何一个语句时，作用域链就会得到加长(这两个语句都会在作用域链的前端添加一个变量对象)：</p>
<ol>
<li>try-catch 语句的 catch 块<ul>
<li>会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</li>
</ul>
</li>
<li>with 语句<ul>
<li>会将指定的对象添加到作用域链中</li>
</ul>
</li>
</ol>
<h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><p>在其他类 C 语言中，由花括号封闭的代码都有自己的块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure>

<p>对于有块级作用域的语言来说，for 循环初始化的变量 i 只会存在于循环的环境中；而对于 JavaScript 来说，for 创建的 i 即使在循环结束之后，也会存在于循环的外部环境中。</p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>使用 var 声明的变量会自动添加到<strong>最接近</strong>的环境中(如果初始化变量时没有使用 var 声明，该变量会自动添加到全局环境)</p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>搜索过程<strong>从作用域链的前端开始</strong>，向上级查询与给定名字匹配的标识符，如果在局部环境找到了该标识符，搜索过程停止(<strong>如果局部环境存在着同名标识符，就不会使用位于父环境的标识符</strong>)。</p>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>执行环境会负责管理代码执行过程中使用的内存，所需内存的分配以及无用内存的回收完全实现了自动管理。机制为<strong>周期性执行</strong>：找出无用变量，将其所占内存释放。</p>
<ul>
<li>用于标识无用变量的策略通常有两个：标记清除(最常用)、引用计数(少用)</li>
</ul>
<p><strong>管理内存</strong>：优化占用内存的最佳方式就是执行中的代码只保存必要的数据，一旦数据不再有用，将其值设置为 null 来释放其引用，称为<strong>解除引用</strong>(局部变量会在离开执行环境时自动被解除引用，全局变量需要手工为它解除引用)。</p>
<h1 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4. 引用类型"></a>4. 引用类型</h1><blockquote>
<p>引用类型的值(对象)是引用类型的一个实例<br><br>在 JavaScript 中引用类型是一种数据结构，用于将数据和功能组织在一起<br><br>引用类型有时候也被称为对象定义,因为它们描述的是一类对象所具有的属性和方法,对象是某个特定引用类型的实例</p>
</blockquote>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建 Object 实例的方式有两种</p>
<ol>
<li><p>使用 new 操作符后跟 Object 构造函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处的左花括号表示一个表达式的开始</p>
</li>
<li><p>在对象字面量中，<strong>使用逗号来分隔不同的属性，在最后一个属性后面不能加逗号</strong></p>
</li>
<li><p><strong>属性名也可以使用字符串</strong>，如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line"><span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的数值属性名会自动转换为字符串</li>
</ul>
</li>
<li><p>如果留空其花括号，则<strong>可以定义只包含默认属性和方法的对象</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; &#125;    <span class="comment">// 与 new Object() 相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过对象字面量定义对象时，实际上不会调用 Object 构造函数</p>
</li>
<li><p>是<strong>向函数传递大量可选参数的首选方式</strong><br>访问对象属性时一般用点表示法，也可以使用方括号表示法，二者在功能上没有区别，但通常使用点表示法：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]);  <span class="comment">// "Nicholas"</span></span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>将要访问的属性以字符串的形式放在方括号中，<strong>主要优点是可以通过变量来访问属性</strong>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]);    <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性名包含会导致语法错误的特殊字符(如空格)，或属性名使用的是关键字或保留字，也可以用方括号表示法。</strong></p>
</li>
</ul>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>ECMAScipt 数组的每一项可以保存任何类型的数据，数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新的数据。<br><br>创建数组的基本方式有两种：</p>
<ol>
<li><p>使用 Array 构造函数</p>
<ul>
<li><p>如果预先知道数组的长度，可以给构造函数传递该数量(会自动变成lenghth属性的值)</p>
</li>
<li><p>可以向 Array 构造函数传递数组中应该包含的项</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给构造函数传递一个值也可以创建数组，但此时如果传递的是数值，则会按照数值创建包含指定项数的数组</p>
</li>
<li><p>使用 Array 构造函数时也可以省略 new 操作符</p>
</li>
</ul>
</li>
<li><p>使用数组字面量表示法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];  <span class="comment">// 使用方括号</span></span><br><span class="line"><span class="keyword">var</span> names = [ ];                        <span class="comment">// 创建一个空数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与对象一样，在使用数组字面量表示法时，也不会调用 Array 构造函数</li>
</ul>
</li>
</ol>
<ul>
<li>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，索引小于数组项数，则返回对应项的值，否则返回 undefined 值；设置数组的值也使用相同的语法，但会替换指定位置的值，但<strong>如果设置某个值的索引超过了数组现有项数，数组就会自动长度。</strong></li>
<li>数组的项数保存在其 length 属性中，<strong>可以通过设置 length 属性从数组的末尾移除项或向数组中添加新项</strong>(新增的每一项为 “undefined” 值)。</li>
</ul>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul>
<li>对于一个网页或者一个全局作用域而言，使用 instanceof 就可以确定某个对象是不是数组</li>
<li>Array.isArray( ) 方法，这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的</li>
</ul>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><p>所有对象都具有 都具有 toLocaleString( ) 、 toString( ) 和 valueOf( ) 方法：</p>
<ul>
<li><p>调用 valueOf( ) 返回的还是数组本身</p>
</li>
<li><p>调用数组的 toString( ) 方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串(实际上,为了创建这个字符串会调用数组每一项的 toString( ) 方法)</p>
</li>
<li><p>调用数组的 toLocaleString( ) 方法时，它也会创建一个数组值的以逗号分隔的字符串(为了取得每一项的值，调用的是每一项的 toLocaleString( ) 方法)<br>数组继承的 toLocaleString( ) 、 tostring( ) 和 valueof( ) 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项<br>如果使用 join( ) 方法，则可以使用不同的分隔符来构建这个字符串</p>
</li>
<li><p>join( ) 方法只接收一个参数，即用作分隔符的字符串</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(colors.join(<span class="string">"||"</span>));   <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果数组中某一项值是 <strong>null 或 undefined，则该值在返回结果中以空字符串表示</strong>。</p>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p>数组可以表现得像<strong>栈</strong>一样：</p>
<ul>
<li>栈是一种 LIFO ( Last-In-First-Out ,后进先出 ) 的数据结构，也就是最新添加的项最早被移除</li>
<li>栈中项的插入(叫做<strong>推入</strong>)和移除(叫做<strong>弹出</strong>)只发生在栈的顶部</li>
</ul>
<p>ECMAScipt 为数组提供了 push( ) 和 pop( ) 方法，以便实现类似栈的行为：</p>
<ul>
<li>push( ) 方法可以接收任意数量的参数，将其逐个添加到数组末尾，并返回修改后数组的长度</li>
<li>pop( ) 方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p>队列数据结构的访问规则是 FIFO ( First-In-First-Out ,先进先出 ) ，队列在列表的末端添加项，从列表的前端移除项。</p>
<p>结合使用 push( ) 和 shift( ) 方法，可以像使用队列一样使用数组：</p>
<ul>
<li>shift( ) 方法能够移除数组中的第一个项并返回该项，同时将数组长度减 1</li>
</ul>
<p>结合使用 pop( ) 方法和 unshift( ) 方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末尾移除项：</p>
<ul>
<li>unshift( ) 方法能在数组前端添加任意个项并返回数组长度</li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><ul>
<li><p>reverse( ) 方法：会反转数组项的顺序</p>
</li>
<li><p>sort( ) 方法：按升序排列数组项</p>
<ul>
<li><p>会调用每个数组项的 toString( ) 转型方法，然后比较得到的字符串，以确定如何排序</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort( );</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 10, 15, 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>很多情况下都不是最佳方案，因此 sort( ) 方法可以接收一个比较函数作为参数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);      <span class="comment">// 0, 1, 5, 10, 15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果第一个应该位于第二个之前则返回一个负数，两个参数相等则返回 0 ，如果第一个参数应该位于第二个之后则返回一个正数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>reverse( ) 方法和 sort( ) 方法的返回值是经过排序之后的数组</p>
</li>
</ul>
<h4 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h4><p>两种查找方法：</p>
<ul>
<li>indexOf( ) 方法：从数组的开头(位置 0 )开始向后查找</li>
<li>lastIndexOf( ) 方法：从数组的末尾开始向前查找</li>
</ul>
<p>二者都接收两个参数：要查找的项和表示查找起点位置的索引(可选)，在比较第一个参数与数组中的每一项时<strong>使用全等操作符</strong>(要求查找的项严格相等)。二者都返回要查找的项在数组中的位置，没找到则返回 -1。</p>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><ul>
<li>ECMAScript 5 为数组定义了 5 个迭代方法：<ol>
<li>every( ) : 对数组中每一项都运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li>filter( ) : 对数组中每一项都运行给定函数，返回该函数会返回 true 的项组成的数组</li>
<li>forEach ( ) : 对数组中每一项都运行给定函数，没有返回值</li>
<li>map( ) : 对数组中每一项都运行给定函数，返回每次函数调用的结果组成的数组</li>
<li>some( ) : 对数组中每一项都运行给定函数，如果该函数对任一项返回 true，则返回 true</li>
</ol>
</li>
<li>每个方法都接收两个参数：<ol>
<li>要在每一项上都运行的函数<ul>
<li>传入这些方法的函数会接收三个参数：数组的项、该项在数组中的位置、数组对象本身</li>
</ul>
</li>
<li>(可选)运行该函数的作用域对象————影响 this 的值</li>
</ol>
</li>
</ul>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><ul>
<li>ECMAScript 5 新增了两个归并数组的方法，二者都会迭代数组的所有项，然后构建一个最终返回的值：<ol>
<li>reduce( ) ：从数组第一项开始逐个遍历到最后</li>
<li>reduceRight( ) ：从数组最后一项开始遍历到第一项</li>
</ol>
</li>
<li>二者都接收两个参数：<ol>
<li>一个在每一项上调用的函数<ul>
<li>函数接收四个参数：前一个值、当前值、项的索引、数组对象</li>
<li>这个函数返回的任何值都会作为第一个参数自动传给下一项(第一次迭代发生在数组的第二项上)</li>
</ul>
</li>
<li>(可选)作为归并基础的初始值</li>
</ol>
</li>
</ul>
<h2 id="Date-类型"><a href="#Date-类型" class="headerlink" title="Date 类型"></a>Date 类型</h2><ul>
<li><p>要创建一个日期对象，使用 new 操作符和 Date 构造函数</p>
<ul>
<li>不传递参数时，新创建的对象自动获得当前日期和时间</li>
<li>如果想创建特定日期对象，必须传入表示该日期的毫秒数(即从 UTC 时间 1 月 1 日午夜起至该日期经过的毫秒数)</li>
</ul>
</li>
<li><p>为了简化计算，ECMAScript 5 提供了两个方法：</p>
<ol>
<li>Data.parse( ) :接受一个表示日期的字符串参数，然后返回相应的毫秒数<ul>
<li>如果传入的字符串不能表示日期，则返回 NaN</li>
<li>实际上，如果直接将表示日期的字符串传递给 Date 构造函数，也会在后台调用 Data.parse( )</li>
</ul>
</li>
<li>Date.UTC( ) ：参数分别是年份、基于 0 的月份(一月是 0 )、月中的哪一天( 1 到 31 )、小时数( 0 到 23 )、分钟、秒、毫秒数，返回表示日期的毫秒数<ul>
<li>参数中只有年和月是必须的，其他假设为 0 或 1 (范围内最小)</li>
<li>Date 构造函数也会模仿 Date.UTC( ) ，但日期和时间都基于本地时区而非 GMT 来创建</li>
</ul>
</li>
</ol>
</li>
<li><p>Date.now( ) 方法返回表示调用这个方法的日期和时间的毫秒数</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();     <span class="comment">// 获得开始的时间</span></span><br><span class="line">doSomething();              <span class="comment">// 调用函数</span></span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();      <span class="comment">// 取得停止时间</span></span><br><span class="line">    result = top - start;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在不支持Date.now( ) 方法的浏览器中，使用 + 操作符获取对象 Date 的时间戳也可达到相同的目的</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> stop = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><ul>
<li>与其他引用类型一样，Date 类型也重写了 toLacaleString( )、toString( ) 和 valueOf( ) 方法<ul>
<li>toLacaleString( ) 方法会按照与浏览器设置的地区相适应的格式返回日期和时间(因浏览器而异)</li>
<li>toString( ) 方法则通常返回带有时区信息的日期和时间，其中一般以军用时间(即小时的范围是 0 到 23)表示(因浏览器而异)</li>
<li>valueOf( ) 方法不返回字符串，而是返回日期的毫秒表示，因此可以使用比较操作符来比较日期值</li>
</ul>
</li>
</ul>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><ul>
<li>Date类型还有一些专门用于将日期格式化为字符串的方法：<ol>
<li>toDateString( ) : 以特定于实现的格式显示星期几、月、日和年</li>
<li>toTimeString( ) : 以特定于实现的格式显示时、分、秒和时区</li>
<li>toLocaleDateString( ) : 以特定于地区的格式显示星期几、月、日和年</li>
<li>toLocaleTimeString( ) : 以特定于实现的格式显示时、分、秒</li>
<li>toUTCString( ) : 以特定于实现的格式完整的UTC日期</li>
</ol>
</li>
<li>以上这些字符串格式式方法的输出也是因浏览器而异的</li>
</ul>
<h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><h2 id="RexExp-类型"><a href="#RexExp-类型" class="headerlink" title="RexExp 类型"></a>RexExp 类型</h2><h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>可以用函数声明语法或者函数表达式来定义函数。</p>
<p>函数实际上是对象，是Function类型的实例，因此函数名就是一个指向函数对象的指针，不会与某个函数绑定。由于函数名的指针性质，一个函数可能会有很多名字。</p>
<p>使用不带圆括号的函数命是访问函数指针，而不是调用函数。</p>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>创建两个同名函数，第二个函数会覆盖第一个。</p>
<h4 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h4><ul>
<li>解析器会先读取函数声明，，并使其在执行任何代码之前可用</li>
<li>函数表达式则必须等到解析器执行到它所在的代码行才会被解释执行</li>
</ul>
<h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>由于函数名本身就是变量，所以函数也可以作为值来使用(可以把函数传递给另一个函数，也可以将一个函数作为另一个函数的结果返回)</p>
<h4 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h4><p>函数内部有两个特殊的对象：arguments和this：</p>
<ul>
<li>arguments：主要用途是保存函数参数，还有一个名叫 callee 的属性，该属性是一个指向拥有这个arguments对象的函数的指针(可以消除递归算法中函数命耦合的问题)</li>
<li>this：引用的是函数执行的环境对象</li>
</ul>
<h4 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/快乐暑假第三天/" data-id="cjyk44b9r000i48uw5bmgk40c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第二天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/09/快乐暑假第二天/" class="article-date">
  <time datetime="2019-07-09T12:46:57.000Z" itemprop="datePublished">2019-07-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/09/快乐暑假第二天/">快乐暑假第二天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天是暑假培训第二天，今天开始学习js高程，其实前几章我之前就看过了，也做了一些笔记。但是现在再翻开书却发现相当多的内容都已经忘记了，因此我又从头开始看起。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
前三章讲的是一些基本的语法和概念，给我的感受大概是js的语法更加宽松和自由，例如声明变量都是用var来进行、不同类型的值能一起进行运算等等。但其实这些内容都比较琐碎，也比较难一次性就记得清楚，不应该在这部分花太多精力去死记硬背。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
计划明天上午看完第三四章(即语法概念部分和作用域链等)，然后将主要精力放在后面的重点上。
</p>


<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-在-HTML-中使用-JavaScript"><a href="#1-在-HTML-中使用-JavaScript" class="headerlink" title="1. 在 HTML 中使用 JavaScript"></a>1. 在 HTML 中使用 JavaScript</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>主要使用 <script> 元素向 HTML 页面中插入 JavaScript ，而其中又有两种使用方式，包括直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript 文件：</p>
<ul>
<li>直接嵌入代码：此时只需要为 <script> 指定 type 属性，然后直接把代码放在元素内部<ul>
<li>若使用这种方法，代码中不能出现"</script>“字符串，可以使用转义字符”&quot;解决这个问题如：alert(“&lt;/script&gt;”);


<li>包含外部文件：此时要设置 src 属性，属性值就是所指向的文件的地址<ul>
<li>不能再在标签之间包含额外的代码</li>
</ul>
</li>

</p><h2 id="lt-script-gt-其他属性"><a href="#lt-script-gt-其他属性" class="headerlink" title="&lt;script&gt; 其他属性"></a>&lt;script&gt; 其他属性</h2><p>有一些属性很少用或者已经废弃了，以下几个属性平时可能会用得上：</p>
<ul>
<li>async：可选。表示应该立即下载脚本。只对外部脚本文件有效<ul>
<li>异步脚本，表示当前脚本不必等待其他脚本，也不必阻塞文档呈现，目的是不让页面等待脚本下载和执行。但不能保证异步脚本按照在页面中的出现顺序执行</li>
</ul>
</li>
<li>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效<ul>
<li>将延迟脚本放在页面底部是最佳选择</li>
</ul>
</li>
<li>type：可选。表示编写代码使用的脚本语言的内容类型</li>
<li>src：可选。表示包含要执行代码的外部文件</li>
</ul>
<blockquote>
<p>如果不存在 async 和 defer 属性，浏览器会按照 &lt;script&gt; 出现的先后顺序来进行解析</p>
</blockquote>
<h2 id="标签位置"><a href="#标签位置" class="headerlink" title="标签位置"></a>标签位置</h2><p>为了避免各种各样的问题，一般把全部 JavaScript 引用放在<body>元素中页面内容的后面</body></p>
<h2 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><noscript> 元素</noscript></h2><p>用以在不支持 JavaScript 的浏览器中显示替换的内容</p>
<h1 id="2-语法和基本概念"><a href="#2-语法和基本概念" class="headerlink" title="2. 语法和基本概念"></a>2. 语法和基本概念</h1><blockquote>
<p>ECMAScript 语法大量借鉴了类 C 语言的语法，但相比之下更让人感到自由和宽松。</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h4><p>变量、函数名、操作符都区分大小写</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符就是指变量、函数、属性的名字或者函数的参数，有一定的格式规则：</p>
<ol>
<li>第一个字符必须是一个字母、下划线”_”或一个美元符号”$”</li>
<li>其他字符可以是字母、下划线或者数字</li>
</ol>
<p>不能把关键字、保留字等用作标识符。按照惯例，标识符采用驼峰大小写格式。</p>
<h4 id="注释和语句"><a href="#注释和语句" class="headerlink" title="注释和语句"></a>注释和语句</h4><p>注释有两种方式，双斜杠(单行)和斜杠星(多行)。<br>一个语句以分号结尾，分号可以省略，但可能会造成各种各样难以描述的错误。<br>始终在控制语句中使用代码块是个好习惯。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>这一点与之前学习过的 C 语言有着很大的区别， ECMAScript 的变量是松散型的，可以用来保存任何类型的数据，相当于每个变量只是一个占位符，里面放什么数据都没问题。<br>定义变量用 var 操作符。</p>
<ul>
<li>可以在定义的同时初始化变量(未经初始化的变量会保存一个undefined值)</li>
<li>可以修改成类型不同的值，但最好不要这么做</li>
<li>在函数中var的变量是一个局部变量，函数退出后即销毁(可以省略var来创建一个全局变量)</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>5种简单数据类型(基本数据类型)：Undefined、Null、Boolean、Number、String，1种复杂数据类型：Object。<br>不支持任何创建自定义类型的机制，因此所有的值最终都是6种数据类型之一。</p>
<h4 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h4><p>var出来的变量可以是任何类型的数据，因此需要一个用来<strong>检测给定变量的数据类型</strong>的手段。<br><br>对一个值使用typeof操作符后可能会返回某个字符串：</p>
<ul>
<li>“undefined”: 值未定义</li>
<li>“boolean”: 值是布尔值</li>
<li>“string”: 值是字符串</li>
<li>“number”: 值是数值</li>
<li>“object”: 值是对象或null<ul>
<li>特殊值null会被认为是一个空的对象引用</li>
</ul>
</li>
<li>“function”: 值是函数<ul>
<li>从技术角度讲，函数是对象，不是数据类型，但有必要区分函数和其他对象</li>
</ul>
</li>
</ul>
<h4 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h4><p>此类型只有一个特殊值 undefined ，用var声明但未对其加以初始化的变量就保存着undefined值。与显式初始化为 undefined 的效果是一样的。<br><br>但是，<strong>包含 undefined 的变量和未声明的变量还是不一样的</strong>：对于尚未声明过的变量，只能执行typeof操作，且也会返回undefined值。因此，如果能够做到显式地初始化变量，当typeof返回”undefined”时就能够知道被检测的变量是还没有被声明，而不是尚未初始化。</p>
<h4 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h4><p>此类型也只有一个特殊值 null ，从逻辑角度看表示一个<strong>空对象指针</strong>(因此使用typeof检测会返回”object”)。<br><br>可以把准备用来保存对象的变量初始化为null，这样一来，就可以通过检测变量值是否为null来判断该变量是否已经保存了一个对象的引用。<br><br>undefined值是派生自null值的，因此对二者的<strong>相等性测试要返回 true</strong>。</p>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p>该类型有 true 和 false 两个字面值，区分大小写。这两个值与数字值不是一回事，即 true 不一定等于 1 ，flase不一定等于 0 。<br><br><strong>转型函数Boolean( )</strong>:用于将一个值转化为其对应的 Boolean 值，可以对任何类型的值调用，其转换规则如下<br>| 数据类型 | 转换为true的值 | 转换为false的值 |<br>| :- | :- | :- |<br>| Boolean | true | false |<br>| String | 任何非空字符串 | “ “(空字符串) |<br>| Number | 任何非零数值(包括无穷大) | 0和null |<br>| Object | 任何对象 | null |<br>| Undefined | n/a(不适用) | undefined |</p>
<blockquote>
<p>控制流语句 (如 if ) 自动执行 Boolean 转换就是按照上面的规则来转换</p>
</blockquote>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number( ) 类型"></a>Number( ) 类型</h4><p>JavaScript总是会不失时机地<strong>把浮点数转换为整数来保存</strong>，例如小数点后没有数字，或者浮点数本身就是表示一个整数的时候，都会被转换为整数。</p>
<p><strong>e表示法</strong>(科学记数法)：3.125e7 = 3.125E7 = 31250000 (一般会默认将小数点后带有6个0以上的浮点数值转换为e表示法表示的数值)</p>
<p>十进制是最基本的数值字面量格式，因此可以在代码中直接输入十进制数值。在进行算术计算时，八进制和十六进制的数值最终都会转换为十进制数值。</p>
<ul>
<li>八进制：第一位是0，后跟0 ~ 7(如果超出范围，则会按照十进制数值解析)。</li>
<li>十六进制：前两位是0x，后跟0 ~ 9及A ~ F(与标识符不一样，这里的字母大小写均可)。</li>
</ul>
<blockquote>
<p>可以保存+0和-0，但认为二者相等。</p>
</blockquote>
<p>由于计算方式的问题，在进行<strong>浮点数的算术计算时精确度不高</strong>，因此不要做浮点数相应的运算测试如 if ( a + b == 0.3 );</p>
<p>由于内存限制，所能表示的数值是有一定范围的，其中最小的数值保存在 <strong>Number.MIN_VALUE</strong> 中，最大的数值保存在 <strong>Number.MAX_VALUE</strong> 中,超过这两个值的数值表示为 -Infinity 或 Infinity 。<strong>(Infinity不能参与计算)</strong>。<br><br>正负无穷分别保存在 <strong>Number.NEGATIVE_INFINITY</strong> 和 <strong>Number.POSITIVE_INFINITY</strong> 中，用来在在执行极大数值和极小数值时监测监控这些值。</p>
<p><strong>NaN</strong>:用于表示一个本来要返回数值的操作数未返回数值的情况。</p>
<ul>
<li>任何涉及 NaN 的操作都会返回 NaN</li>
<li>NaN 与任何值都不相等，包括它本身</li>
</ul>
<p><strong>isNaN( )函数</strong>：用于检测一个数值是否为 NaN ，如果接收的参数无法转换为数值，就会返回 true。</p>
<p>有3个函数可以把非数值转换为数值：</p>
<ul>
<li>Number( )：适用于任何数据类型<ul>
<li>Boolean值，true和false分别转换为1和0</li>
<li>数字值，只是简单的传入和返回</li>
<li>null值，返回0</li>
<li>undefined，返回NaN</li>
<li>字符串，遵循下列规则<ul>
<li>只包含数字(包括带正负号的情况)，则转换为十进制数(会忽略前导0)</li>
<li>包含有效的浮点格式，则转换为对应的浮点数值(也会忽略前导0)</li>
<li>包含有效的十六进制格式，则转换为相同大小的十进制整数值</li>
<li>空字符串，则转换为0</li>
<li>包含上述格式之外的字符，则转换为NaN</li>
<li>对象，则调用对象的valueOf( )方法，然后依照前面的规则转换返回的值。若转换结果是NaN，则调用对象的toString( )方法，然后再次依照前面的规则转换返回的字符串值</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Number( )函数由于其繁杂性和不合理性，实际使用较少，更常用的是 parseInt( ) 函数和 parseFloat( ) 函数。</p>
</blockquote>
<ul>
<li>parseInt( )：专门由于把字符串转换为数值<ul>
<li>会忽略字符串前面的空格，如果第一个非空格字符不是数字字符或符号，则返回 NaN ( 即对空字符串返回NaN，而Number( )返回0 )</li>
<li>如果第一个非空格字符是数字，则会继续解析下一个字符，直到解析完成或遇到非数字字符</li>
<li>可以提供第二个参数，即转换使用的基数，最好是每次都明确基数</li>
</ul>
</li>
<li>parseFloat( )：也是专门由于把字符串转换为数值<ul>
<li><strong>只解析十进制</strong></li>
<li>字符串中第一个小数点是有效的，后面的无效</li>
<li>按照上面的说法，当字符串包含的是可以解析为整数的数，则会返回整数</li>
</ul>
</li>
</ul>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String( ) 类型"></a>String( ) 类型</h4><p>字符串由双引号或单引号来表示。<br><br><strong>转义序列</strong>：作为一个字符来解析。<br><br><strong>length 属性</strong>:任何字符串都可以通过访问此属性来取得其长度。<br><br>字符串是不可变的，即要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。<br><br>将一个值转换为字符串有2种方式：</p>
<ul>
<li>toString( ) 方法：<ul>
<li>数值、布尔值、对象和字符都有该方法，但null和undefined没有</li>
<li>一般不用传递参数，也可以传递输出数值的基数(默认以十进制返回)</li>
</ul>
</li>
<li>转型函数 String( )：能够将任何类型的值转换为字符串<ul>
<li>null 和 undefined 分别转换为 “null” 和 “undefined”</li>
<li>如果值有toString( ) 方法则调用该方法</li>
</ul>
</li>
</ul>
<h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><p>对象就是一组数据和功能的集合，可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。<br><br>也可以创建自定义对象。<br><br>Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor：保存着用于创建当前对象的函数</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在，其中，作为参数的属性名(propertyName)必须以字符串形式指定，例如：o.hasOwnProperty(“name”);</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型(第5章将讨论原型)</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语句来枚，作为参数的属性名必须以字符串形式指定</li>
<li>toLocaleString( )：返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString( ):返回对象的字符串表示</li>
<li>valueOf( )：返回对象的字符串、数值或布尔值表示，通常与 toString( ) 方法的返回值相同</li>
</ul>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>即只能操作一个值的操作符<br><strong>递增递减操作符</strong><br><strong>一元加和减操作符</strong></p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p><strong>按位非 (NOT)</strong></p>
<p><strong>按位与 (AND)</strong></p>
<p><strong>按位或 (OR)</strong></p>
<p><strong>按位异或 (XOR)</strong></p>
<p><strong>左移</strong></p>
<p><strong>有符号的右移</strong></p>
<p><strong>无符号右移</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/09/快乐暑假第二天/" data-id="cjyk44b9d000b48uwkinmxm94" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第一天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/快乐暑假第一天/" class="article-date">
  <time datetime="2019-07-08T10:51:01.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/快乐暑假第一天/">快乐暑假第一天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>快乐的暑假开始了！！！今天主要学习了git相关的一些东西，以及搭建了自己的博客，虽然在我出色的操作下，遇到了各种各样的奇葩问题</p>
</blockquote>
<h1 id="一、-git相关操作"><a href="#一、-git相关操作" class="headerlink" title="一、 git相关操作"></a>一、 git相关操作</h1><blockquote>
<p>在多人协作完成一个项目的情况下，如果只靠将文件传来传去这种老方法是十分麻烦的，而且人一多就极其容易发生各种各样的错误。因此在多人协作时，需要依靠git这种卓越的工具</p>
</blockquote>
<ol>
<li><p><strong>将远程库的内容克隆到本地</strong><br></p>
<p> 使用命令 <strong>git clone</strong> ，后跟从GitHub复制来的地址</p>
</li>
<li><p><strong>创建自己的分支</strong></p>
<blockquote>
<p>为了避免各种各样的错误，应该创建自己的分支，并在自己的分支里进行各种各样的修改和操作</p>
</blockquote>
<p> 使用命令 <strong>git checkout -b</strong> ,后跟自己分支的名字，此时<strong>head</strong>的指向从<strong>master</strong>变成自己创建的分支</p>
</li>
<li><p><strong>将修改后的文件添加到暂存区</strong></p>
<blockquote>
<p>文件修改后需要先 add 到暂存区，否则无法 commit 到 master 上，可以 add 多个文件之后再 commit</p>
</blockquote>
<p> 使用命令 <strong>git add</strong> ，后跟要添加的文件名或者”.”(表示所有文件)</p>
</li>
<li><p><strong>将暂存区中的文件提交到分支上</strong></p>
<p> 使用命令 <strong>git commit -m “注释”</strong></p>
</li>
<li><p><strong>抓取远程库的文件资源</strong></p>
<blockquote>
<p>自己修改完文件后，可能团队的其他人在此期间内也修改了文件并且已经提交到远程库上，因此在将本地分支推送到远程库之前，为了更新资源避免错误，需要将远程库上的资源抓取到本地</p>
</blockquote>
<p> 使用命令 <strong>git pull</strong></p>
</li>
<li><p><strong>合并分支</strong></p>
<p> 先使用 <strong>git checkout master</strong> 让 head 指向 master 分支，然后使用 <strong>git merge <name></name></strong> 来合并分支</p>
</li>
<li><p><strong>将本地分支推送到远程库中</strong>、</p>
<blockquote>
<p>本地分支他人是不可见的，因此需要将本地分支推送到远程库中</p>
</blockquote>
<p> 使用命令 <strong>git push</strong></p>
</li>
</ol>
<h1 id="二、-hexo博客"><a href="#二、-hexo博客" class="headerlink" title="二、 hexo博客"></a>二、 hexo博客</h1><ul>
<li><strong>hexo n “title”</strong> :创建一篇标题为 title 的博客</li>
<li><strong>hexo g</strong> :生成静态文章</li>
<li><strong>hexo s</strong> :启动本地服务器，用于预览主题</li>
<li><strong>hexo d</strong> :自动生成网站静态文件，并部署到设定的仓库</li>
</ul>
<h1 id="三、-小结"><a href="#三、-小结" class="headerlink" title="三、 小结"></a>三、 小结</h1><ul>
<li>今天是培训第一天，我格外适应这种一坐几个小时都不用动的生活</li>
<li>今天了解了git的一些基本操作，但还不是很熟练，还需要多练习几次</li>
<li>今天开始贯彻落实每天运动的基本方针，强身健体，提神醒脑</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/快乐暑假第一天/" data-id="cjyk44b8y000248uwx3eq48jx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-的" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/的/" class="article-date">
  <time datetime="2019-07-08T09:45:35.000Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/的/">的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>12121212</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/的/" data-id="cjyk44b96000948uwfy5rfx26" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/08/hello-world/" class="article-date">
  <time datetime="2019-07-08T09:42:59.273Z" itemprop="datePublished">2019-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/08/hello-world/" data-id="cjyk44b8v000148uwxj44rife" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/26/快乐暑假第十七天——开始学习nodejs/">快乐暑假第十七天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第十六天——继续做Bolo/">快乐暑假第十六天——继续做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/24/快乐暑假第十五天——开始做Bolo/">快乐暑假第十五天——开始做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/23/快乐暑假第十四天——学习jQuery/">快乐暑假第十四天——学习jQuery</a>
          </li>
        
          <li>
            <a href="/2019/07/22/快乐暑假第十三天/">快乐暑假第十三天</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>