<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Lee&#39;s blogs">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lee&#39;s blogs">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-快乐暑假第13天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/快乐暑假第13天/" class="article-date">
  <time datetime="2019-07-22T12:21:09.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/快乐暑假第13天/">快乐暑假第13天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
今晚还看了一些jq，明天再大概看一下。设计差不多要出稿了，准备开始实践了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="9-async-函数"><a href="#9-async-函数" class="headerlink" title="9. async 函数"></a>9. async 函数</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>
<h2 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9.1 语法"></a>9.1 语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p>async函数返回一个 Promise 对象。</p>
<ul>
<li>内部return语句返回的值，会<strong>成为then方法回调函数的参数</strong>。</li>
<li>async函数内部抛出错误，会导致返回的 Promise 对象<strong>变为reject状态</strong>。抛出的错误对象<strong>会被catch方法回调函数接收到</strong>。</li>
</ul>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async函数返回的 Promise 对象，必须<strong>等到内部所有await命令后面的 Promise 对象执行完</strong>，才会发生状态改变，然后执行then方法指定的回调函数，除非<strong>遇到return语句</strong>或者<strong>抛出错误</strong>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<strong>await命令后面是一个 Promise 对象</strong>，返回该对象的结果。如果不是 Promise 对象，就<strong>直接返回对应的值</strong>。如果后面是一个thenable对象（即定义then方法的对象），那么await会<strong>将其等同于 Promise 对象</strong>。</p>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<ul>
<li>任何一个await语句后面的 Promise 对象变为reject状态，整个async函数都会中断执行。</li>
<li>如果不想中断后面语句的执行，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>
<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<ul>
<li>防止出错的方法，也是将其放在try…catch代码块之中。</li>
<li>如果有多个await命令，可以统一放在try…catch结构中。</li>
</ul>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个操作互相独立，这样做比较耗时</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>

<ul>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li>async 函数可以保留运行堆栈。</li>
</ul>
<h1 id="10-Class-的基本语法"><a href="#10-Class-的基本语法" class="headerlink" title="10. Class 的基本语法"></a>10. Class 的基本语法</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。<strong>Object.assign方法</strong>可以很方便地一次向类添加多个方法。</p>
<p><strong>类的内部所有定义的方法，都是不可枚举的</strong>。这一点与 ES5 的行为不一致。</p>
<p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。<strong>一个类必须有constructor方法</strong>，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<ul>
<li>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象(但会导致实例对象改变)。</li>
</ul>
<p>类必须使用new调用，否则会报错。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<ul>
<li>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</li>
</ul>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Square类的方法名getArea，是从表达式得到的。</li>
</ul>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，<strong>这个类只能用MyClass引用</strong>。</li>
<li>如果类的内部没用到的话，可以省略Me。</li>
</ul>
<p>采用 Class 表达式，可以写出<strong>立即执行的 Class</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用use strict指定运行模式。</li>
<li><strong>类不存在变量提升</strong>（hoist），这一点与 ES5 完全不同。</li>
<li>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</li>
<li>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ol>
<h2 id="10-2-静态方法"><a href="#10-2-静态方法" class="headerlink" title="10.2 静态方法"></a>10.2 静态方法</h2><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果在一个方法前，<strong>加上static关键字，就表示该方法不会被实例继承</strong>，而是直接通过类来调用，这就称为“静态方法”。</p>
<ul>
<li>如果静态方法包含this关键字，这个this指的是类，而不是实例。</li>
<li>静态方法可以与非静态方法重名。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>静态方法也是可以从super对象上调用的。</li>
</ul>
<h2 id="10-3-实例属性的新写法"><a href="#10-3-实例属性的新写法" class="headerlink" title="10.3 实例属性的新写法"></a>10.3 实例属性的新写法</h2><p>实例属性除了定义在constructor()方法里面的this上面，也可以<strong>定义在类的最顶层</strong>。</p>
<h2 id="10-4-静态属性"><a href="#10-4-静态属性" class="headerlink" title="10.4 静态属性"></a>10.4 静态属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</li>
</ul>
<h1 id="11-Class-的继承"><a href="#11-Class-的继承" class="headerlink" title="11. Class 的继承"></a>11. Class 的继承</h1><p>Class 可以通过extends关键字实现继承。</p>
<ul>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</li>
<li>如果子类没有定义constructor方法，这个方法会被默认添加。因此不管有没有显式定义，任何一个子类都有constructor方法。</li>
<li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</li>
<li>父类的静态方法，也会被子类继承。</li>
</ul>
<h2 id="11-1-Object-getPrototypeOf"><a href="#11-1-Object-getPrototypeOf" class="headerlink" title="11.1 Object.getPrototypeOf( )"></a>11.1 Object.getPrototypeOf( )</h2><p>Object.getPrototypeOf方法可以用来从子类上获取父类。<br>因此可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="11-2-super-关键字"><a href="#11-2-super-关键字" class="headerlink" title="11.2 super 关键字"></a>11.2 super 关键字</h2><p>super作为函数调用时，代表父类的构造函数。<strong>作为函数时，super()只能用在子类的构造函数之中</strong>，用在其他地方就会报错。</p>
<p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h1 id="12-Module-的语法"><a href="#12-Module-的语法" class="headerlink" title="12. Module 的语法"></a>12. Module 的语法</h1><p>ES6 的模块自动采用严格模式。</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</p>
<p>模块功能主要由两个命令构成：export和import：</p>
<ul>
<li><strong>export命令用于规定模块的对外接口</strong>。</li>
<li><strong>import命令用于输入其他模块提供的功能</strong>。</li>
</ul>
<h2 id="12-1-export-命令"><a href="#12-1-export-命令" class="headerlink" title="12.1 export 命令"></a>12.1 export 命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果要<strong>让外部能够读取模块内部的某个变量</strong>，就必须使用export关键字输出该变量。</p>
<ul>
<li>export命令除了输出变量，还可以输出函数或类。</li>
<li>通常情况下，export输出的变量就是本来的名字，但是可以<strong>使用as关键字重命名</strong>。</li>
<li>export语句输出的接口，与其对应的值是<strong>动态绑定关系</strong>，即通过该接口，可以取到模块内部实时的值。</li>
<li>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。</li>
</ul>
<h2 id="12-2-import-命令"><a href="#12-2-import-命令" class="headerlink" title="12.2 import 命令"></a>12.2 import 命令</h2><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以<strong>通过import命令加载这个模块</strong>。</p>
<ul>
<li>使用as关键字，将输入的变量重命名。</li>
<li>import命令输入的变量都是<strong>只读</strong>的，因为它的本质是输入接口。</li>
<li>import命令<strong>具有提升效果</strong>，会提升到整个模块的头部，首先执行。(import命令是编译阶段执行的，在代码运行之前)</li>
<li>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li>
</ul>
<h2 id="12-3模块的整体加载"><a href="#12-3模块的整体加载" class="headerlink" title="12.3模块的整体加载"></a>12.3模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即<strong>用星号（*）指定一个对象，所有输出值都加载在这个对象上面</strong>。</p>
<ul>
<li>模块整体加载所在的那个对象，应该是<strong>可以静态分析</strong>的，所以<strong>不允许运行时改变</strong>。</li>
</ul>
<h2 id="12-4-export-default-命令"><a href="#12-4-export-default-命令" class="headerlink" title="12.4 export default 命令"></a>12.4 export default 命令</h2><p>export default命令能为模块指定默认输出。</p>
<ul>
<li>这时import命令后面，不使用大括号。</li>
<li>export default命令也可以用在非匿名函数前。</li>
<li>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</li>
<li>因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</li>
</ul>
<h2 id="12-5-export-与-import-的复合写法"><a href="#12-5-export-与-import-的复合写法" class="headerlink" title="12.5 export 与 import 的复合写法"></a>12.5 export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>foo和bar实际上并没有被导入当前模块</li>
</ul>
<h1 id="13-Module-的加载实现"><a href="#13-Module-的加载实现" class="headerlink" title="13. Module 的加载实现"></a>13. Module 的加载实现</h1><h2 id="13-1-浏览器加载"><a href="#13-1-浏览器加载" class="headerlink" title="13.1 浏览器加载"></a>13.1 浏览器加载</h2><p>浏览器允许脚本异步加载，有两种异步加载的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是“渲染完再执行”，async是“下载完就执行”。</li>
<li>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</li>
</ul>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入<strong>type=”module”属性</strong>。</p>
<ul>
<li>浏览器对于带有 type=”module” 的&lt;script&gt;，都是异步加载，<strong>等同于打开了&lt;script&gt;标签的defer属性</strong>。（会按照出现顺序执行）</li>
<li>async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。（此时<strong>不会按照在页面出现的顺序执行</strong>，而是只要该模块加载完成，就执行该模块）</li>
</ul>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。对于外部的模块脚本（上例是foo.js），有几点需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式。</li>
<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li>
<li>在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/快乐暑假第13天/" data-id="ck06ipghf000g9kuwq3u1em4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第12天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/快乐暑假第12天/" class="article-date">
  <time datetime="2019-07-21T13:33:40.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/21/快乐暑假第12天/">快乐暑假第12天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p><strong>Set函数接受数组作为参数</strong>是一种去除数组重复成员的方法。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>
<p><strong>Array.from方法可以将 Set 结构转为数组</strong>，是去除数组重复成员的另一种方法。</p>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员：</p>
<ul>
<li><strong>Set.prototype.keys( )</strong>：返回键名的遍历器</li>
<li><strong>Set.prototype.values( )</strong>：返回键值的遍历器</li>
<li><strong>Set.prototype.entries( )</strong>：返回键值对的遍历器</li>
<li><strong>Set.prototype.forEach( )</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>Set的遍历顺序就是插入顺序。</strong></p>
<h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<strong>keys方法和values方法的行为完全一致</strong>。entries方法返回的遍历器，同时包括键名和键值。</p>
<p>可以省略values方法，直接用for…of循环遍历 Set。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>用于对每个成员执行某种操作，没有返回值。</p>
<p><strong>forEach方法的参数就是一个处理函数</strong>。</p>
<h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>数组的map和filter方法也可以间接用于 Set ，因此<strong>使用 Set 可以很容易地实现并集、交集和差集</strong>。</p>
<h2 id="7-2-WeakSet"><a href="#7-2-WeakSet" class="headerlink" title="7.2 WeakSet"></a>7.2 WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的<strong>成员只能是对象</strong>。</p>
<p>WeakSet 中的对象都是<strong>弱引用</strong>，如果其他对象都不再引用某一对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。因此 <strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。</p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数(数组的成员只能是对象)，该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<p>WeakSet 结构有以下三个方法：</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet 没有size属性，<strong>没有办法遍历它的成员</strong>(由于弱引用特性，不支持遍历)。</p>
<h2 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h2><p>Map 数据结构类似于对象，是<strong>键值对的集合</strong>，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作键</strong>。</p>
<p>作为构造函数，Map 也可以<strong>接受一个数组作为参数</strong>。该数组的成员是一个个表示键值对的数组。</p>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法：</p>
<ul>
<li><strong>size 属性</strong>：返回 Map 结构的成员总数。</li>
<li><strong>Map.prototype.set(key, value)</strong>：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><strong>Map.prototype.get(key)</strong>：读取key对应的键值，如果找不到key，返回undefined。</li>
<li><strong>Map.prototype.has(key)</strong>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><strong>Map.prototype.delete(key)</strong>：删除某个键，返回true。如果删除失败，返回false。</li>
<li><strong>Map.prototype.clear()</strong>：清除所有成员，没有返回值。</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li><strong>Map.prototype.keys()</strong>：返回键名的遍历器。</li>
<li><strong>Map.prototype.values()</strong>：返回键值的遍历器。</li>
<li><strong>Map.prototype.entries()</strong>：返回所有成员的遍历器。</li>
<li><strong>Map.prototype.forEach()</strong>：遍历 Map 的所有成员。</li>
</ul>
<p><strong>Map 的遍历顺序就是插入顺序。</strong></p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul>
<li>数组与Map的相互转换</li>
<li>对象与Map的相互转换</li>
<li>JSON与Map的相互转换</li>
</ul>
<h2 id="7-4-WeakMap"><a href="#7-4-WeakMap" class="headerlink" title="7.4 WeakMap"></a>7.4 WeakMap</h2><h1 id="8-Promise-对象"><a href="#8-Promise-对象" class="headerlink" title="8. Promise 对象"></a>8. Promise 对象</h1><h2 id="8-1-Promise-的含义"><a href="#8-1-Promise-的含义" class="headerlink" title="8.1 Promise 的含义"></a>8.1 Promise 的含义</h2><p>Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>Promise对象有以下两个特点：</p>
<ul>
<li><strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。(这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的)</li>
</ul>
<h2 id="8-2-基本用法"><a href="#8-2-基本用法" class="headerlink" title="8.2 基本用法"></a>8.2 基本用法</h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，<strong>不用自己部署</strong>。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并<strong>将异步操作的结果，作为参数传递出去</strong>。</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<p>如果<strong>调用resolve函数和reject函数时带有参数</strong>，那么它们的参数会被<strong>传递给回调函数</strong>。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<ul>
<li>then方法可以接受两个回调函数作为参数：第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用(可选)。</li>
<li>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</li>
</ul>
<h2 id="8-3-Promise-prototype-then"><a href="#8-3-Promise-prototype-then" class="headerlink" title="8.3 Promise.prototype.then( )"></a>8.3 Promise.prototype.then( )</h2><p>then方法<strong>返回的是一个新的Promise实例</strong>，因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h2 id="8-4-Promise-prototype-catch"><a href="#8-4-Promise-prototype-catch" class="headerlink" title="8.4 Promise.prototype.catch( )"></a>8.4 Promise.prototype.catch( )</h2><p>是.then(null, rejection)或.then(undefined, rejection)的别名，<strong>用于指定发生错误时的回调函数</strong>。</p>
<p>Promise 对象的错误<strong>具有“冒泡”性质</strong>，会一直向后传递，直到被捕获为止。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），<strong>总是使用catch方法</strong>。catch方法返回的还是一个 Promise 对象，因此<strong>后面还可以接着调用then方法</strong>。</p>
<ul>
<li>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即<strong>不会有任何反应</strong>。</li>
</ul>
<h2 id="8-5-Promise-prototype-finally"><a href="#8-5-Promise-prototype-finally" class="headerlink" title="8.5 Promise.prototype.finally( )"></a>8.5 Promise.prototype.finally( )</h2><p>用于<strong>指定不管 Promise 对象最后状态如何，都会执行的操作</strong>。</p>
<ul>
<li>finally方法的回调函数<strong>不接受任何参数</strong>，故无法知道前面的 Promise 状态到底是fulfilled还是rejected。因此finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
<li>finally本质上是then方法的特例。</li>
<li>finally方法总是会返回原来的值。</li>
</ul>
<h2 id="8-6-Promise-all"><a href="#8-6-Promise-all" class="headerlink" title="8.6 Promise.all( )"></a>8.6 Promise.all( )</h2><p>Promise.all方法用于<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>接受一个数组作为参数，p1、p2、p3都是 Promise 实例。(如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理)</li>
<li>p的状态由p1、p2、p3决定：<ul>
<li>只有p1、p2、p3的状态<strong>都变成fulfilled</strong>，p的状态才会变成fulfilled，此时p1、p2、p3的<strong>返回值组成一个数组，传递给p的回调函数</strong>。</li>
<li>只要p1、p2、p3之中<strong>有一个被rejected</strong>，p的状态就变成rejected，此时<strong>第一个被reject的实例的返回值，会传递给p的回调函数</strong>。</li>
</ul>
</li>
<li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</li>
</ul>
<h2 id="8-7-Promise-race"><a href="#8-7-Promise-race" class="headerlink" title="8.7 Promise.race( )"></a>8.7 Promise.race( )</h2><p>Promise.race方法同样是<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要p1、p2、p3之中<strong>有一个实例率先改变状态，p的状态就跟着改变</strong>。那个<strong>率先改变的 Promise 实例的返回值，就传递给p的回调函数</strong>。</li>
<li>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</li>
</ul>
<h2 id="8-8-Promise-resolve"><a href="#8-8-Promise-resolve" class="headerlink" title="8.8 Promise.resolve( )"></a>8.8 Promise.resolve( )</h2><p>Promise.resolve方法能够<strong>将现有对象转为 Promise 对象</strong>。</p>
<p>Promise.resolve方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<strong>Promise 实例</strong>：不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个<strong>thenable对象</strong>：(thenable对象指的是具有then方法的对象)会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</li>
<li>参数<strong>不是具有then方法的对象，或不是对象</strong>:返回一个新的 Promise 对象，状态为resolved。（Promise.resolve方法的参数，会同时传给回调函数，回调函数会立即执行）</li>
<li><strong>不带有任何参数</strong>：直接返回一个resolved状态的 Promise 对象。<ul>
<li>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li>
</ul>
</li>
</ul>
<h2 id="8-9-Promise-reject"><a href="#8-9-Promise-reject" class="headerlink" title="8.9 Promise.reject( )"></a>8.9 Promise.reject( )</h2><p>Promise.reject(reason)方法也会<strong>返回一个状态为rejected的新的 Promise 实例</strong>。</p>
<ul>
<li>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</li>
</ul>
<h1 id="9-Generator-函数的语法"><a href="#9-Generator-函数的语法" class="headerlink" title="9. Generator 函数的语法"></a>9. Generator 函数的语法</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/快乐暑假第12天/" data-id="ck06ipghf000f9kuw30cikfm9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第11天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/快乐暑假第11天/" class="article-date">
  <time datetime="2019-07-19T14:02:19.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/快乐暑假第11天/">快乐暑假第11天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义</li>
<li>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中<ul>
<li>如果不需要换行，可以使用trim方法消除它</li>
</ul>
</li>
<li>模板字符串中嵌入变量，需要将变量名写在${}之中<ul>
<li>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</li>
<li>还能调用函数，如果大括号中的值不是字符串，将按照一般的规则转为字符串</li>
<li>如果模板字符串中的变量没有声明，将报错</li>
<li>实际上模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出</li>
</ul>
</li>
<li>模板字符串还能嵌套</li>
<li>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</li>
</ul>
<h1 id="4-函数的扩展"><a href="#4-函数的扩展" class="headerlink" title="4. 函数的扩展"></a>4. 函数的扩展</h1><h2 id="4-1-箭头函数"><a href="#4-1-箭头函数" class="headerlink" title="4.1 箭头函数"></a>4.1 箭头函数</h2><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果箭头函数不需要参数或需要多个参数，就使用一个<strong>圆括号代表参数部分</strong></li>
<li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且<strong>使用return语句返回</strong></li>
<li>由于大括号被解释为代码块，所以如果箭头函数直接<strong>返回一个对象，必须在对象外面加上括号</strong>，否则会报错</li>
<li>箭头函数可以与变量解构结合使用：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数的一个用处是简化回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ol>
<li>函数体内的<strong>this对象，就是定义时所在的对象</strong>，而不是使用时所在的对象。</li>
<li><strong>不可以当作构造函数</strong>，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li><strong>不可以使用arguments对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li><strong>不可以使用yield命令</strong>，因此箭头函数不能用作 Generator 函数。</li>
</ol>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + type  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</li>
</ul>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是<strong>箭头函数根本没有自己的this，导致内部的this就是外层代码块的this</strong>。正是因为它没有this，所以也就<strong>不能用作构造函数</strong>。</p>
<h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数：</p>
<ol>
<li>定义对象的方法，且该方法内部包括this</li>
<li>需要动态this的时候，也不应使用箭头函数</li>
</ol>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这个函数，可以使用箭头函数改写。</span></span><br><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="function">(<span class="params">&#123;into: (array</span>) =&gt;</span> <span class="function">(<span class="params">&#123;after: (afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-rest-参数"><a href="#4-2-rest-参数" class="headerlink" title="4.2 rest 参数"></a>4.2 rest 参数</h2><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。</p>
<ul>
<li>rest 参数搭配的变量是一个数组，该变量<strong>将多余的参数放入数组中</strong>。</li>
<li>arguments对象不是数组，而是一个类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。<strong>rest 参数是一个真正的数组，数组特有的方法都可以使用</strong>。</li>
<li>rest 参数之后不能再有其他参数（即<strong>只能是最后一个参数</strong>），否则会报错。</li>
<li><strong>函数的length属性，不包括 rest 参数</strong>。</li>
</ul>
<h2 id="4-3-数组实例的-includes"><a href="#4-3-数组实例的-includes" class="headerlink" title="4.3 数组实例的 includes( )"></a>4.3 数组实例的 includes( )</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。</p>
<h1 id="5-数组的扩展"><a href="#5-数组的扩展" class="headerlink" title="5. 数组的扩展"></a>5. 数组的扩展</h1><h2 id="5-1-扩展运算符"><a href="#5-1-扩展运算符" class="headerlink" title="5.1 扩展运算符"></a>5.1 扩展运算符</h2><p>扩展运算符是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<ul>
<li>扩展运算符与正常的函数参数可以结合使用</li>
<li>扩展运算符后面还可以放置表达式</li>
<li>如果扩展运算符后面是一个空数组，则不产生任何效果</li>
<li>只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错</li>
</ul>
<h1 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h1><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值，它是 JavaScript 语言的第七种数据类型。</p>
<ul>
<li>Symbol函数前不能使用new命令，因为生成的 Symbol 是一个原始类型的值，不是对象。它是一种类似于字符串的数据类型。</li>
<li>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。<ul>
<li>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</li>
<li>相同参数的Symbol函数的返回值是不相等的。</li>
</ul>
</li>
<li>Symbol 值不能与其他类型的值进行运算。</li>
<li>Symbol 值可以显式转为字符串。</li>
<li>Symbol 值也可以转为布尔值，但是不能转为数值。</li>
</ul>
<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/快乐暑假第11天/" data-id="ck06ipghd000d9kuw2lln99ut" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第10天——学习ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/快乐暑假第10天——学习ES6/" class="article-date">
  <time datetime="2019-07-18T13:04:59.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/快乐暑假第10天——学习ES6/">快乐暑假第10天——学习ES6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
用let来声明变量能避免很多由于变量提升带来的问题，相应地，使用限制也会增加。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用const命令来声明一个复杂变量时要特别注意，const只能保证指针指向不变，但变量却不受控制，可以添加新的属性方法，但是也有可能会因为疏忽而导致错误。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
不允许重复声明指的是不允许在同一级作用域中重复声明同一变量，而由于let命令和块级作用域的存在，在两层不同的作用域内声明同名变量是完全可以的，并且二者相互独立，不会互相影响。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">

</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h1><h2 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了let命令，用来声明变量。用法类似于var，但是<strong>所声明的变量，只在let命令所在的代码块内有效。</strong></p>
<ul>
<li><p>for循环的计数器，就很合适使用let命令。在for循环内定义的计数器变量不会影响到外部变量。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量(JavaScript 引擎内部会记住上一轮循环的值)。</li>
<li>for循环设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</li>
</ul>
</li>
</ul>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>let声明的变量一定要在<strong>声明后使用</strong>，否则报错。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内<strong>存在let命令</strong>，它所声明的变量就“绑定”（binding）这个区域，<strong>不受外部的影响</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就<strong>形成了封闭作用域</strong>。凡是在声明之前就使用这些变量，就会报错。</li>
<li>语法上，称为“暂时性死区”。</li>
</ul>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作：</p>
<ul>
<li>如果在用let声明的变量之前对其使用typeOf，则会报错</li>
<li>如果一个变量根本没有被声明，使用typeof反而不会报错(在没有let之前，typeof运算符是百分之百安全的)</li>
</ul>
<p>有些“死区”比较隐蔽，不太容易发现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = x;  <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;  <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在变量x的声明语句还没有执行完成前，就去取x的值，导致报错“x 未定义”</li>
</ul>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。因此<strong>不能在函数内部重新声明参数</strong>。</p>
<h2 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h2><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景：</p>
<ul>
<li>内层变量可能会覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>let实际上为 JavaScript 新增了块级作用域，外层代码块不受内层代码块的影响。</p>
<p>块级作用域必须有<strong>大括号</strong>。</p>
<p>块级作用域的出现，使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。</p>
<p>块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<p>考虑到环境导致的行为差异太大，应该<strong>避免在块级作用域内声明函数</strong>。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>const声明一个<strong>只读</strong>的常量，一旦声明，常量的值就不能改变。这意味着，const一旦声明变量，就必须<strong>立即初始化</strong>，不能留到以后赋值。</p>
<p>与let特性相似：</p>
<ul>
<li>只在声明所在的块级作用域内有效。</li>
<li>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</li>
<li>const声明的常量，也与let一样不可重复声明。</li>
</ul>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
<ul>
<li><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p>
</li>
<li><p>对于复合类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const<strong>只能保证这个指针是固定的</strong>（即总是指向另一个固定的地址），至于它<strong>指向的数据结构是不是可变的，就完全不能控制了</strong>。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行，数组本身是可写的</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错，不能改变指针的指向</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果真的想将对象冻结，应该使用Object.freeze方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>;     <span class="comment">// 常规模式时不起作用；严格模式时会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>var命令和function命令、let命令和const命令、import命令和class命令。</p>
<h2 id="1-4-顶层对象的属性"><a href="#1-4-顶层对象的属性" class="headerlink" title="1.4 顶层对象的属性"></a>1.4 顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的，这带来了各种各样的问题。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<strong>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</strong>。</p>
<h2 id="1-5-globalThis-对象"><a href="#1-5-globalThis-对象" class="headerlink" title="1.5 globalThis 对象"></a>1.5 globalThis 对象</h2><p>在有一个提案，在语言标准的层面，<strong>引入globalThis作为顶层对象</strong>。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。</p>
<p>垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。</p>
<h1 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h1><h2 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中<strong>提取值</strong>，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</li>
<li>本质上，这种写法属于 <strong>“模式匹配”</strong> ，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</li>
</ul>
<p>如果<strong>解构不成功</strong>，变量的值就等于undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>以上两种情况都属于解构不成功，foo的值都会等于undefined。</li>
</ul>
<p>另一种情况是<strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面两个例子，都属于不完全解构，但是可以成功。</li>
</ul>
<p>如果等号的右边不是数组（严格地说，不是可遍历的结构），那么将会报错。</p>
<p>事实上，只要某种数据结构<strong>具有 Iterator 接口</strong>，都可以采用数组形式的解构赋值。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值<strong>允许指定默认值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>

<p>ES6 内部<strong>使用严格相等运算符（===）</strong>，判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果默认值是一个表达式，那么这个表达式是<strong>惰性求值</strong>的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>因为x能取到值，所以函数f根本不会执行。</li>
</ul>
<p>默认值可以引用解构赋值的其他变量，但该变量<strong>必须已经声明</strong>。</p>
<h2 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，<strong>变量必须与属性同名</strong>，才能取到正确的值。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再<strong>赋给对应的变量</strong>。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</li>
</ul>
<p>与数组一样，解构也<strong>可以用于嵌套结构的对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;    <span class="comment">//foo这时等于undefined，再取子属性就会报错</span></span><br></pre></td></tr></table></figure>

<p>对象的解构赋值<strong>可以取到继承的属性</strong>。</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。默认值生效的条件是，<strong>对象的属性值严格等于undefined</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有<strong>不将大括号写在行首</strong>，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>解构赋值允许等号左边的模式之中，不放置任何变量名。</p>
</li>
<li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-字符串的解构赋值"><a href="#2-3-字符串的解构赋值" class="headerlink" title="2.3 字符串的解构赋值"></a>2.3 字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-数值和布尔值的解构赋值"><a href="#2-4-数值和布尔值的解构赋值" class="headerlink" title="2.4 数值和布尔值的解构赋值"></a>2.4 数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就<strong>先将其转为对象</strong>。由于<strong>undefined和null无法转为对象</strong>，所以对它们进行解构赋值，都会报错。</p>
<h2 id="2-5-函数参数的解构赋值"><a href="#2-5-函数参数的解构赋值" class="headerlink" title="2.5 函数参数的解构赋值"></a>2.5 函数参数的解构赋值</h2><h2 id="2-6-圆括号问题"><a href="#2-6-圆括号问题" class="headerlink" title="2.6 圆括号问题"></a>2.6 圆括号问题</h2><p>建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号：</p>
<ol>
<li>变量声明语句</li>
<li>函数参数</li>
<li>赋值语句的模式</li>
</ol>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<h2 id="2-7-用途"><a href="#2-7-用途" class="headerlink" title="2.7 用途"></a>2.7 用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数参数的定义</li>
</ol>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<ol start="4">
<li>提取 JSON 数据</li>
<li>函数参数的默认值</li>
<li>遍历 Map 结构</li>
<li>输入模块的指定方法</li>
</ol>
<h1 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h1><h2 id="3-5-模板字符串"><a href="#3-5-模板字符串" class="headerlink" title="3.5 模板字符串"></a>3.5 模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/快乐暑假第10天——学习ES6/" data-id="ck06ipghe000e9kuwz5vp9n79" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第9天——学习移动端网页制作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/快乐暑假第9天——学习移动端网页制作/" class="article-date">
  <time datetime="2019-07-17T13:35:49.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/快乐暑假第9天——学习移动端网页制作/">快乐暑假第9天——学习移动端网页制作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
用vw和vh能很好地实现响应式布局，但是这两个单位的兼容性不强，只有较新版本的浏览器才能使用。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
移动端的网页与PC端相比，少了鼠标悬浮和鼠标移开等事件，多了触摸事件，可以用监听器来对touchstart、touchmove和touchend进行监听。要想让某个元素随手指移动而移动，可以监听touchstart事件，当手指触碰到屏幕时获取此时的位置。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
要想让某个元素随手指移动而移动，可以监听touchstart事件，当手指触碰到屏幕时通过clientX和clientY属性获取此时的位置；监听touchmove事件，随时获取此时的位置，然后计算出位移，再进行移动。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-vw、vh、vmin、vmax-简介"><a href="#1-vw、vh、vmin、vmax-简介" class="headerlink" title="1. vw、vh、vmin、vmax 简介"></a>1. vw、vh、vmin、vmax 简介</h1><p>这些单位是一种视窗单位，也是相对单位(相对于视窗)。</p>
<ul>
<li>视窗(Viewport)是浏览器实际显示内容的区域，即不包括工具栏和按钮的网页浏览器。</li>
<li>具体描述：<ul>
<li><strong>vw</strong>：视窗宽度的百分比（1vw 代表视窗的宽度为 1%）</li>
<li><strong>vh</strong>：视窗高度的百分比</li>
<li><strong>vmin</strong>：当前 vw 和 vh 中较小的一个值</li>
<li><strong>vmax</strong>：当前 vw 和 vh 中较大的一个值</li>
</ul>
</li>
</ul>
<h2 id="vw、vh-与百分比-的区别"><a href="#vw、vh-与百分比-的区别" class="headerlink" title="vw、vh 与百分比 % 的区别"></a>vw、vh 与百分比 % 的区别</h2><ul>
<li>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的</li>
<li>vw、vh <strong>能够直接获取高度</strong>，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的</li>
</ul>
<h2 id="vmin、vmax-用处"><a href="#vmin、vmax-用处" class="headerlink" title="vmin、vmax 用处"></a>vmin、vmax 用处</h2><p>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的(因为两种状态下视窗宽高会发生变化)。此时就可以用 vmin 和 vmax <strong>使得文字大小在横竖屏下保持一致</strong>。</p>
<h2 id="vw、vh-实现垂直居中"><a href="#vw、vh-实现垂直居中" class="headerlink" title="vw、vh 实现垂直居中"></a>vw、vh 实现垂直居中</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123; </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50vw</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50vh</span>; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25vh</span> auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-移动端触屏滑动事件"><a href="#2-移动端触屏滑动事件" class="headerlink" title="2. 移动端触屏滑动事件"></a>2. 移动端触屏滑动事件</h1><h2 id="四种-touch-事件"><a href="#四种-touch-事件" class="headerlink" title="四种 touch 事件"></a>四种 touch 事件</h2><ul>
<li><strong>touchstart</strong>: 手指放到屏幕上时触发</li>
<li><strong>touchmove</strong>: 手指在屏幕上滑动式触发</li>
<li><strong>touchend</strong>: 手指离开屏幕时触发</li>
<li><strong>touchcancel</strong>: 系统取消touch事件的时候触发(这个好像比较少用)</li>
</ul>
<h2 id="跟踪触摸"><a href="#跟踪触摸" class="headerlink" title="跟踪触摸"></a>跟踪触摸</h2><p>每个触摸事件被触发后，会生成一个event对象，event对象里额外包括以下三个触摸列表：</p>
<ul>
<li><strong>touches</strong>：表示当前跟踪的触摸操作的touch对象的数组。<ul>
<li>当一个手指在触屏上时，event.touches.length=1,当两个手指在触屏上时，event.touches.length=2，以此类推。</li>
</ul>
</li>
<li><strong>targetTouches</strong>：特定于事件目标的touch对象数组。<ul>
<li>因为touch事件是会冒泡的，所以利用这个属性指出目标对象。</li>
</ul>
</li>
<li><strong>changedTouches</strong>：表示自上次触摸以来发生了什么改变的touch对象的数组。</li>
</ul>
<p>这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下：</p>
<ul>
<li><strong>clientX</strong> / <strong>clientY</strong>：触摸目标在视口中的 x / y 坐标</li>
<li><strong>identifier</strong>：标识触摸的唯一ID</li>
<li><strong>pageX</strong> /  <strong>pageY</strong>：触摸目标在页面中的 x / y 坐标</li>
<li><strong>screenX</strong> / <strong>screenY</strong>：触摸目标在屏幕中的 x / y 坐标</li>
<li><strong>target</strong>：触摸的DOM节点目标</li>
</ul>
<h2 id="禁止缩放和滚动"><a href="#禁止缩放和滚动" class="headerlink" title="禁止缩放和滚动"></a>禁止缩放和滚动</h2><p>手指在滑动整个屏幕时，会影响浏览器的行为，比如滚动和缩放。所以在调用touch事件时，要注意禁止缩放和滚动。</p>
<h4 id="禁止缩放"><a href="#禁止缩放" class="headerlink" title="禁止缩放"></a>禁止缩放</h4><p>通过meta元标签来设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"target-densitydpi=320,width=640,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="禁止滚动"><a href="#禁止滚动" class="headerlink" title="禁止滚动"></a>禁止滚动</h4><p><strong>event.preventDefault()</strong>： preventDefault 是阻止默认行为，touch事件的默认行为就是滚动。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(div,<span class="string">"touchstart"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  div.innerHTML=event.touches[<span class="number">0</span>].clientX+<span class="string">','</span>+event.touches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(div,<span class="string">"touchmove"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  div.innerHTML=event.touches[<span class="number">0</span>].clientX;</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(div,<span class="string">"touchend"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  div.innerHTML=event.changedTouches[<span class="number">0</span>].clientY;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用clientX……时，必须要指明具体的touch对象，而不要直接指明数组:<br><code>event.touches[0]</code></li>
<li>在touchend事件处理函数中，当该事件发生时，touches里面已经没有任何的touch对象了，此时，就要使用changeTouches集合。</li>
</ul>
<h2 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h2><p>只有两个手指都触摸到事件的接收容器时才触发这些手势事件:</p>
<ul>
<li>gesturestart：当一个手指已经按在屏幕上，而另一个手指又触摸在屏幕时触发。</li>
<li>gesturechange：当触摸屏幕的任何一个手指的位置发生变化时触发。</li>
<li>gestureend：当任何一个手指从屏幕上面移开时触发。</li>
</ul>
<h4 id="触摸事件与手势事件之间的关系"><a href="#触摸事件与手势事件之间的关系" class="headerlink" title="触摸事件与手势事件之间的关系"></a>触摸事件与手势事件之间的关系</h4><ul>
<li>当一个手指放在屏幕上时，会触发touchstart事件，如果另一个手指又放在了屏幕上，则会触发gesturestart事件，随后触发基于该手指的touchstart事件。</li>
<li>如果一个或两个手指在屏幕上滑动，将会触发gesturechange事件，但只要有一个手指移开，则会触发gestureend事件，紧接着又会触发toucheend事件。</li>
</ul>
<h4 id="手势的专有属性"><a href="#手势的专有属性" class="headerlink" title="手势的专有属性"></a>手势的专有属性</h4><ul>
<li>rotation：表示手指变化引起的旋转角度，负值表示逆时针，正值表示顺时针，从零开始。</li>
<li>scale：表示两个手指之间的距离情况，向内收缩会缩短距离，这个值从1开始，并随距离拉大而增长。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/快乐暑假第9天——学习移动端网页制作/" data-id="ck06ipghc000c9kuw63ak6w6j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第8天——学习canvas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/快乐暑假第8天——学习canvas/" class="article-date">
  <time datetime="2019-07-16T14:05:05.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/快乐暑假第8天——学习canvas/">快乐暑假第8天——学习canvas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天画钟画的有点心塞。再一次体会到了真正开始动手才会发现各种各样的问题。其实最后能让时针按照真实时间动起来，还是参考了网上的例子，一步一步模仿下来的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
大概总结一下今天做完时钟之后印象深刻的东西吧：<br>
canvas有自己的宽高，超出的部分不会显示；<br>
可以用moveTo方法改变画笔的位置，用来画不连续的线段；<br>
路径画好之后需要用stroke()来着色；<br>
可以设置线段的宽度、颜色；<br>
像画圆形的时候，边框的宽度不会遮住圆形本体；<br>
有时候用图形变换(旋转、平移等)可以省很大力气；<br>
在操作圆形之类的对称图形的时候，把原点放到画布中央更方便；<br>
写好注释，利人利己。<br>
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<p>&lt;canvas&gt;是一个可以使用脚本(通常为JavaScript)来绘制图形的 HTML 元素，默认大小为300px × 150px，也可以自定义宽高。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="元素"><a href="#元素" class="headerlink" title=" 元素"></a><canvas> 元素</canvas></h2><p>&lt;canvas&gt; 标签只有 width 和 height 两个<strong>属性</strong>。</p>
<ul>
<li>应该用width和height属性为 &lt;canvas&gt; 明确规定宽高，而不是使用CSS(可能会出现扭曲)</li>
<li>&lt;canvas&gt;元素也有margin，border，background等等属性，且这些样式不会影响在canvas中的实际图像</li>
</ul>
<p>可以定义一些<strong>替换内容</strong>，在不支持此元素的浏览器上会展示这些替换内容，如文字描述或静态图片(使用&lt;img&gt;标签)。</p>
<h2 id="渲染上下文"><a href="#渲染上下文" class="headerlink" title="渲染上下文"></a>渲染上下文</h2><p>canvas起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。</p>
<ul>
<li><strong>getContext( ) 方法</strong>：用来获得渲染上下文和它的绘画功能。只有一个参数——上下文的格式。</li>
<li>可以通过测试 getContext( ) 方法的存在来检查编程的支持性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'tutorial'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (canvas.getContext)&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="comment">// drawing code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h1><h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p><img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" alt="image"></p>
<ul>
<li>通常来说网格中的一个单元相当于canvas元素中的一像素。</li>
<li>栅格的起点为左上角（坐标为（0,0）），所有元素的位置都相对于原点定位。</li>
</ul>
<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>canvas只支持一种原生的图形绘制：矩形。</p>
<p>canvas提供了三种方法绘制矩形：</p>
<ol>
<li><strong>fillRect(x, y, width, height)</strong>：绘制一个填充的矩形</li>
<li><strong>strokeRect(x, y, width, height)</strong>：绘制一个矩形的边框</li>
<li><strong>clearRect(x, y, width, height)</strong>：清除指定矩形区域，让清除部分完全透明。</li>
</ol>
<p>以上的三个函数绘制之后会马上显现在canvas上。其中，x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。</p>
<ul>
<li><strong>beginPath()</strong>：新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>
<li><strong>closePath()</strong>：闭合路径之后图形绘制命令又重新指向到上下文中。</li>
<li><strong>stroke()</strong>：通过线条来绘制图形轮廓。</li>
<li><strong>fill()</strong>：通过填充路径的内容区域生成实心的图形。</li>
</ul>
<p>使用路径绘制图的步骤：</p>
<ol>
<li>生成路径 beginPath( ) 。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。每次这个方法调用之后，列表清空重置，然后就可以重新绘制新的图形。</li>
<li>调用函数指定绘制路径。</li>
<li>闭合路径 closePath( ) ,不是必需的。通过绘制一条从当前点到开始点的直线来闭合图形(如果图形已经闭合，即当前点为开始点，该函数什么也不做)。<ul>
<li>当调用 fill( ) 函数时，所有没有闭合的形状都会自动闭合，此时不需要调用 closePath( ) 函数。</li>
</ul>
</li>
</ol>
<h4 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h4><p><strong>moveTo(x, y)</strong>：将笔触移动到指定的坐标x以及y上。</p>
<ul>
<li>当canvas初始化或者beginPath()调用后，通常会使用moveTo()函数设置起点</li>
<li>也可以使用moveTo()绘制一些不连续的路径</li>
</ul>
<h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><p><strong>lineTo(x, y)</strong>：绘制一条从当前位置到指定x以及y位置的直线。</p>
<ul>
<li>该方法有两个参数：x以及y ，代表坐标系中直线结束的点</li>
</ul>
<h4 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h4><p><strong>arc(x, y, radius, startAngle, endAngle, anticlockwise)</strong>：画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。</p>
<ul>
<li>参数anticlockwise为一个布尔值。<strong>为true时，是逆时针方向</strong>，否则顺时针方向</li>
<li>函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式: <strong>弧度=(Math.PI/180)*角度</strong></li>
</ul>
<h4 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h4><p><img src="https://mdn.mozillademos.org/files/223/Canvas_curves.png" alt="image"></p>
<ul>
<li>红色点为控制点，蓝色点为开始点和结束点</li>
</ul>
<p><strong>quadraticCurveTo(cp1x, cp1y, x, y)</strong>：绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。<br><strong>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</strong>：绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p>
<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p><strong>rect(x, y, width, height)</strong>：绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。</p>
<ul>
<li>当该方法执行的时候，当前笔触自动重置回默认坐标。</li>
</ul>
<h2 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h2><p><strong>Path2D( )</strong>：会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。</p>
<ul>
<li>所有的路径方法比如moveTo, rect, arc或quadraticCurveTo等都可以在Path2D中使用。</li>
<li>Path2D API 添加了 addPath 作为将path结合起来的方法。当你想要从几个元素中来创建对象时，这将会很实用。比如：<figure class="highlight plain"><figcaption><span>[, transform])```添加了一条路径到当前路径（可能添加了一个变换矩阵）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 使用样式和颜色</span><br><span class="line">## 色彩 Colors</span><br><span class="line">有两个重要的属性可以给图像上色：</span><br><span class="line">- **fillStyle = color**：设置图形的填充颜色。</span><br><span class="line">- **strokeStyle = color**：设置图形轮廓的颜色。</span><br><span class="line"></span><br><span class="line">color 可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象。默认情况下，线条和填充颜色都是黑色。</span><br><span class="line"></span><br><span class="line">一旦设置了 strokeStyle 或者 fillStyle 的值，这个新值就会成为新绘制的图形的默认值。</span><br><span class="line"></span><br><span class="line">## 透明度 Transparency</span><br><span class="line">**globalAlpha = transparencyValue**：这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</span><br><span class="line"></span><br><span class="line">strokeStyle 和 fillStyle 属性接受符合 CSS 3 规范的颜色值，因此 rgba( )  方法可以直接设置颜色透明度。</span><br><span class="line"></span><br><span class="line">## 线型 Line styles</span><br><span class="line">可以通过一系列属性来设置线的样式。</span><br><span class="line">- **lineWidth = value**：设置线条宽度。</span><br><span class="line">- **lineCap = type**：设置线条末端样式。</span><br><span class="line">- **lineJoin = type**：设定线条与线条间接合处的样式。</span><br><span class="line">- **miterLimit = value**：限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</span><br><span class="line">- **getLineDash()**：返回一个包含当前虚线样式，长度为非负偶数的数组。</span><br><span class="line">- **setLineDash(segments)**：设置当前虚线样式。</span><br><span class="line">- **lineDashOffset = value**：设置虚线样式的起始偏移量。</span><br><span class="line"></span><br><span class="line">#### lineWidth 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/201/canvas-grid.png)</span><br><span class="line">- 出现图二情况时会以实际笔触颜色一半色调的颜色来填充剩下的半个像素</span><br><span class="line"></span><br><span class="line">#### lineCap 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/236/Canvas_linecap.png)</span><br><span class="line"></span><br><span class="line">属性 lineCap 的值决定了线段端点显示的样子：**butt**，**round** 和 **square**。默认是 butt。</span><br><span class="line"></span><br><span class="line">#### lineJoin 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/237/Canvas_linejoin.png)</span><br><span class="line"></span><br><span class="line">lineJoin 的属性值决定了图形中两线段连接处所显示的样子：**round**, **bevel** 和 **miter**。默认是 miter。</span><br><span class="line"></span><br><span class="line">#### miterLimit 属性</span><br><span class="line">![image](https://mdn.mozillademos.org/files/240/Canvas_miterlimit.png)</span><br><span class="line"></span><br><span class="line">lineJoin 属性应用 miter 时，当夹角减少时，交点距离会呈指数级增大。</span><br><span class="line"></span><br><span class="line">miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了 bevel。</span><br><span class="line"></span><br><span class="line">#### 使用虚线</span><br><span class="line">用 **setLineDash( ) 方法**和 **lineDashOffset 属性**来制定虚线样式.</span><br><span class="line">- setLineDash( ) 方法接受一个数组，来指定线段与间隙的交替</span><br><span class="line">- lineDashOffset 属性设置起始偏移量</span><br><span class="line"></span><br><span class="line">## 渐变 Gradients</span><br><span class="line">有两种方法可以新建一个 canvasGradient 对象：</span><br><span class="line">- **createLinearGradient(x1, y1, x2, y2)**:表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</span><br><span class="line">- **createRadialGradient(x1, y1, r1, x2, y2, r2)**:，前三个参数定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</span><br><span class="line"></span><br><span class="line">创建出 canvasGradient 对象后，就可以用 addColorStop 方法上色：</span><br><span class="line">- **addColorStop(position, color)**：position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置；color 参数必须是一个有效的 CSS 颜色值。</span><br><span class="line"></span><br><span class="line">## 图案样式 Patterns</span><br><span class="line">**createPattern(image, type)**：Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。</span><br><span class="line"></span><br><span class="line">图案的应用跟渐变类似，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。</span><br><span class="line">- 要使用 Image 对象的 onload 来确保设置图案之前图像已经装载完毕</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">  // 创建新 image 对象，用作图案</span><br><span class="line">  var img = new Image();</span><br><span class="line">  img.src = &apos;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&apos;;</span><br><span class="line">  img.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">    // 创建图案</span><br><span class="line">    var ptrn = ctx.createPattern(img, &apos;repeat&apos;);</span><br><span class="line">    ctx.fillStyle = ptrn;</span><br><span class="line">    ctx.fillRect(0, 0, 150, 150);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><ul>
<li><strong>shadowOffsetX = float</strong> 和 <strong>shadowOffsetY = float</strong>：shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</li>
<li><strong>shadowBlur = float</strong>：shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</li>
<li><strong>shadowColor = color</strong>：shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</li>
</ul>
<h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当用到 fill（或者 clip和isPointinPath ）时，可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。</p>
<p>两个可能的值：</p>
<ol>
<li><strong>“nonzero”</strong>: non-zero winding rule, 默认值</li>
<li><strong>“evenodd”</strong>:  even-odd winding rule</li>
</ol>
<h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><p>canvas 提供了两种方法来渲染文本:</p>
<ul>
<li><strong>fillText(text, x, y [, maxWidth])</strong>：在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</li>
<li><strong>strokeText(text, x, y [, maxWidth])</strong>：在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</li>
</ul>
<h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>以下属性可以改变 canvas 显示文本的方式：</p>
<ul>
<li><strong>font = value</strong>：当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。</li>
<li><strong>textAlign = value</strong>：文本对齐选项。可选的值包括：start, end, left, right 或 center. 默认值是 start。</li>
<li><strong>textBaseline = value</strong>：基线对齐选项。可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</li>
<li><strong>direction = value</strong>：文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</li>
</ul>
<h2 id="预测量文本宽度"><a href="#预测量文本宽度" class="headerlink" title="预测量文本宽度"></a>预测量文本宽度</h2><ul>
<li><strong>measureText( ) 方法</strong>：将返回一个 TextMetrics 对象的宽度、所在像素，这些体现文本特性的属性。</li>
</ul>
<h1 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h1><p>引入图像到canvas里需要以下两步基本操作：</p>
<ol>
<li>获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片</li>
<li>使用drawImage()函数将图片绘制到画布上</li>
</ol>
<h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2><p>canvas的API可以使用下面这些类型中的一种作为图片的源：</p>
<ul>
<li><strong>HTMLImageElement</strong>：这些图片是由Image()函数构造出来的，或者任何的 &lt;img&gt; 元素</li>
<li><strong>HTMLVideoElement</strong>：用一个HTML的 &lt;video&gt; 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</li>
<li><strong>HTMLCanvasElement</strong>：可以使用另一个 &lt;canvas&gt; 元素作为你的图片源。</li>
<li><strong>ImageBitmap</strong>：这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。</li>
</ul>
<p>这些源统一由 CanvasImageSource 类型来引用。</p>
<h4 id="使用相同页面内的图片"><a href="#使用相同页面内的图片" class="headerlink" title="使用相同页面内的图片"></a>使用相同页面内的图片</h4><p>可以通过下列方法来获得与canvas相同页面内的图片的引用：</p>
<ul>
<li><strong>document.images 集合</strong></li>
<li><strong>document.getElementsByTagName( ) 方法</strong></li>
<li><strong>document.getElementById( ) 方法</strong></li>
</ul>
<h4 id="使用其它域名下的图片"><a href="#使用其它域名下的图片" class="headerlink" title="使用其它域名下的图片"></a>使用其它域名下的图片</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/快乐暑假第8天——学习canvas/" data-id="ck06ipgho000l9kuw6wesfhkt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第7天——学习Ajax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/快乐暑假第7天——学习Ajax/" class="article-date">
  <time datetime="2019-07-15T13:32:25.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/快乐暑假第7天——学习Ajax/">快乐暑假第7天——学习Ajax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把之前六七章的笔记又回顾了一下，感觉已经比之前第一次看的时候要熟悉许多。然后在w3school上看了一下Ajax(貌似没有专门讲Ajax的博客)，大概就是XMLHttpRequest对象极其open( )和send( )方法、responseTex和responseXML两种获取内容的属性、onreadystatechange 事件这几个方面。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="1-创建-XMLHttpRequest-对象"><a href="#1-创建-XMLHttpRequest-对象" class="headerlink" title="1. 创建 XMLHttpRequest 对象"></a>1. 创建 XMLHttpRequest 对象</h1><p>XMLHttpRequest 对象是 AJAX 的基础，用于在后台与服务器交换数据。</p>
<ul>
<li>创建 XMLHttpRequest 对象的语法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable=<span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>(老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象)</p>
<p>为了兼容所有浏览器，可写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">  &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">  xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2. 向服务器发送请求"></a>2. 向服务器发送请求</h1><p>使用 XMLHttpRequest 对象的 open() 和 send() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">"GET"</span>,<span class="string">"test1.txt"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">open(method, url, async)</td>
<td align="left">method：请求的类型；GET 或 POST<br>url：文件在服务器上的位置<br>async：true（异步）或 false（同步）</td>
</tr>
<tr>
<td align="left">send(string)</td>
<td align="left">string：仅用于 POST 请求</td>
</tr>
</tbody></table>
<h2 id="GET-和-POST-的选择"><a href="#GET-和-POST-的选择" class="headerlink" title="GET 和 POST 的选择"></a>GET 和 POST 的选择</h2><p>GET 更简单也更快，但在以下情况中，必须使用 POST 请求：</p>
<ol>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ol>
<h1 id="3-服务器响应"><a href="#3-服务器响应" class="headerlink" title="3. 服务器响应"></a>3. 服务器响应</h1><p>如需获得来自服务器的响应，需要使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性：</p>
<ul>
<li>responseText ： 获得字符串形式的响应数据</li>
<li>responseXML ： 获得 XML 形式的响应数据</li>
</ul>
<h1 id="4-onreadystatechange-事件"><a href="#4-onreadystatechange-事件" class="headerlink" title="4. onreadystatechange 事件"></a>4. onreadystatechange 事件</h1><p>XMLHttpRequest 对象的三个重要的属性：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onreadystatechange</td>
<td align="left">存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</td>
</tr>
<tr>
<td align="left">readyState</td>
<td align="left">存有 XMLHttpRequest 的状态,从 0 到 4 发生变化。<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">200: “OK”<br>404: 未找到页面</td>
</tr>
</tbody></table>
<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/快乐暑假第7天——学习Ajax/" data-id="ck06ipgh9000a9kuw1k55n2ea" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第6天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/快乐暑假第6天/" class="article-date">
  <time datetime="2019-07-14T12:48:14.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/快乐暑假第6天/">快乐暑假第6天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
在看过王福朋的博客之后，对instanceof以及对象和函数的关系有了更清晰和更深入的理解，但是仍然有一些地方如this的指向，还是感觉比较别扭和生疏。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="6-函数表达式"><a href="#6-函数表达式" class="headerlink" title="6. 函数表达式"></a>6. 函数表达式</h1><p>定义函数的方式有两种：函数声明，函数表达式。</p>
<p>函数声明有一个重要特性：<strong>函数声明提升</strong>，即在执行代码之前会先读取函数声明。(因此函数声明可以放在调用语句后面)</p>
<p>函数表达式与其他表达式一样，在使用前必须先赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要这样做</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Hi!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"Yo!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用的是函数表达式就没有问题了</li>
</ul>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的。</p>
<p>在编写递归函数时，使用 arguments.callee (指向正在执行函数的指针) 代替函数名更保险。或者使用命名函数表达式来达成相同的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> faactorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是<strong>在一个函数内部创建另一个函数</strong>。</p>
<p>后台的每个执行环境都有一个表示变量的对象————<strong>变量对象</strong>。</p>
<p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>
<p>在另一个函数内部定义的函数会将包含函数的活动对象添加到它的作用域中。</p>
<h4 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个函数的作用域中都保存着creatFunctions( )函数的活动对象，所以它们引用的都是同一个变量 i <strong>(闭包只能取得包含函数中任何变量的最后一个值)</strong></li>
</ul>
<p>可以将函数改为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h4><p>this 对象是在运行时基于函数的执行环境绑定的。但匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
<p>如果想访问作用域中的 this 和 arguments 对象，必须将该对象的引用保存到另一个闭包能够访问的变量中。</p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>多次声明同一个变量时，会对后续的声明视而不见(不过，会执行后续声明的初始化)。</p>
<p>函数声明后面不能跟圆括号，而函数表达式可以。给函数声明加上一对圆括号即可将其转换为函数表达式。</p>
<p>无论在什么地方，如果临时需要一些变量，就可以使用私有作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">    </span><br><span class="line">    alert(i);   <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>在任何函数中定义的变量，都可以认为是私有变量(包括函数的参数、局部变量、函数内部定义的其他函数)。</p>
<p>有权访问私有变量和私有函数的公有方法称为<strong>特权方法</strong>，有两种在对象上创建特权方法的方式：</p>
<ul>
<li>在构造函数中定义特权方法(缺点是必须使用构造函数模式来达到这个目的)</li>
<li>使用静态私有变量来实现特权方法</li>
</ul>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/快乐暑假第6天/" data-id="ck06ipghb000b9kuwvzq7lak8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第5天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/12/快乐暑假第5天/" class="article-date">
  <time datetime="2019-07-12T11:50:17.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/12/快乐暑假第5天/">快乐暑假第5天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
在我的不懈努力下，今天终于将第六章看完了。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
明显能感觉到第六章对比起前面几章更难理解，有点像上学期学C语言链表那一部分时的感觉，一开始会感觉很绕，记住了构造函数、原型、实例之间的关系之后，继承部分也就能慢慢看懂了。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
单一地使用一种方法可能会有这样那样的问题，但是结合起来、取长补短，或许能获得满意的结果。
</p>


<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>(接前一天笔记)

<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>由于实例与原型之间的松散连接关系(二者之间的联系的一个指针，而不是一个副本)，在原型中添加属性和方法可以立即在实例中反映出来。</p>
<p>重写原型对象会切断现有原型与之前已经存在的对象实例之间的联系，这些实例引用的仍然是最初的原型。</p>
<h5 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h5><p>不仅是创建自定义类型，所有原生的引用类型(Object、Array等)都是采用原型模式创建的。</p>
<p>通过元素对象的原型，可以取得所有默认方法发引用，也可以定义新的方法(跟自定义类型一样)。</p>
<h5 id="原型对象的缺点"><a href="#原型对象的缺点" class="headerlink" title="原型对象的缺点"></a>原型对象的缺点</h5><p>省略了为构造函数传递初始化参数这一环节，因此所有实例在默认情况下都将取得相同的属性值。</p>
<p>对于包含引用类型值的属性来说，这种共享会导致一些问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name : "Nicholas",</span><br><span class="line">    age : 29,</span><br><span class="line">    job : "Software Engineer",</span><br><span class="line">    friends : ["Shelby", "Court"],</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性，可以使每个实例都有自己的一份实例属性的副本，同时又共享着对方法的引用，最大限度地节省了内存。这种混成模式还支持向构造函数传递参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.friends);    <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends);    <span class="comment">//"Shelby,Court"</span></span><br><span class="line">alert(person1.friends === person2.friends);  <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>person1.friends和person2.friends分别引用了不同的数组，不会互相影响</li>
</ul>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//properties</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//methods</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>

<ul>
<li>if 语句检查的可以是初始化之后应该存在的任何属性或方法，且只需要检查其中一个就好。</li>
</ul>
<h4 id="寄生构造函数模式-不建议"><a href="#寄生构造函数模式-不建议" class="headerlink" title="寄生构造函数模式(不建议)"></a>寄生构造函数模式(不建议)</h4><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式其实跟工厂模式是一样的。这个模式可以在特殊情况下用来为对象创建构造函数。</p>
<p>构造函数在不返回值的情况下，默认会返回新对象实例，而再构造函数末尾添加return语句可以重写调用构造函数使返回的值。</p>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象：指的是没有公共属性，且其方法也不引用this的对象。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>只支持实现继承，而实现继承主要是依靠原型链来实现的。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>基本思想是利用原型链让一个引用类型继承另一个引用类型的属性和方法。</p>
<h5 id="默认的原型"><a href="#默认的原型" class="headerlink" title="默认的原型"></a>默认的原型</h5><p>所有引用类型默认都继承了Object(也是通过原型链实现的)，因此所有自定义类型都会继承toString( )、valueOf( )等默认方法。</p>
<h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><p>可以通过两种方式来确定原型和实例的关系：</p>
<ul>
<li>使用instanceof操作符：用这个操作符来测试与原型链中<strong>出现过的</strong>构造函数，就会返回true</li>
<li>使用isPrototypeOf( )方法：只要是原型链中<strong>出现过的</strong>原型，都会返回true</li>
</ul>
<h5 id="谨慎地定义方法"><a href="#谨慎地定义方法" class="headerlink" title="谨慎地定义方法"></a>谨慎地定义方法</h5><p>给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p>在通过原型链实现继承时，不能使用对象字面量创建原型方法，否则会重写原型链。</p>
<h5 id="原型链的缺点"><a href="#原型链的缺点" class="headerlink" title="原型链的缺点"></a>原型链的缺点</h5><p>最主要的问题来自包含引用类型值的原型，也是由于属性共享带来的问题。</p>
<p>在创建子类型的实例时，不能向超类型的构造函数中传递参数(实际上是无法在不影响所有对象实例的情况下，给超类型的构造函数传递参数)。</p>
<p>因此实践中很少单独使用原型链。</p>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>思路为在子类型构造函数的内部调用超类型构造函数。</p>
<p>借用构造函数可以在子类型构造函数中向超类型构造函数传递参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    <span class="comment">//继承了 SuperType ，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);    <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age);     <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<ul>
<li>为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</li>
</ul>
<p>借用构造函数也有一些缺点，因此很少单独使用。</p>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>指的是将原型链和借用构造函数的技术组合到一块的一种继承模式。</p>
<p>思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有自己的属性。</p>
<p>最常用的继承模式。</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型可以基于已有对象创建新对象，且不必因此创建自定义类型。</p>
<p>Object.creat( ) 方法规范化了原型式继承。接收两个参数：一个用作新对象原型的对象和一个为新对象定义额外属性的对象(可选)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line">                   </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line">alert(anotherPerson.name);  <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>包含引用类型值的属性始终会共享相应的值。</li>
</ul>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>组合继承最大的问题就是无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<p>寄生组合式继承指：通过借用构造函数来继承属性，通过原型链的混成方式来继承方法。<br><br>本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<p>寄生组合式继承的基本模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);   <span class="comment">//创建对象(创建超类型原型的一个副本)</span></span><br><span class="line">    prototype.constructor = subType;               <span class="comment">//增强对象(为创建的副本添加因重写原型而失去的默认 constructor 属性)</span></span><br><span class="line">    subType.prototype = prototype;                 <span class="comment">//指定对象(将创建的新对象——即副本——赋值给子类型的原型)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以调用inheritPrototype( )函数的语句去替换为子类型原型赋值的语句</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/12/快乐暑假第5天/" data-id="ck06ipgho000k9kuwi3bi413d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-快乐暑假第4天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/快乐暑假第4天/" class="article-date">
  <time datetime="2019-07-11T13:16:02.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/快乐暑假第4天/">快乐暑假第4天</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
进入第六章的学习，感觉有一点绕，原型对象、构造对象、实例之间的关系以及联系它们的一些方法。但花点时间理解一下之后也渐渐地有一点概念了。
</p>

<p style="font-size:18px;text-align:left;text-indent:2em">
接下来强行总结一波：我早上吃了超市买的4块钱三明治和一瓶蒙牛纯牛奶，中午吃了一盘不知道叫什么的菜和一碗白米饭，晚上吃的是豆角和豆腐。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
ps：今天没抽卡。
</p>

<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="5-面向对象的程序设计"><a href="#5-面向对象的程序设计" class="headerlink" title="5. 面向对象的程序设计"></a>5. 面向对象的程序设计</h1><p>对象的定义为：无序属性的集合，其属性可以包含基本值、对象或函数。</p>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ECMAScript 中有两种属性：</p>
<ul>
<li><p>数据属性：包含一个数据值的位置，在这个位置可以读取和写入值。</p>
<ul>
<li><p>数据属性有4个描述其行为的特性：</p>
<ol>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Enumerable]]:表示能否通过 fot-in 循环返回属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Writable]]:表示能否修改属性的值。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Value]]:包含这个属性的数据值。读取属性的时候，从这个位置读；写入属性的时候，把新值保存在这个位置。(这个特性的默认值为undefined)</li>
</ol>
</li>
<li><p>修改属性默认特性必须使用 Object.defineProperty( ) 方法，该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符对象的属性必须是：configurable、enumerable、writable、value。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(person.name);     <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一旦把属性定义为不可配置的(configurable: false)，就不能再把它变回可配置了，此时再调用Object.defineProperty( )方法修改除writable之外的特性都会导致错误。</li>
<li>在调用该方法创建新属性时，如果不指定，configurable、enumerable、writable特性的默认值都是false；如果只是修改已定义的属性的特性则无此限制。</li>
</ul>
</li>
</ul>
</li>
<li><p>访问器属性：不包含数据值，包含一对getter和setter函数(但这两个函数都不是必需的)。</p>
<ul>
<li><p>访问器属性有4个特性：</p>
<ol>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特<br>性,或者能否把属性修改为数据属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Enumerable]]:表示能否通过 fot-in 循环返回属性。(直接在对象上定义的属性,这个特性默认值为true)</li>
<li>[[Get]]：读取属性时调用的函数。(默认值为undefined)</li>
<li>[[Set]]：写入属性时调用的函数。(默认值为undefined)</li>
</ol>
</li>
<li><p>访问器属性不能直接定义，必须使用Object.defineProperty( )来定义。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>_year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。将year属性修改为2005会导致 _year 变成2005，而 edition 变为2。</li>
<li>这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</li>
</ul>
</li>
<li><p>只指定getter意味着属性是不能写，尝试写入属性会被忽略；只指定setter函数的属性不能读，否则会返回undefined。</p>
</li>
</ul>
</li>
</ul>
<h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p>利用Object.defineProperties( )方法可以通过描述符一次定义多个属性。</p>
<p>该方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    year: &#123;            </span><br><span class="line">        <span class="keyword">get</span>: function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span>: function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;                  </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);   <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p>Object.getOwnPropertyDescriptor( )方法可以取得给定属性的<strong>描述符</strong>。</p>
<p>该方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。</p>
<p><strong>返回值是一个对象</strong>：</p>
<ul>
<li>若是访问器属性，则这个对象的属性有configurable、enumerable、get、set</li>
<li>若是数据属性，则这个对象的属性有configurable、enumerable、writable、value</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用Object构造函数或对象字面量来创建很多对象时会产生大量重复的代码。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>用函数来封装以特定接口创建对象的细节：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">            o.name = name;</span><br><span class="line">            o.age = age;</span><br><span class="line">            o.job = job;</span><br><span class="line">            o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;;    </span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">        <span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">        </span><br><span class="line">        person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line">        person2.sayName();   <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><p>可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.job = job;</span><br><span class="line">            <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;;    </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">        <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>用new操作符调用构造函数会经过以下4个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象(因此this就指向了这个新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象<br>返回的对象都有一个constructor(构造函数)属性，该属性指向对应的构造函数。</li>
</ol>
<h5 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h5><p>任何函数，只要通过new操作符来调用，就可以作为构造函数；任何函数，如果不通过new操作符来调用，就是普通函数。</p>
<h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>不同实例上的同名函数是不相等的，因此会创建许多相同的Function实例。</p>
<p>由于this对象的存在，可以将函数的定义转移到构造函数外部。</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<h5 id="原型对象的性质"><a href="#原型对象的性质" class="headerlink" title="原型对象的性质"></a>原型对象的性质</h5><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性(可以自定义添加)，其他方法则都是从Object继承而来的。</p>
<p>调用构造函数创建一个新的实例后，该实例内部包含一个指针(内部指针)叫[[Prototype]]，这个连接存在于实例和构造函数的原型对象之间(实例与构造函数之间没有直接的关系)。</p>
<p>虽然无法访问到[[Prototype]]，但可以通过 isPrototpyeOf( ) 方法来确定对象之间是否存在这种关系。如果[[Prototype]]指向调用该方法的对象，则会返回true。</p>
<p><strong>Object.getPrototypeOf( )方法</strong>可以用来取得[[Prototype]]的值(即指向的原型对象)。</p>
<p>当代码读取某个对象的某个属性时，会先从对象实例本身开始搜索给定名字的属性，如果没找到，则继续搜索指针指向的原型对象，若搜索到了这个属性，则返回该属性的值。(多个对象实例共享原型所保存的属性和方法的基本原理)<br><br>可以通过对象实例访问保存在原型中的值，但<strong>不能改写</strong>。如果在实例中添加的新属性与实例原型中的属性同名，则新属性会屏蔽原型中的那个属性。</p>
<p>delete操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性。</p>
<p>hasOwnProperty( )方法可以检测一个属性是存在于实例中还是存在于原型中。当给定属性存在于实例中时，返回true。</p>
<h5 id="原型与-in-操作符"><a href="#原型与-in-操作符" class="headerlink" title="原型与 in 操作符"></a>原型与 in 操作符</h5><p>有两种方式使用 in 操作符：<br>    - 单独使用：会在通过对象能够访问给定的属性时返回 true ，无论该属性存在于实例中还是原型中。<br>    - 在 for-in 循环中使用：返回的是所有能够通过对象访问的、可枚举的(enumerable)属性，包括存在于实例中和原型中的属性。屏蔽了原型中不可枚举属性(即[[enumerable]]标记为false)的实例属性也会返回。</p>
<p>Object.keys( ) 方法能取得对象上所有可枚举的实例属性，接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<p>Object.keys( ) 和 Object.getOwnPropertyNames( ) 方法都可以用来替代 for-in 循环。</p>
<h5 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h5><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">    </span><br><span class="line">alert(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br><span class="line">alert(friend <span class="keyword">instanceof</span> Person);  <span class="comment">//true</span></span><br><span class="line">alert(friend.constructor == Person);  <span class="comment">//false</span></span><br><span class="line">alert(friend.constructor == <span class="built_in">Object</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时用constructor属性不再指向Person，而是指向Object。</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/快乐暑假第4天/" data-id="ck06ipghn000j9kuwmf3ueb88" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/05/2019暑假总结/">2019暑假总结</a>
          </li>
        
          <li>
            <a href="/2019/08/02/快乐暑假第22天——学习Vue-js/">快乐暑假第22天——学习Vue.js</a>
          </li>
        
          <li>
            <a href="/2019/07/31/快乐暑假第21天——nodejs简单实现登陆注册/">快乐暑假第21天——nodejs简单实现登陆注册</a>
          </li>
        
          <li>
            <a href="/2019/07/31/快乐暑假第20天——学习nodejs模块化和express框架/">快乐暑假第20天——学习nodejs模块化和express框架</a>
          </li>
        
          <li>
            <a href="/2019/07/29/快乐暑假第19天——学习nodejs处理两种请求/">快乐暑假第19天——学习nodejs处理两种请求</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>