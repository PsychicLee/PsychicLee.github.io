<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>快乐暑假第十三天 | Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今日小结  今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。   我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。">
<meta property="og:type" content="article">
<meta property="og:title" content="快乐暑假第十三天">
<meta property="og:url" content="http://yoursite.com/2019/07/22/快乐暑假第十三天/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:description" content="今日小结  今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。   我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-22T12:21:25.992Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="快乐暑假第十三天">
<meta name="twitter:description" content="今日小结  今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。   我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-快乐暑假第十三天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/快乐暑假第十三天/" class="article-date">
  <time datetime="2019-07-22T12:21:09.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      快乐暑假第十三天
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
今天把es6重点部分看了个大概，有了一个总体的概念，但有些地方仍旧没有理解透彻，许多细节也没办法全部记住。与之前学习的JavaScript比起来，es6更加严格，更接近其他的面向对象语言，不过像解构赋值、异步、模块化等也更便于编程，能够减少代码量、提高程序的效率和准确率。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
我将重点内容、关键语句都做了笔记，方便快速回顾之前学过看过的东西，但之后实践的时候肯定还是要再回去看文档的。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
今晚还看了一些jq，明天再大概看一下。设计差不多要出稿了，准备开始实践了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="9-async-函数"><a href="#9-async-函数" class="headerlink" title="9. async 函数"></a>9. async 函数</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>
<h2 id="9-1-语法"><a href="#9-1-语法" class="headerlink" title="9.1 语法"></a>9.1 语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p>async函数返回一个 Promise 对象。</p>
<ul>
<li>内部return语句返回的值，会<strong>成为then方法回调函数的参数</strong>。</li>
<li>async函数内部抛出错误，会导致返回的 Promise 对象<strong>变为reject状态</strong>。抛出的错误对象<strong>会被catch方法回调函数接收到</strong>。</li>
</ul>
<h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p>async函数返回的 Promise 对象，必须<strong>等到内部所有await命令后面的 Promise 对象执行完</strong>，才会发生状态改变，然后执行then方法指定的回调函数，除非<strong>遇到return语句</strong>或者<strong>抛出错误</strong>。</p>
<h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<strong>await命令后面是一个 Promise 对象</strong>，返回该对象的结果。如果不是 Promise 对象，就<strong>直接返回对应的值</strong>。如果后面是一个thenable对象（即定义then方法的对象），那么await会<strong>将其等同于 Promise 对象</strong>。</p>
<p>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<ul>
<li>任何一个await语句后面的 Promise 对象变为reject状态，整个async函数都会中断执行。</li>
<li>如果不想中断后面语句的执行，可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>
<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<ul>
<li>防止出错的方法，也是将其放在try…catch代码块之中。</li>
<li>如果有多个await命令，可以统一放在try…catch结构中。</li>
</ul>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul>
<li>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</li>
<li>多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个操作互相独立，这样做比较耗时</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>

<ul>
<li>await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>
<li>async 函数可以保留运行堆栈。</li>
</ul>
<h1 id="10-Class-的基本语法"><a href="#10-Class-的基本语法" class="headerlink" title="10. Class 的基本语法"></a>10. Class 的基本语法</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。<strong>Object.assign方法</strong>可以很方便地一次向类添加多个方法。</p>
<p><strong>类的内部所有定义的方法，都是不可枚举的</strong>。这一点与 ES5 的行为不一致。</p>
<p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。<strong>一个类必须有constructor方法</strong>，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<ul>
<li>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象(但会导致实例对象改变)。</li>
</ul>
<p>类必须使用new调用，否则会报错。</p>
<h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<ul>
<li>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</li>
</ul>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Square类的方法名getArea，是从表达式得到的。</li>
</ul>
<h3 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，<strong>这个类只能用MyClass引用</strong>。</li>
<li>如果类的内部没用到的话，可以省略Me。</li>
</ul>
<p>采用 Class 表达式，可以写出<strong>立即执行的 Class</strong>。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>类和模块的内部，<strong>默认就是严格模式</strong>，所以不需要使用use strict指定运行模式。</li>
<li><strong>类不存在变量提升</strong>（hoist），这一点与 ES5 完全不同。</li>
<li>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</li>
<li>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</li>
</ol>
<h2 id="10-2-静态方法"><a href="#10-2-静态方法" class="headerlink" title="10.2 静态方法"></a>10.2 静态方法</h2><p>类相当于实例的原型，<strong>所有在类中定义的方法，都会被实例继承</strong>。如果在一个方法前，<strong>加上static关键字，就表示该方法不会被实例继承</strong>，而是直接通过类来调用，这就称为“静态方法”。</p>
<ul>
<li>如果静态方法包含this关键字，这个this指的是类，而不是实例。</li>
<li>静态方法可以与非静态方法重名。</li>
<li>父类的静态方法，可以被子类继承。</li>
<li>静态方法也是可以从super对象上调用的。</li>
</ul>
<h2 id="10-3-实例属性的新写法"><a href="#10-3-实例属性的新写法" class="headerlink" title="10.3 实例属性的新写法"></a>10.3 实例属性的新写法</h2><p>实例属性除了定义在constructor()方法里面的this上面，也可以<strong>定义在类的最顶层</strong>。</p>
<h2 id="10-4-静态属性"><a href="#10-4-静态属性" class="headerlink" title="10.4 静态属性"></a>10.4 静态属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</li>
</ul>
<h1 id="11-Class-的继承"><a href="#11-Class-的继承" class="headerlink" title="11. Class 的继承"></a>11. Class 的继承</h1><p>Class 可以通过extends关键字实现继承。</p>
<ul>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</li>
<li>如果子类没有定义constructor方法，这个方法会被默认添加。因此不管有没有显式定义，任何一个子类都有constructor方法。</li>
<li>在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。</li>
<li>父类的静态方法，也会被子类继承。</li>
</ul>
<h2 id="11-1-Object-getPrototypeOf"><a href="#11-1-Object-getPrototypeOf" class="headerlink" title="11.1 Object.getPrototypeOf( )"></a>11.1 Object.getPrototypeOf( )</h2><p>Object.getPrototypeOf方法可以用来从子类上获取父类。<br>因此可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="11-2-super-关键字"><a href="#11-2-super-关键字" class="headerlink" title="11.2 super 关键字"></a>11.2 super 关键字</h2><p>super作为函数调用时，代表父类的构造函数。<strong>作为函数时，super()只能用在子类的构造函数之中</strong>，用在其他地方就会报错。</p>
<p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<h1 id="12-Module-的语法"><a href="#12-Module-的语法" class="headerlink" title="12. Module 的语法"></a>12. Module 的语法</h1><p>ES6 的模块自动采用严格模式。</p>
<p>ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。</p>
<p>模块功能主要由两个命令构成：export和import：</p>
<ul>
<li><strong>export命令用于规定模块的对外接口</strong>。</li>
<li><strong>import命令用于输入其他模块提供的功能</strong>。</li>
</ul>
<h2 id="12-1-export-命令"><a href="#12-1-export-命令" class="headerlink" title="12.1 export 命令"></a>12.1 export 命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果要<strong>让外部能够读取模块内部的某个变量</strong>，就必须使用export关键字输出该变量。</p>
<ul>
<li>export命令除了输出变量，还可以输出函数或类。</li>
<li>通常情况下，export输出的变量就是本来的名字，但是可以<strong>使用as关键字重命名</strong>。</li>
<li>export语句输出的接口，与其对应的值是<strong>动态绑定关系</strong>，即通过该接口，可以取到模块内部实时的值。</li>
<li>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错。</li>
</ul>
<h2 id="12-2-import-命令"><a href="#12-2-import-命令" class="headerlink" title="12.2 import 命令"></a>12.2 import 命令</h2><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以<strong>通过import命令加载这个模块</strong>。</p>
<ul>
<li>使用as关键字，将输入的变量重命名。</li>
<li>import命令输入的变量都是<strong>只读</strong>的，因为它的本质是输入接口。</li>
<li>import命令<strong>具有提升效果</strong>，会提升到整个模块的头部，首先执行。(import命令是编译阶段执行的，在代码运行之前)</li>
<li>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li>
</ul>
<h2 id="12-3模块的整体加载"><a href="#12-3模块的整体加载" class="headerlink" title="12.3模块的整体加载"></a>12.3模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即<strong>用星号（*）指定一个对象，所有输出值都加载在这个对象上面</strong>。</p>
<ul>
<li>模块整体加载所在的那个对象，应该是<strong>可以静态分析</strong>的，所以<strong>不允许运行时改变</strong>。</li>
</ul>
<h2 id="12-4-export-default-命令"><a href="#12-4-export-default-命令" class="headerlink" title="12.4 export default 命令"></a>12.4 export default 命令</h2><p>export default命令能为模块指定默认输出。</p>
<ul>
<li>这时import命令后面，不使用大括号。</li>
<li>export default命令也可以用在非匿名函数前。</li>
<li>因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</li>
<li>因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</li>
</ul>
<h2 id="12-5-export-与-import-的复合写法"><a href="#12-5-export-与-import-的复合写法" class="headerlink" title="12.5 export 与 import 的复合写法"></a>12.5 export 与 import 的复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>foo和bar实际上并没有被导入当前模块</li>
</ul>
<h1 id="13-Module-的加载实现"><a href="#13-Module-的加载实现" class="headerlink" title="13. Module 的加载实现"></a>13. Module 的加载实现</h1><h2 id="13-1-浏览器加载"><a href="#13-1-浏览器加载" class="headerlink" title="13.1 浏览器加载"></a>13.1 浏览器加载</h2><p>浏览器允许脚本异步加载，有两种异步加载的语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>defer是“渲染完再执行”，async是“下载完就执行”。</li>
<li>如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</li>
</ul>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>浏览器加载 ES6 模块，也使用&lt;script&gt;标签，但是要加入<strong>type=”module”属性</strong>。</p>
<ul>
<li>浏览器对于带有 type=”module” 的&lt;script&gt;，都是异步加载，<strong>等同于打开了&lt;script&gt;标签的defer属性</strong>。（会按照出现顺序执行）</li>
<li>async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。（此时<strong>不会按照在页面出现的顺序执行</strong>，而是只要该模块加载完成，就执行该模块）</li>
</ul>
<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。对于外部的模块脚本（上例是foo.js），有几点需要注意：</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式。</li>
<li>模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。</li>
<li>在模块顶层使用this关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/快乐暑假第十三天/" data-id="cjyip9978000fdouwubub7o9k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/23/快乐暑假第十四天——学习jQuery/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          快乐暑假第十四天——学习jQuery
        
      </div>
    </a>
  
  
    <a href="/2019/07/21/快乐暑假第十二天/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">快乐暑假第十二天</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/25/快乐暑假第十六天——继续做Bolo/">快乐暑假第十六天——继续做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/24/快乐暑假第十五天——开始做Bolo/">快乐暑假第十五天——开始做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/23/快乐暑假第十四天——学习jQuery/">快乐暑假第十四天——学习jQuery</a>
          </li>
        
          <li>
            <a href="/2019/07/22/快乐暑假第十三天/">快乐暑假第十三天</a>
          </li>
        
          <li>
            <a href="/2019/07/21/快乐暑假第十二天/">快乐暑假第十二天</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>