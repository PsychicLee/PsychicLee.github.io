<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>快乐暑假第12天 | Lee&#39;s blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今日小结  使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。   周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。  笔记部分  7. Set 和 Map 数据结构7.1 SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的">
<meta property="og:type" content="article">
<meta property="og:title" content="快乐暑假第12天">
<meta property="og:url" content="http://yoursite.com/2019/07/21/快乐暑假第12天/index.html">
<meta property="og:site_name" content="Lee&#39;s blogs">
<meta property="og:description" content="今日小结  使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。   周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。  笔记部分  7. Set 和 Map 数据结构7.1 SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-28T01:44:29.227Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="快乐暑假第12天">
<meta name="twitter:description" content="今日小结  使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。   周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。  笔记部分  7. Set 和 Map 数据结构7.1 SetES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的">
  
    <link rel="alternate" href="/atom.xml" title="Lee&#39;s blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lee&#39;s blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-快乐暑假第12天" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/快乐暑假第12天/" class="article-date">
  <time datetime="2019-07-21T13:33:40.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      快乐暑假第12天
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">今日小结</div>
<p style="font-size:18px;text-align:left;text-indent:2em">
使用Promise时最好把catch单独写出来，而不是跟then放在一起。由于then会返回一个promise实例，因此then可以成链。
</p>
<p style="font-size:18px;text-align:left;text-indent:2em">
周翰程说出去玩的时候我们在房间里看电影，他负责烤完给我们吃就好。他还说他要负责洗海鲜。不能忘了。
</p>
<div style="font-size: 24px;color: blue;font-weight:bold;margin-top:30px">笔记部分</div>

<h1 id="7-Set-和-Map-数据结构"><a href="#7-Set-和-Map-数据结构" class="headerlink" title="7. Set 和 Map 数据结构"></a>7. Set 和 Map 数据结构</h1><h2 id="7-1-Set"><a href="#7-1-Set" class="headerlink" title="7.1 Set"></a>7.1 Set</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的</strong>，没有重复的值。</p>
<ul>
<li>Set本身是一个<strong>构造函数</strong>，用来生成 Set 数据结构。</li>
<li>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。(会<strong>去除重复成员</strong>)</li>
<li>向 Set 加入值的时候，<strong>不会发生类型转换</strong>。内部判断两个值是否不同的算法类似于精确相等运算符（===），主要的区别是向 Set 加入值时<strong>认为NaN等于自身</strong>，另外，<strong>两个对象总是不相等的</strong>。</li>
</ul>
<h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性：</p>
<ul>
<li><strong>Set.prototype.constructor</strong>：构造函数，默认就是Set函数。</li>
<li><strong>Set.prototype.size</strong>：返回Set实例的成员总数。</li>
</ul>
<p><strong>Set函数接受数组作为参数</strong>是一种去除数组重复成员的方法。</p>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面是四个操作方法：</p>
<ul>
<li><strong>Set.prototype.add(value)</strong>：添加某个值，返回 Set 结构本身。</li>
<li><strong>Set.prototype.delete(value)</strong>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><strong>Set.prototype.has(value)</strong>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><strong>Set.prototype.clear( )</strong>：清除所有成员，没有返回值。</li>
</ul>
<p><strong>Array.from方法可以将 Set 结构转为数组</strong>，是去除数组重复成员的另一种方法。</p>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员：</p>
<ul>
<li><strong>Set.prototype.keys( )</strong>：返回键名的遍历器</li>
<li><strong>Set.prototype.values( )</strong>：返回键值的遍历器</li>
<li><strong>Set.prototype.entries( )</strong>：返回键值对的遍历器</li>
<li><strong>Set.prototype.forEach( )</strong>：使用回调函数遍历每个成员</li>
</ul>
<p><strong>Set的遍历顺序就是插入顺序。</strong></p>
<h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h4><p>keys方法、values方法、entries方法返回的都是遍历器对象，由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<strong>keys方法和values方法的行为完全一致</strong>。entries方法返回的遍历器，同时包括键名和键值。</p>
<p>可以省略values方法，直接用for…of循环遍历 Set。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>用于对每个成员执行某种操作，没有返回值。</p>
<p><strong>forEach方法的参数就是一个处理函数</strong>。</p>
<h4 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h4><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>

<p>数组的map和filter方法也可以间接用于 Set ，因此<strong>使用 Set 可以很容易地实现并集、交集和差集</strong>。</p>
<h2 id="7-2-WeakSet"><a href="#7-2-WeakSet" class="headerlink" title="7.2 WeakSet"></a>7.2 WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的<strong>成员只能是对象</strong>。</p>
<p>WeakSet 中的对象都是<strong>弱引用</strong>，如果其他对象都不再引用某一对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。因此 <strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。</p>
<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数(数组的成员只能是对象)，该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>
<p>WeakSet 结构有以下三个方法：</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向 WeakSet 实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除 WeakSet 实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<p>WeakSet 没有size属性，<strong>没有办法遍历它的成员</strong>(由于弱引用特性，不支持遍历)。</p>
<h2 id="7-3-Map"><a href="#7-3-Map" class="headerlink" title="7.3 Map"></a>7.3 Map</h2><p>Map 数据结构类似于对象，是<strong>键值对的集合</strong>，但是“键”的范围不限于字符串，<strong>各种类型的值（包括对象）都可以当作键</strong>。</p>
<p>作为构造函数，Map 也可以<strong>接受一个数组作为参数</strong>。该数组的成员是一个个表示键值对的数组。</p>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法：</p>
<ul>
<li><strong>size 属性</strong>：返回 Map 结构的成员总数。</li>
<li><strong>Map.prototype.set(key, value)</strong>：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li><strong>Map.prototype.get(key)</strong>：读取key对应的键值，如果找不到key，返回undefined。</li>
<li><strong>Map.prototype.has(key)</strong>：has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><strong>Map.prototype.delete(key)</strong>：删除某个键，返回true。如果删除失败，返回false。</li>
<li><strong>Map.prototype.clear()</strong>：清除所有成员，没有返回值。</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li><strong>Map.prototype.keys()</strong>：返回键名的遍历器。</li>
<li><strong>Map.prototype.values()</strong>：返回键值的遍历器。</li>
<li><strong>Map.prototype.entries()</strong>：返回所有成员的遍历器。</li>
<li><strong>Map.prototype.forEach()</strong>：遍历 Map 的所有成员。</li>
</ul>
<p><strong>Map 的遍历顺序就是插入顺序。</strong></p>
<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。</p>
<h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ul>
<li>数组与Map的相互转换</li>
<li>对象与Map的相互转换</li>
<li>JSON与Map的相互转换</li>
</ul>
<h2 id="7-4-WeakMap"><a href="#7-4-WeakMap" class="headerlink" title="7.4 WeakMap"></a>7.4 WeakMap</h2><h1 id="8-Promise-对象"><a href="#8-Promise-对象" class="headerlink" title="8. Promise 对象"></a>8. Promise 对象</h1><h2 id="8-1-Promise-的含义"><a href="#8-1-Promise-的含义" class="headerlink" title="8.1 Promise 的含义"></a>8.1 Promise 的含义</h2><p>Promise 简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>Promise对象有以下两个特点：</p>
<ul>
<li><strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。(这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的)</li>
</ul>
<h2 id="8-2-基本用法"><a href="#8-2-基本用法" class="headerlink" title="8.2 基本用法"></a>8.2 基本用法</h2><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，<strong>不用自己部署</strong>。</p>
<ul>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并<strong>将异步操作的结果，作为参数传递出去</strong>。</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<p>如果<strong>调用resolve函数和reject函数时带有参数</strong>，那么它们的参数会被<strong>传递给回调函数</strong>。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<ul>
<li>then方法可以接受两个回调函数作为参数：第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用(可选)。</li>
<li>then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行。</li>
</ul>
<h2 id="8-3-Promise-prototype-then"><a href="#8-3-Promise-prototype-then" class="headerlink" title="8.3 Promise.prototype.then( )"></a>8.3 Promise.prototype.then( )</h2><p>then方法<strong>返回的是一个新的Promise实例</strong>，因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<h2 id="8-4-Promise-prototype-catch"><a href="#8-4-Promise-prototype-catch" class="headerlink" title="8.4 Promise.prototype.catch( )"></a>8.4 Promise.prototype.catch( )</h2><p>是.then(null, rejection)或.then(undefined, rejection)的别名，<strong>用于指定发生错误时的回调函数</strong>。</p>
<p>Promise 对象的错误<strong>具有“冒泡”性质</strong>，会一直向后传递，直到被捕获为止。</p>
<p>一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），<strong>总是使用catch方法</strong>。catch方法返回的还是一个 Promise 对象，因此<strong>后面还可以接着调用then方法</strong>。</p>
<ul>
<li>如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即<strong>不会有任何反应</strong>。</li>
</ul>
<h2 id="8-5-Promise-prototype-finally"><a href="#8-5-Promise-prototype-finally" class="headerlink" title="8.5 Promise.prototype.finally( )"></a>8.5 Promise.prototype.finally( )</h2><p>用于<strong>指定不管 Promise 对象最后状态如何，都会执行的操作</strong>。</p>
<ul>
<li>finally方法的回调函数<strong>不接受任何参数</strong>，故无法知道前面的 Promise 状态到底是fulfilled还是rejected。因此finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</li>
<li>finally本质上是then方法的特例。</li>
<li>finally方法总是会返回原来的值。</li>
</ul>
<h2 id="8-6-Promise-all"><a href="#8-6-Promise-all" class="headerlink" title="8.6 Promise.all( )"></a>8.6 Promise.all( )</h2><p>Promise.all方法用于<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>接受一个数组作为参数，p1、p2、p3都是 Promise 实例。(如果不是，就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理)</li>
<li>p的状态由p1、p2、p3决定：<ul>
<li>只有p1、p2、p3的状态<strong>都变成fulfilled</strong>，p的状态才会变成fulfilled，此时p1、p2、p3的<strong>返回值组成一个数组，传递给p的回调函数</strong>。</li>
<li>只要p1、p2、p3之中<strong>有一个被rejected</strong>，p的状态就变成rejected，此时<strong>第一个被reject的实例的返回值，会传递给p的回调函数</strong>。</li>
</ul>
</li>
<li>如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。</li>
</ul>
<h2 id="8-7-Promise-race"><a href="#8-7-Promise-race" class="headerlink" title="8.7 Promise.race( )"></a>8.7 Promise.race( )</h2><p>Promise.race方法同样是<strong>将多个 Promise 实例，包装成一个新的 Promise 实例</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<ul>
<li>只要p1、p2、p3之中<strong>有一个实例率先改变状态，p的状态就跟着改变</strong>。那个<strong>率先改变的 Promise 实例的返回值，就传递给p的回调函数</strong>。</li>
<li>Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。</li>
</ul>
<h2 id="8-8-Promise-resolve"><a href="#8-8-Promise-resolve" class="headerlink" title="8.8 Promise.resolve( )"></a>8.8 Promise.resolve( )</h2><p>Promise.resolve方法能够<strong>将现有对象转为 Promise 对象</strong>。</p>
<p>Promise.resolve方法的参数分成四种情况：</p>
<ul>
<li>参数是一个<strong>Promise 实例</strong>：不做任何修改、原封不动地返回这个实例。</li>
<li>参数是一个<strong>thenable对象</strong>：(thenable对象指的是具有then方法的对象)会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</li>
<li>参数<strong>不是具有then方法的对象，或不是对象</strong>:返回一个新的 Promise 对象，状态为resolved。（Promise.resolve方法的参数，会同时传给回调函数，回调函数会立即执行）</li>
<li><strong>不带有任何参数</strong>：直接返回一个resolved状态的 Promise 对象。<ul>
<li>立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li>
</ul>
</li>
</ul>
<h2 id="8-9-Promise-reject"><a href="#8-9-Promise-reject" class="headerlink" title="8.9 Promise.reject( )"></a>8.9 Promise.reject( )</h2><p>Promise.reject(reason)方法也会<strong>返回一个状态为rejected的新的 Promise 实例</strong>。</p>
<ul>
<li>Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。</li>
</ul>
<h1 id="9-Generator-函数的语法"><a href="#9-Generator-函数的语法" class="headerlink" title="9. Generator 函数的语法"></a>9. Generator 函数的语法</h1><p>async函数<strong>返回一个 Promise 对象</strong>，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/快乐暑假第12天/" data-id="cjymaxnms000bb8uw08k2199l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/22/快乐暑假第13天/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          快乐暑假第13天
        
      </div>
    </a>
  
  
    <a href="/2019/07/19/快乐暑假第11天/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">快乐暑假第11天</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/26/快乐暑假第17天——开始学习nodejs/">快乐暑假第17天——开始学习nodejs</a>
          </li>
        
          <li>
            <a href="/2019/07/25/快乐暑假第16天——继续做Bolo/">快乐暑假第16天——继续做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/24/快乐暑假第15天——开始做Bolo/">快乐暑假第15天——开始做Bolo</a>
          </li>
        
          <li>
            <a href="/2019/07/23/快乐暑假第14天——学习jQuery/">快乐暑假第14天——学习jQuery</a>
          </li>
        
          <li>
            <a href="/2019/07/22/快乐暑假第13天/">快乐暑假第13天</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>